{"meta":{"title":"🍧 Peach","subtitle":"equne","description":"蜜桃想写可爱的代码","author":"equne","url":"https://equnee.github.io","root":"/"},"pages":[],"posts":[{"title":"🦋 HashMap","slug":"note/Data-Structure/data-structure_HashMap","date":"2023-03-09T15:11:32.969Z","updated":"2023-03-16T17:33:47.370Z","comments":true,"path":"note/Data-Structure/data-structure_HashMap/","link":"","permalink":"https://equnee.github.io/note/Data-Structure/data-structure_HashMap/","excerpt":"","text":"（本文编辑中）本文结构： %%{ init: { 'themeVariables': { 'fontSize': '13px' } } }%% graph LR T((\"HashMap\")) T --> A(\"HashMap介绍\"); T --> B(\"HashMap源码\"); A --> a[\"原理\"] B --> b[\"属性\"] B --> b2[\"构造方法\"] B --> b3[\"实现方法\"] B --> b4[\"内部类\"] class T cssClass 注：本文制作的流程图仅为个人理解，仅供参考。 一、HashMap介绍1. 原理（1）HashMap怎么存取 使用数组保存、通过数组索引获取： %%{ init: { 'themeVariables': { 'fontSize': '13px' } } }%% graph TD T((\"HashMap怎么存取值\")):::p T --> |\"数据以键值对形式存储\"| A[\"key — value\"] A --> |\"包装为Node数组对象\"| B[\"Node { key, value }\"] B --> |\"通过node数组下标保存对应数据\"| C[\"node[0] = new Node { key, value }node[1] = new Node { key, value }node[2] = new Node { key, value } ...\"] C -.-> |\"[ 保存 ] 遍历数组，对应key和value\"| D[\"for (Node node : nodes)\"] C --> |\"[ 获取 ] 通过 数组索引 获取（key的hash值）\"|E[\"node[ hash(key) ] = value\"]:::lb classDef p fill:#ddaebd style E fill:#d9dfeb, stroke:#657eae,stroke-width:2px,stroke-dasharray: 3 3 （2）Hash算法怎么写 计算数组索引值： %%{ init: { 'themeVariables': { 'fontSize': '13px', 'clusterBorder': 'none', 'clusterBkg': '#f0f2f7' } } }%% graph TD T((\"Hash算法怎么写？\")):::p T --> |\"如何计算出数组索引？hash(key)\"| A[\"* 因为Node数组有固定的初始化默认长度（length）* 索引值需限定在数组长度范围内（0～length-1）* 索引值还要尽可能平衡、分布均匀\"] A --> B([\"取模运算：hash % length\"]) B ==> |\"（更好的方案：使用位运算效率更高）\"| C([\"位运算：hash & (length - 1)\"]) C -.- c(\"length必须是2的n次幂\"):::b subgraph \"前置条件\" c -.- c2[\"假如 key = 20, length = 16, hash & (length-1):0001 0100 // 20 0000 1111 // 150000 0100 // =4\"]:::c2 end classDef p fill:#ddaebd classDef b fill:#d2d9e7, stroke-width: 0px style c2 color: #86868b, fill:#ebedf3, stroke-dasharray: 3 3 %% 取模运算 style B fill: #f4e4e9 %% \"位运算\" style C fill:#b8c3d9, stroke:#657eae,stroke-width:2px 为了解决取模的效率问题，采用了位运算的方法：index = hash值 &amp; (length -1)此时需要一个前置条件：length的长度必须是2的n次幂。当length的长度是2n时，有以下公式成立： num%2n = num&amp;(2n-1) 。 🦋 因为就像十进制取余数一样，若除以10或10的整次幂数，余数刚好是取低位上的数字。同理，二进制取余数只要除以2的n次幂数，低位上的数字就是我们需要的余数。而(2n - 1)的二进制有效位都是1，和n位的1作与运算相当于取低n位的值。 length的长度刚好是2的n次幂，扩容也是按原来的2倍容量进行扩容，可以加快hash计算、减少hash冲突。 🦋 加快hash计算： 两倍扩容机制使容量一直保持在2的n次幂数，就可以使用位运算代替取模运算，提升hash计算效率。 当容量保持为2的n次幂时，每次扩容时位运算计算得出的余数不变，数据存放的索引位置也保持不变。而使用%计算时，结果会因为容量的变化而改变（模运算会产生小数点），每次扩容时数据在数组中存放的位置会发生改变（数据漂移），影响性能。 🦋 减少hash冲突： 将容量保持为偶数进行hash计算时，经过(length-1)后，计算出的索引值为奇数和偶数的概率相同（取决于随机生成的hash值）； 而使用奇数容量进行hash计算时，经过(length-1)后，最终结果均为偶数，这样任何 hash 值都只会被散列到数组的偶数下标位置上，这浪费了近一半的空间。 因此2的n次幂容量、双倍扩容机制可以使容量保持在偶数值，可以使添加的元素在HashMap的数组中均匀分布，减少hash碰撞。 （3）Hash冲突怎么办 Hash冲突 %%{ init: { 'themeVariables': { 'fontSize': '13px' } } }%% graph TD T((\"1. Hash冲突怎么优化\")):::p --> T1(\"hash表里可以存储元素的位置被称为“桶（bucket）”\") T1 --> |\"通常情况\"| A(\"单个“桶”里存储一个元素，此时性能最佳\"):::g A -.-> |\"O(1)\"| a[\"hash算法可以根据hashCode值计算出“桶”的存储位置，接着从“桶”中取出元素。\"] T1 --> |\"哈希冲突的情况\"| B(\"单个桶会存储多个元素（hash值相同）\"):::g B -.-> |\"O(n)\"|b([\"多个元素以 链表 形式存储\"]):::B b --> 2T((\"2. Hash冲突很大怎么优化\")):::p subgraph \"（链表必须按顺序搜索，存取性能差）\" 2T --> C([\"将链表结构转为红黑树\"]):::B C -.- |\"O(logn)\"|c[\"以树的高度为最差查询性能，永远不会出现O(n)的情况。\"]:::info end classDef p fill:#ddaebd classDef g fill:#f4e4e9 classDef B fill:#d9dfeb, stroke:#657eae,stroke-width:2px classDef info fill:#f6f6f7,color:#737379, stroke-width: 2px, stroke-dasharray: 3 3 Hash冲突示意图 %%{ init: { 'themeVariables': { 'clusterBorder': 'none', 'clusterBkg': '#ececee' } } }%% %% 链表超过8时树化成红黑树 graph TD subgraph \"Node[]\" Entry0[\"Node0Node＜K,V>\"] -.- Node1 -.- Node2 -.- Node3 -.- Node4 -.- Node5 -.- Node6 end subgraph 链表 Node1 --> A[Node] --> B[Node] --> C[Node] --> D[Node] --> E[Node] --> F[Node] end subgraph 红黑树 Node4 --> a[Node] a[Node] --> b[Node] b --> b1[Node] b --> b2[Node] a --> c[Node] c --> c1[Node] c --> c2[Node] b1 --> d[Node] b1 --> d2[Node] end style 链表 fill:#ddebe6 style 红黑树 fill:#f4e4e9 2. 使用（1）基本使用Printer.printHashMapStructures(map); // 打印树结构getMapFromStringParam(); （2）如何遍历graph LR T((\"遍历HashMap的5种方法\")):::p T --> A([\"entrySet\"]):::lp T --> B([\"keySet\"]):::lp T --> C([\"forEach\"]):::lp T --> |\"流操作\"|D([\"StreamApi.forEach\"]):::lp T -.-> E([\"values\"]) A -.-> a(\"（1）entrySet\") A -.-> a2(\"（2）entrySet + 迭代器\") B -.-> |\"（效率低）\"| b(\"（3）keySet + get()\") C -.-> c(\"（4）forEach + Lambda\") D -.-> d(\"（5）Stream().forEach（单线程）\") D -.-> d2(\"（6）Stream().forEach（多线程）\") E -.-> e(\"（7）仅遍历value\") classDef p fill:#ddaebd classDef lp fill:#f4e4e9 classDef B fill:#d9dfeb, stroke:#657eae,stroke-width:2px 遍历HashMap代码： package com.equne;import java.util.HashMap;import java.util.Iterator;import java.util.Map;public class Main &#123; /** （1）entrySet */ public static void traverse1(Map&lt;String, String&gt; map) &#123; for (Map.Entry&lt;String, String&gt; entry : map.entrySet())&#123; System.out.println(entry.getKey() + &quot;, &quot; + entry.getValue()); &#125; &#125; /** （2）迭代器（entrySet） */ public static void traverse2(Map&lt;String, String&gt; map) &#123; Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = map.entrySet().iterator(); while (iterator.hasNext())&#123; Map.Entry&lt;String, String&gt; entry = iterator.next(); System.out.println(entry.getKey() + &quot;, &quot; + entry.getValue()); &#125; &#125; /** （3）keySet + get() */ public static void traverse3(Map&lt;String, String&gt; map) &#123; for (String key : map.keySet())&#123; System.out.println(key + &quot;, &quot; + map.get(key)); &#125; &#125; /** （4）forEach + Lambda */ public static void traverse4(Map&lt;String, String&gt; map) &#123; map.forEach((key, value) -&gt; &#123; System.out.println(key + &quot;, &quot; + value); &#125;); &#125; /** （5）StreamApi（单线程） */ public static void traverse5(Map&lt;String, String&gt; map) &#123; map.entrySet().stream().forEach((entry) -&gt; &#123; System.out.println(entry.getKey() + &quot;, &quot; +entry.getValue()); &#125;); &#125; /** （6）StreamApi（多线程） */ public static void traverse6(Map&lt;String, String&gt; map) &#123; map.entrySet().stream().parallel().forEach((entry) -&gt; &#123; System.out.println(entry.getKey() + &quot;, &quot; +entry.getValue()); &#125;); &#125; /** （7）仅遍历value */ public static void traverse7(Map&lt;String, String&gt; map) &#123; for (String v : map.values())&#123; System.out.println(v); &#125; &#125; public static void main(String[] args) &#123; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;key1&quot;, &quot;value1&quot;); map.put(&quot;key2&quot;, &quot;value2&quot;); traverse1(map); traverse2(map); traverse3(map); traverse4(map); traverse5(map); traverse6(map); traverse7(map); &#125;&#125; entrySet 和 keySet Map.entrySet 迭代器会生成 EntryIterator，其返回的实例是一个包含 key/value 键值对的对象。 而 keySet 中迭代器返回的只是 key 对象，还需要到 map 中二次取值（多一个get方法的调用）。故 entrySet 要比 keySet 快一倍左右。（keySet适合仅需要操作key时使用）🔗 摘自：《Java修炼指南：高频源码解析》 foreach + Lambda 表达式（Java8 的新特性） forEach()：用于遍历动态数组中每一个元素并执行特定操作。 Lambda 表达式：箭头符号 -&gt;，其两边连接着输入参数和函数体。 Stream() 其实用Iterable本身的forEach方法即可，没有必要用流式操作。StreamApi适合在对集合进行其他流式操作之后使用。 补充：用流获取映射值的极端案例：Optional&lt;String&gt; value = map .entrySet() .stream() .filter(entry -&gt; entry.getKey().equals(key)) .map(Entry::getValue) // 双冒号：引用方法 .findFirst(); 🔗 摘自：《好代码，坏代码》 . 二、HashMap源码 注：本文源码版本均为：JDK 8 1. 属性// 🔹 常量// 默认的初始容量值（16）- 必须是2的n次幂static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;// 最大容量上限（2的30次方）static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;// 默认的负载因数（0.75）static final float DEFAULT_LOAD_FACTOR = 0.75f;// 树化阈值：当一个桶中的元素个数大于等于8时进行树化static final int TREEIFY_THRESHOLD = 8;// 树降级为链表的仓位计数阈值，当一个桶中的元素个数小于等于6时把树转化为链表。static final int UNTREEIFY_THRESHOLD = 6;// 将table树化的最小容量值（64）：当桶的个数达到64的时候才进行树化（至少应为4*TREEIFY_THRESHOLD，以避免调整大小和树化阈值之间的冲突。）static final int MIN_TREEIFY_CAPACITY = 64;// 🔹 变量// Node数组，又叫作桶（bucket）transient Node&lt;K,V&gt;[] table;// 作为entrySet()的缓存transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;// 元素的数量transient int size;// 记录hashMap的修改次数（每次扩容和更改 map 结构的计数器）transient int modCount;// 扩容阈值 = table.length * loadFactor（当size大于阈值时扩容）int threshold;// 负载因数：表示整体上table被占用的程度final float loadFactor; 2. 构造方法graph LR T((\"HashMap构造方法\")):::p T --> A([\"HashMap map1 = new HashMap();\"]):::lp T --> B([\"HashMap map2 = new HashMap(30);\"]):::lp T --> C([\"HashMap map3 = new HashMap(30, 0.5f);\"]):::lp T --> D([\"HashMap map4 = new HashMap(map);\"]):::lp A --- |\"无参构造方法\"|a(\"不指定容量，默认:16\") B --- |\"initialCapacoty\"| b(\"指定初始化容量：30\") C --- |\"initialCapacotyloadFactor\"| c(\"指定初始化容量、负载因数\") D --- |\"Map map\"| d(\"以指定map构造新map\") D -.- ci(\"* 注意：与上述仅创建空HashMap不同，此方法内部调用了put()存值table才真正进行了初始化。\"):::info classDef p fill:#ddaebd classDef lp fill: #f4e4e9 classDef info fill:#f6f6f7,color:#737379,stroke-dasharray: 3 3, stroke-width: 2px （1）HashMap() 无参数的构造方法/** * Constructs an empty HashMap with the default initial capacity(16) and the default load factor (0.75). * 以默认初始容量(16)和默认负载因数(0.75)，构造一个空的HashMap。 */public HashMap() &#123; // 🔻 将负载因数赋为默认值。 this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted&#125; （2）HashMap(20) 带初始容量的构造方法：/** * Constructs an empty HashMap with the specified initial capacity and the default load factor (0.75). * 以特定的初始容量和默认的负载因数(0.75)，构造一个空的HashMap * * @param initialCapacity 初始容量 * @throws IllegalArgumentException 初始容量为负值时抛出非法数据异常。 */ public HashMap(int initialCapacity) &#123; // 🔻 调用了带初始容量、负载因数的构造方法（详见下文(3)） this(initialCapacity, DEFAULT_LOAD_FACTOR); &#125; （3）HashMap(20, 0.5f)- HashMap() 带初始容量、负载因数的构造方法/** * Constructs an empty HashMap with the specified initial capacity and load factor. * 以特定的初始容量和负载因数构造一个空的HashMap。 * * @param initialCapacity 初始化容量 * @param loadFactor 负载因数 * @throws IllegalArgumentException if the initial capacity is negative * or the load factor is nonpositive * 当初始容量为负值、或负载因数为非正时抛出非法数据异常。 */public HashMap(int initialCapacity, float loadFactor) &#123; // 🔴 一、判断传入参数的合法性 // 🔹 初始容量值非负数 if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity); // 🔹 初始容量值不超过最大容量 if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; // 🔹 负载因数大于0且为数字 if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor); // 🔴 二、为配置参数赋值 // 🔹 为负载因数赋值 this.loadFactor = loadFactor; // 🔹 为扩容阈值赋值：使用tableSizeFor()将给定数值调整为2的次幂数。 this.threshold = tableSizeFor(initialCapacity);&#125; - tableSizeFor() 返回最接近给定目标容量的二次幂数值。/** * Returns a power of two size for the given target capacity. * 返回给定目标容量的二次幂数。 */static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125;/* 以下为备注： ------------------------------------------------- * 该位运算用于求出高位1之后每位都为1的结果。 因为将每位变为1，则加上1后刚好是一个二次幂数。 如(0000 1000)，使其第一位1后面都为1，即(0000 1111) ------------------------------------------------- */ // 如，initialCapacity = 9 // 🔴 将 n - 1 int n = cap -1; // n = 8 // 🔴 作位运算：1. 无符号位移 2. 与n作或的位运算。 n |= n &gt;&gt;&gt; 1; n = 0000 1000 n = 0000 0100 n = 0000 1100 n |= n &gt;&gt;&gt; 2; n = 0000 1100 n = 0000 0011 n = 0000 1111 // =15 n |= n &gt;&gt;&gt; 4; n = 0000 1111 n = 0000 0000 n = 0000 1111 n |= n &gt;&gt;&gt; 8; n = 0000 1111 n = 0000 0000 n = 0000 1111 n |= n &gt;&gt;&gt; 16; // 🔸 因为int是32位的，所以执行到16即可. // 🔴 返回位移结果n + 1 return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUN_CAPACITY : n + 1; n &lt; 0, 则返回 n = 1 n &gt;= 0, 且 n &gt;= 最大容量, 则返回最大容量 n &gt;= 0, 且 n &lt; 最大容量, 则返回 n + 1 （=16） 为什么先进行n-1操作：为了处理n刚好是二次幂数的情况。 🦋 若n已经是2的n次幂了，按照逻辑变1之后再加1，结果就会变成n的2倍了，与应有的结果不一致。如，n=16（0001 0000），位运算后 n=31（0001 1111）。 （4）HashMap(map)- HashMap() 带map的构造方法 /** * Constructs a new HashMap with the same mappings as the specified Map. * The HashMap is created with default load factor (0.75) and an initial capacity sufficient to hold the mappings in the specified Map. * 使用与指定Map相同的映射构造新的HashMap。 * 此HashMap由：默认负载因数(0.75)、足够的初始容量（足以存下指定Map）创建。 * * @param m the map whose mappings are to be placed in this map * @参数： m，原map * @throws NullPointerException if the specified map is null * @异常： 当原map为空时抛出空指针异常。 */public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; // 🔻 将负载因数赋为默认值。 this.loadFactor = DEFAULT_LOAD_FACTOR; // 🔻 调用putMapEntries()，将原有map存入新map。 putMapEntries(m, false);&#125; - putMapEntries() 赋值并初始化函数/** * Implements Map.putAll and Map constructor. * 赋值并构造函数。 * * @param m the map * @参数： m，传入的map * @param evict false when initially constructing this map, else true (relayed to method afterNodeInsertion). * @参数： evict，首次创建此map时返回false，非首次创建返回true。 */final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) &#123; int s = m.size(); // m的元素个数 // 🔴 一、若m中有元素，需要根据新Map的初始化情况为其扩容阈值赋值。 （若m无元素则无需赋值，直接使用给定的负载因数和扩容阈值(lf*cap)完成构造。） if (s &gt; 0) &#123; // 🔹 若数组未初始化：根据m中元素数量和负载因数计算新Map的扩容阈值。 if (table == null) &#123; // pre-size // m的扩容阈值 = 元素数量 / 负载因数（🔸+1.0F：对小数做向上取整以尽可能保证更大容量） float ft = ((float)s / loadFactor) + 1.0F; // 将m扩容阈值的数据类型转为整型，并限定在默认容量上限内 int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ? (int)ft : MAXIMUM_CAPACITY); // 若计算出m的扩容阈值 &gt; 新Map扩容阈值，调用tableSizeFor方法，将新Map扩容阈值设置为：该值最接近容量的2次幂数。 if (t &gt; threshold) threshold = tableSizeFor(t); &#125; // 🔹 若数组已初始化、且Map中的元素数量超过了其扩容阈值：扩容。 else if (s &gt; threshold) resize(); // 🔴 二、赋值：遍历m的entry，逐个赋值到新Map上。 for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123; K key = e.getKey(); V value = e.getValue(); // 🔹 调用putVal()为每个节点赋值（此时新Map才真正初始化完成） putVal(hash(key), key, value, false, evict); &#125; &#125;&#125; ((float)s / loadFactor) + 1.0F + 1.0F：为了让浮点数进行除法计算后向上取整，以尽可能保证足够容量。 3. 实现方法（1）Get()%%{ init: { 'themeVariables': { 'fontSize': '13px' } } }%% graph TD T([\"如何从HashMap获取元素？\"]):::p T --> B(\"先根据key找到桶位\") B --> A([\"判断当前位置的元素是否就要找的值\"]):::lp A --> |\"是\"| C2[\"核对k-v值后返回\"]:::b A --> |\"否（有hash冲突）\"| C([\"判断为链表或红黑树\"]):::lp C -.-> |\"链表\"|a[\"遍历链表、核对k-v值后返回\"]:::b C -.-> |\"红黑树\"|b[\"从树的根节点查找、核对k-v值后返回\"]:::b classDef p fill:#ddaebd classDef b fill:#d9dfeb classDef lp fill: #f4e4e9 - get() 通过key获取value/** * Returns the value to which the specified key is mapped, * or null if this map contains no mapping for the key. * 返回指定key所映射的value值。若找不到对应value时返回null。 * * 但返回null不一定代表不存在该key映射的值，有可能是该key保存的value值正是&quot;null&quot;。 * 可以使用containsKey()来识别。 */public V get(Object key) &#123; // Node Node&lt;K,V&gt; e; // 🔻 使用key和其hash值调用getNode()方法，返回Node的value值。 return (e = getNode(hash(key), key)) == null ? null : e.value;&#125; null ? null : e.value：若该值为null，返回null；若该值不为null，返回e.value - getNode() 获取Node/** * Implements Map.get and related methods. * 实现了Map.get()和相关方法 * * @param hash key的hash值 * @param key key * @return 返回该key对应的Node，若无返回null */final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; // Node数组 Node&lt;K,V&gt; first, e; // Node int n; // 数组长度 K k; // key // 🔻 判断该数组非空 // 并根据传入key的hash值计算出该hash值对应的Node的下标，将该数组下标对应的值赋值给first-Node（意为hash冲突时第一个节点） if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; // 🔹 先判断若first刚好是我们要找的Node时：直接返回first if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; // 🔹 当first尾部还有元素（即有hash冲突）时，根据Node的结构取值。 if ((e = first.next) != null) &#123; // 🔸 红黑树：将Node转为TreeNode类型，并调用getTreeNode()取值。 if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); // 🔸 链表：遍历取值。 do &#123; if (e.hash == hash &amp;&amp; // 判断hash值和key值都相同 ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; // 🔻 数组为空，返回null return null;&#125; （2）Remove()%%{ init: { 'themeVariables': { 'fontSize': '13px' } } }%% graph TD T([\"如何从HashMap删除元素？\"]):::p T --> B(\"先根据key找到桶位\") B --> A([\"判断当前位置的元素是否就要删除的值\"]):::lp A --> |\"是\"| C2[\"直接删除该元素\"]:::b A --> |\"否（有hash冲突）\"| C([\"判断为链表或红黑树\"]):::lp C --> |\"链表\"|a[\"将上个位置的指针（跳过该值）指向下个位置\"]:::b C --> |\"红黑树\"|b[\"去掉当前节点后自平衡\"]:::b b -.- bt[\"（树长度小于6时转为链表）\"]:::info classDef info fill:#f6f6f7,color:#737379stroke-width: 3px, stroke-dasharray: 3 3 classDef p fill:#ddaebd classDef b fill:#d9dfeb classDef lp fill: #f4e4e9 - remove() 删除元素 /** * Removes the mapping for the specified key from this map if present. * 根据指定key删除映射。 * * @param key 要从map中删除映射的键 * @return 返回与键关联的前值，若前值为空返回null */public V remove(Object key) &#123; Node&lt;K,V&gt; e; // 🔻 调用removeNode()删除该键映射，若前值为空返回null，若前值非空返回前值。 return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value;&#125; - removeNode() 删除Node /** * Implements Map.remove and related methods. * 实现删除和相关方法。 * * @param hash key的hash值 * @param key key * @param value 若有值时匹配该值 * @param matchValue 若为真：仅值相等时删除 * @param movable 为false:删除时不移动其他值 * @return 返回Node，若无该Node返回null */final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) &#123; Node&lt;K,V&gt;[] tab; // Node数组（引用当前hashMap的散列表） Node&lt;K,V&gt; p; // 当前Node元素：p int n, index; // n：数组长度，index：数组下标 // 数组非空、当前索引位置的Node元素p非空 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) &#123; Node&lt;K,V&gt; node = null, e; // 要删除的Node元素：node；当前节点的下个节点：e(=p.next) K k; V v; // 当前元素p的key和value值 // 🔹 第一个位置刚好是要删除的元素：赋值给node，执行下方修改指针的代码 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) node = p; // 🔹 存在哈希冲突时：根据链表或红黑树结构获取要删除的元素node else if ((e = p.next) != null) &#123; // 🔸 红黑树：使用getTreeNode()获取元素，赋值给node。 if (p instanceof TreeNode) node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key); // 🔸 链表：用hash值和键值对遍历：赋值给node。 else &#123; do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; node = e; break; &#125; p = e; &#125; while ((e = e.next) != null); &#125; &#125; // 🔴 根据元素(node)的结构删除 if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) &#123; // 🔹 若要删除树结构节点：使用removeTreeNode()移除树节点 if (node instanceof TreeNode) ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable); // 🔹 若要删除Node节点上的元素（刚好是第一个元素）：将该节点赋值为下个元素 else if (node == p) tab[index] = node.next; // 🔹 若要删除链表节点：指向其下个元素的next，将链表链接起来。 else p.next = node.next; ++modCount; // 记录修改次数（可以判断是否修改成功） --size; // 数组长度自减 afterNodeRemoval(node); return node; &#125; &#125; return null;&#125; （3）Put()%%{ init: { 'themeVariables': { 'fontSize': '13px' } } }%% graph TD T([\"如何向HashMap添加元素？\"]):::p T --> B(\"先根据key找到桶位\") B --> A([\"判断当前索引是否就是要添加元素的位置\"]):::lp A --> |\"无元素\"| C2[\"直接将元素添加到该位置\"]:::b A --> |\"有元素（有hash冲突）\"| C([\"判断为链表或红黑树\"]):::lp C --> |\"链表\"|a[\"将元素添加到链表尾部\"]:::b C --> |\"红黑树\"|b[\"将元素添加到树尾部\"]:::b a -.- at[\"链表长度超过8、且桶数量大于64时转为树（*桶数小于64时不会树化，只会扩容）\"]:::info classDef info fill:#f6f6f7,color:#737379stroke-width: 3px, stroke-dasharray: 3 3 classDef p fill:#ddaebd classDef b fill:#d9dfeb classDef lp fill: #f4e4e9 + put() 添加元素/** * Associates the specified value with the specified key in this map. If the map previously contained a mapping for the key, the old value is replaced. * 存值：将指定值与此映射中的指定键相关联。如果映射先前包含键的映射，则将替换旧值。 * * @param key * @param value * @return 返回被替换的原值 */public V put(K key, V value) &#123; // 调用putVal()方法存值 return putVal(hash(key), key, value, false, true);&#125; - putVal() 赋值方法（若key已有值时默认替换）/** * Implements Map.put and related methods. * 实现了Map赋值以及相关方法。 * * @param hash key的hash值 * @param key key值 * @param value 需要赋的值 * @param onlyIfAbsent 是否保留原值（默认为false：会替换原值） * @param evict false:表处于创建状态 * @return 返回前值，如果没有则为空 */final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; // Node数组 Node&lt;K,V&gt; p; // Node int n, i; // n：数组长度， i：数组索引 // 🔴 一、若空数组：初始化 // 当数组为空、长度为0时：扩容，并获得Node数组长度n（容量） if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 🔴 二、若空索引：直接存 // 若传入的key计算出的索引位置无元素，则使用键值对在该位置上创建Node，putVal()完成。 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); // 🔴 三、若索引非空：根据情况存值 // 可能有hash冲突，判断该Node是否为链表或红黑树进行存值。 else &#123; Node&lt;K,V&gt; e; // node K k; // key // 🔹 若p刚好在当前索引位置的第一个节点上（未涉及到链表或红黑树），将该Node赋值给e以备存值（当前Node的key值和传入的key值相等） if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // 🔹 TreeNode类型：通过putTreeVal()方法在红黑树上插入键值对，赋值给e以备存值。 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 🔹 链表类型：循环直到将元素插入链表尾部，赋值给e以备存值。 else &#123; for (int binCount = 0; ; ++binCount) &#123; // binCount：链表节点个数 // 🔸 若已遍历到链表尾部：使用newNode()在尾部再添加一个新节点并存值。 if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); // * 若添加节点后链表的长度超过树化阈值： // 通过treeifyBin()将链表转化为红黑树，跳出循环，putVal()完成。 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; // 🔸 若还未遍历到尾部、且该节点的key值与传入key值相等： // 则跳出循环，执行下方替换原值的判断。 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; // 🔸 继续循环遍历链表 p = e; &#125; &#125; // 🔻 替换并输出原值（key已有值时） if (e != null) &#123; // existing mapping for key V oldValue = e.value; // 若设置了替换原值、或原值为空时：存值 if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); // 访问后回调（❓ return oldValue; &#125; &#125; ++modCount; // 记录修改次数（方便在迭代中检测结构性变化） // 🔻 若存值后元素数量大于扩容阈值，则扩容。 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); // 插入后回调（❓ return null;&#125; 比较时先比较hash值，hash相同的时候，再使用equals方法进行比较：if(e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) 因为hash是整数，比较的性能一般要比equals()高很多，使用短路与：hash不同，就没有必要调用equals方法了，这样整体上可以提高比较性能。 + putIfAbsent() 赋值，且已有值时不进行覆盖@Overridepublic V putIfAbsent(K key, V value) &#123; // 🔻 与默认的put()区别在于第四个参数：onlyIfAbsent（为true时不覆盖原值） return putVal(hash(key), key, value, true, true);&#125; （4）Resize() - 扩容① 何时扩容%%{ init: { 'themeVariables': { 'fontSize': '14px' } } }%% graph TD T([\"HashMap何时需要扩容？\"]):::p T --> |\"1. 初始化\"| A(\"1. table为null 或长度为0时\"):::lp T --> |\"2. 存值\"| B(\"2. 添加元素且元素数量即将超过扩容阈值（threshold）时\"):::lp B -.- |\"hreshold 可以由 tableSizeFor() 计算得到\"| b[\"tableSizeFor()：可以计算出大于当前方法入参值，并且和当前方法入参值最接近的2的幂数。\"]:::info classDef p fill: #ddaebd classDef lp fill: #f4e4e9 classDef lb fill: #d9dfeb classDef info fill:#f6f6f7,color:#737379, stroke-width: 2px, stroke-dasharray: 3 3 ② 如何扩容 %%{ init: { 'themeVariables': { 'fontSize': '14px' } } }%% graph TD T([\"HashMap如何扩容？\"]):::p T --> A(\"2倍扩容，创建新数组\") A --> B(\"移动元素到新数组（重新计算hash）\") B --> b([\"判断元素类型调整位置\"]):::lp b -.-|\"单个值\"| b1[\"①原位置② 原位置 + 原容量\"]:::lb b -.-|\"红黑树\"| b2[\"split()分割树①一棵：原位置②另一棵：原位置 + 原容量\"]:::lb b -.-|\"链表\"| b3[\"①低位链表：原位置②高位链表：原位置 + 原容量\"]:::lb classDef p fill: #ddaebd classDef lp fill: #f4e4e9 classDef lb fill: #d9dfeb 调整位置的原因： 因为HashMap计算索引位置是根据hash值 &amp; (当前容量 -1)，因此当容量改变时，一些原本的索引位置也会发生改变。扩容的同时重新调整元素位置，取值时才能正确匹配到相应的键值对。 ③ 如何调整位置 元素位置如何改变？ %%{ init: { 'themeVariables': { 'fontSize': '14px' } } }%% graph TD T([\"元素位置如何改变？\"]):::p T --> A(\"hash值 & 原长度\"):::lb A --> a[\"结果为0，位置不变\"]:::lp A --> b[\"结果为1，在新位置\"]:::lp a -.- at[\"如，原hash值=3（原位置=3），数组长度16， hash & 16： 0000 0011 // 3 0001 0000 // 16 0000 0000 // =0则，新位置 = 原位置 = 3\"]:::info b -.- bt[\"如，原hash值=19（原位置=3），数组长度16，hash & 16： 0001 0011 // 19 0001 0000 // 16 0001 0000 // =1则，新位置 = 原位置 + 原容量 = 19\"]:::info classDef p fill: #ddaebd classDef lp fill: #f4e4e9 classDef lb fill: #d9dfeb classDef info fill:#f6f6f7,color:#737379, stroke-width: 2px, stroke-dasharray: 3 3 满足“(e.hash &amp; oldCap)==0”条件的节点可以继续在原索引位上存储，不满足该条件的节点则需要进行移动操作。 HashMap中，table数组都是以2的幂数进行扩容操作的，就是将原容量值左移1位。 因此进行扩容操作后，各个K-V键值对节点是否仍能在原索引位上，取决于新增的一位（oldCap的值）在进行与运算时是否为0。 链表元素移动： 满足“(e.hash &amp; oldCap)==0”条件的节点会构成新的单向链表，这个链表中的节点会按照原索引位顺序存储于新的HashMap集合的table数组中； 满足“(e.hash &amp;oldCap) !=0”条件的节点会构成另一个新的单向链表，并且将原索引值+原数组长度的计算结果作为新的索引值存储于新的HashMap集合的table数组中。 红黑树元素移动： 如果扩容前某个索引位上的K-V键值对节点是以红黑树结构组织的，则需要根据以上原理，将这棵红黑树拆分成两棵新的红黑树（如果红黑树中的节点数量不大于6，那么会将红黑树结构转换为链表结构）。一棵红黑树（或链表）留在原索引位上，另一棵红黑树（或链表）放到原索引值+原数组容量值的计算结果对应的新索引位上。 红黑树中隐含的双向链表结构非常重要，在将红黑树结构转换为链表结构的过程中，需要使用这个隐含的双向链表进行遍历；在红黑树结构的拆分过程中，也需要使用这个隐含的双向链表进行遍历。上述源码描述的过程如图3-65所示。 - resize() 扩容/** * Initializes or doubles table size. If null, allocates in accord with initial capacity target held in field threshold. * Otherwise, because we are using power-of-two expansion, the elements from each bin must either stay at same index, or move with a power of two offset in the new table. * 初始化或二倍扩容。若为空，根据阈值和初始容量分配。 * 由于使用2次幂扩容，因此每个元素保持相同索引，或在新表中以二次幂偏移量移动。 * * @return table*/final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; // 原table int oldCap = (oldTab == null) ? 0 : oldTab.length; // 扩容前的table长度，若无元素返回0 int oldThr = threshold; // 原阈值 int newCap, newThr = 0; // 新长度、新阈值 // 🔴 一、设置扩容阈值 // 🔹 ① 若已初始化(原数组有元素)：检查数组长度并设置2倍扩容阈值。 if (oldCap &gt; 0) &#123; // 🔸 若原数组长度超过最大容量值：—&gt; 已到达容量上值，无法再扩容，返回原表。 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; // 🔸 若原数组长度2倍扩容后仍未超过容量上限，且原数组长度超过了默认初始容量：—&gt; 原扩容阈值设置为2倍。 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; // 🔹 ② 若未初始化(原数组无元素)，但已设置过扩容阈值(&gt;0) ：将新数组长度设置为该扩容阈值。 else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; // 🔹 ③ 若未初始化(原数组无元素)，且未设置过扩容阈值：使用系统设置的默认数组长度和默认阈值赋值。 else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; // 🔴 二、检查扩容阈值 // 若新扩容阈值仍为0：使用新数组长度计算新的扩容阈值（并将数组长度限制在最大容量上限内） if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; // 设置扩容阈值 threshold = newThr; // 🔴 三、扩容 @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) // 🔹 新建数组 Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; // 使用新的数组长度创建新数组 table = newTab; // 🔹 移动元素到新数组 // - 若原数组为空，无需移动，直接返回该数组。 // - 若原数组非空：移动数据到新数组。 if (oldTab != null) &#123; // 🔸 外层循环：遍历原数组元素 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; // 清空原值，便于GC回收。 oldTab[j] = null; // ① 单个值 if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; // 原位 或 +旧容量oldCap // ② 红黑树：分割 else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); // ③ 链表： else &#123; // preserve order // 低位链表：位置不变 Node&lt;K,V&gt; loHead = null, loTail = null; // 高位链表：位置 + 容量 Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; // 🔸 内层循环：计算新节点的索引位置。 do &#123; next = e.next; // true：位置不变（低位链表） if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; // false：位置 + 容量（高位链表） else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); // 低位链表赋值 if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; // 高位链表赋值 if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; // 🔹 返回新数组 return newTab;&#125; - split() 来自Tree bins内部类的方法：/** * Splits nodes in a tree bin into lower and upper tree bins, * or untreeifies if now too small. Called only from resize; * see above discussion about split bits and indices. * * @param map the map * @param tab the table for recording bin heads * @param index the index of the table being split * @param bit the bit of hash to split on */final void split(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int index, int bit) &#123; TreeNode&lt;K,V&gt; b = this; // Relink into lo and hi lists, preserving order TreeNode&lt;K,V&gt; loHead = null, loTail = null; TreeNode&lt;K,V&gt; hiHead = null, hiTail = null; int lc = 0, hc = 0; for (TreeNode&lt;K,V&gt; e = b, next; e != null; e = next) &#123; next = (TreeNode&lt;K,V&gt;)e.next; e.next = null; if ((e.hash &amp; bit) == 0) &#123; if ((e.prev = loTail) == null) loHead = e; else loTail.next = e; loTail = e; ++lc; &#125; else &#123; if ((e.prev = hiTail) == null) hiHead = e; else hiTail.next = e; hiTail = e; ++hc; &#125; &#125; if (loHead != null) &#123; if (lc &lt;= UNTREEIFY_THRESHOLD) tab[index] = loHead.untreeify(map); else &#123; tab[index] = loHead; if (hiHead != null) // (else is already treeified) loHead.treeify(tab); &#125; &#125; if (hiHead != null) &#123; if (hc &lt;= UNTREEIFY_THRESHOLD) tab[index + bit] = hiHead.untreeify(map); else &#123; tab[index + bit] = hiHead; if (loHead != null) hiHead.treeify(tab); &#125; &#125;&#125; 4. 内部类（1）Iterators- nextNode() HashMap实现了Iterator(迭代器)接口。 abstract class HashIterator &#123; Node&lt;K,V&gt; next; // 将返回的下个entry Node&lt;K,V&gt; current; // 当前 entry int expectedModCount; // 用于快速失败的属性 int index; // 当前索引 HashIterator() &#123; expectedModCount = modCount; Node&lt;K,V&gt;[] t = table; current = next = null; index = 0; if (t != null &amp;&amp; size &gt; 0) &#123; // advance to first entry do &#123;&#125; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null); &#125; &#125; final Node&lt;K,V&gt; nextNode() &#123; Node&lt;K,V&gt;[] t; Node&lt;K,V&gt; e = next; // 若modCount不等于expectedModCount：抛出异常 if (modCount != expectedModCount) throw new ConcurrentModificationException(); // 若指定Node为空：抛出异常 if (e == null) throw new NoSuchElementException(); // 若next指向的Node（即当前Node的next的值）不为空，且数组不为空： if ((next = (current = e).next) == null &amp;&amp; (t = table) != null) &#123; // 限定索引不超出长度、且下个位置仍有元素。 do &#123;&#125; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null); &#125; return e; &#125; // ... // EntryIterator，继承自HashIterator final class EntryIterator extends HashIterator implements Iterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123; public final Map.Entry&lt;K,V&gt; next() &#123; return nextNode(); &#125; &#125;&#125; 遍历元素时使用modCount属性判断HashMap是否发生结构性变化 🔹 属性：- modCount：HashMap类中的一个成员变量，表示对HashMap的修改次数。（与ArrayList和LinkedList相同）- expectedModCount：表示对hashMap修改次数的期望值，它的初始值为modCount。- ConcurrentModificationException()异常：此异常为了防止在使用Iterator遍历容器的同时又对容器作增加或删除操作，或者使用多线程操作。 🔹 说明：HashMap的Iterator是fail-fast迭代器。每次发生结构性变化时modCount都会增加，而每次迭代器操作时都会检查expectedModCount是否与modCount相同，这样就能检测出结构性变化。当有其他线程改变了HashMap的结构（增加、删除、修改元素），将会抛出ConcurrentModificationExceptidon。 🔹 解决方法：在遍历的过程中把需要删除的对象保存到一个集合中，等遍历结束后再调用removeAll方法来删除，或者通过Iterator的remove()方法移除元素。 （2）TreeNode+ TreeNode TreeNode继承自LinkedHashMap.Entry类。 红黑树结构的属性和构造方法：static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123; // 父节点 TreeNode&lt;K,V&gt; parent; // red-black tree links // 左节点 TreeNode&lt;K,V&gt; left; // 右节点 TreeNode&lt;K,V&gt; right; // 前节点：删除时需要取消链接&quot;next&quot; TreeNode&lt;K,V&gt; prev; // needed to unlink next upon deletion // 颜色：true红色；false黑色 boolean red; // 构造方法，参数：hash值、key、value、下一个Node节点 TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) &#123; super(hash, key, val, next); &#125; // ...&#125; - getTreeNode() 获取红黑树节点 /** * Calls find for root node. * 调用查找根节点 */final TreeNode&lt;K,V&gt; getTreeNode(int h, Object k) &#123; // 🔻 调用find()查找节点 return ((parent != null) ? root() : this).find(h, k, null); // 若根节点不为空，调用root节点查找；若根节点为空，使用this查找。&#125; - find() 查找树节点 /** * Finds the node starting at root p with the given hash and key. The kc argument caches comparableClassFor(key) upon first use comparing keys. * 使用给定的key和hash值查找从根p开始的节点。 */final TreeNode&lt;K,V&gt; find(int h, Object k, Class&lt;?&gt; kc) &#123; TreeNode&lt;K,V&gt; p = this; // 当前树形Node：p // 遍历整树： do &#123; int ph, dir; K pk; TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q; // 当前Node左节点、右节点、 // 若当前节点hash值较大：p取其左节点 if ((ph = p.hash) &gt; h) p = pl; // 若当前节点hash值较小：p取其右节点 else if (ph &lt; h) p = pr; // 若当前节点key值等于给定key值，返回当前节点 else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk))) return p; // 若左节点为空，p取其右节点 else if (pl == null) p = pr; // 若右节点为空，p取其左节点 else if (pr == null) p = pl; // 根据compareTo比较 else if ((kc != null || (kc = comparableClassFor(k)) != null) &amp;&amp; (dir = compareComparables(kc, k, pk)) != 0) p = (dir &lt; 0) ? pl : pr; // 根据compareTo的结果，若右节点能找到：返回右节点 else if ((q = pr.find(h, k, kc)) != null) return q; // 若compareTo的结果在左节点上：继续查找 else p = pl; &#125; while (p != null); return null;&#125; 参考： HashMap扩容部分：Java高并发与集合框架：JCF和JUC源码分析与实现）","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://equnee.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://equnee.github.io/tags/Java/"},{"name":"HashMap","slug":"HashMap","permalink":"https://equnee.github.io/tags/HashMap/"}]},{"title":"🌷 设计模式 - 责任链","slug":"note/Design-pattern/design-pattern_Chain","date":"2023-03-08T15:14:10.467Z","updated":"2023-03-08T15:18:36.714Z","comments":true,"path":"note/Design-pattern/design-pattern_Chain/","link":"","permalink":"https://equnee.github.io/note/Design-pattern/design-pattern_Chain/","excerpt":"","text":"来自《秒懂设计模式》","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://equnee.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://equnee.github.io/tags/Java/"},{"name":"Chain","slug":"Chain","permalink":"https://equnee.github.io/tags/Chain/"}]},{"title":"🌷 设计模式 - 单例","slug":"note/Design-pattern/design-pattern_Singleton","date":"2023-03-07T17:32:40.177Z","updated":"2023-03-08T15:26:08.159Z","comments":true,"path":"note/Design-pattern/design-pattern_Singleton/","link":"","permalink":"https://equnee.github.io/note/Design-pattern/design-pattern_Singleton/","excerpt":"","text":"来自《秒懂设计模式》 一. 孤独的太阳我们可以把太阳系看作一个庞大的系统，其中有各种各样的对象存在，丰富多彩的实例造就了系统的美好。这个系统里的某些实例是唯一的，如我们赖以生存的恒星太阳。 与其他行星或卫星不同的是，太阳是太阳系内唯一的恒星实例。但倘若天上有9个太阳，那么将会带来一场灾难。太阳不多不少仅此一例。 二. 饿汉造日%%{ init: { 'themeVariables': { 'fontSize': '22px', 'fontFamily': 'Noto Serif SC' } } }%% graph LR T((\"饿汉造日\")):::b T --> A([\"1. 开始\"]):::p T --> B([\"2. 构造方法私有化\"]):::p T --> C([\"3. 自有永有\"]):::p T --> D([\"4. 公开访问\"]):::p T --> E([\"5. 总结\"]):::b A --> a(\"既然太阳系里只有一个太阳，就需要严格把控太阳实例化的过程。\"):::lp a -.-> at([\"Public class Sun {} // 一个最简单的Sun类\"]):::lg B --> b(\"太阳只有一个，不能随意创建实例。但由于Java会自动生成一个无参构造器，因此必须禁止外部调用构造器*。\"):::lp b -.-> bt([\"private Sun(){}\"]):::lg C --> c(\"让它在类加载时就自己创建自己，并使其自有永有\"):::lp c -.-> ct([\"private static final Sun sun = new Sun();\"]):::lg D --> d(\"使用静态方法*getInstance()来获取太阳的单例对象并将其设置为“public”以暴露给外部使用\"):::lp d -.- dt([\"public static Sun getInstance(){ return sun; }\"]):::lg d -.- d2t[\"*如同程序入口的静态方法main(), 不需要任何对象引用就能被访问\"]:::info T -..-> e(\"（还可以添加其他功能方法，如发光和发热等）\"):::info d --> et(\"最后，不管谁得到或得到几次，得到的都是同一个太阳实例，这样就确保了整个太阳系中恒星太阳的唯一合法性，他人无法伪造。\"):::lb E --> e2t(\"这就是“饿汉模式”(eager initialization)：即在初始阶段(static)就主动进行实例化，并时刻保持一种渴求的状态(public)，无论此单例是否有人使用。\"):::lb classDef p fill:#ddaebd classDef b fill:#aab7d2 classDef lp fill:#f4e4e9 classDef lb fill:#d9dfeb classDef lg fill:#cde2da classDef info fill:#f6f6f7,color:#5a5a5f,stroke-dasharray: 3 3, stroke-width: 2px 1. 开始 public class Sun &#123;&#125; 2. 构造方法私有化 接下来我们得确保任何人都不能创建太阳的实例，否则一旦程序员调用代码“new Sun()”，天空就会出现多个太阳，便又需要“后羿”去解决了。 实例化工作完全归属于内部事务，任何外部类都无权干预 public class Sun &#123; private Sun()&#123; // 构造方法私有化 &#125; &#125; 3. 自有永有 public class Sun &#123; private static final Sun sun = new Sun(); // 自有永有的太阳单例 private Sun()&#123; // 构造方法私有化 &#125; &#125; 关键字 说明 private 确保太阳实例的私有性、不可见性和不可访问性； static 确保太阳的静态性，将太阳放入内存里的静态区，在类加载的时候就初始化了，它与类同在，也就是说它是与类同时期且早于内存堆中的对象实例化的，该实例在内存中永生，内存垃圾收集器(Garbage Collector, GC)也不会对其进行回收； final 确保这个太阳是常量、恒量，它是一颗终极的恒星，引用一旦被赋值就不能再修改； new 初始化太阳类的静态实例，并赋予静态常量sun。 4. 公开访问 单例的太阳对象写好了，可一切皆是私有的，外部如何访问？—— 使用静态方法getInstance()来获取太阳的单例对象。 public class Sun &#123; private static final Sun sun = new Sun(); // 自有永有的太阳单例 private Sun()&#123; // 构造方法私有化 &#125; public static Sun getInstance()&#123; // 阳光普照，方法公开化 return sun; &#125; &#125; 三. 懒汉的队伍%%{ init: { 'themeVariables': { 'fontFamily': 'Noto Serif SC' } } }%% graph LR T((懒汉的队伍)):::b T --> A([\"1. 用时才创建\"]):::p T --> B([\"2. 排队（同步锁）\"]):::p T --> C([\"3. 需要时再排队（双检锁）\"]):::p A --> a(\"若无请求就不实例化，节省内存空间\"):::lp a -.-> at([\"去掉 finalif(sun == null)\"]):::lg B --> b(\"由于多线程时的缺陷：请求方法加上同步锁synchronized\"):::lp b -.- bt2([\"public static synchronized Sun getInstance() \"]):::lg b -.-> bt3(\"加锁后某线程调用前必须获取同步锁，调用完会释放锁给其他线程用，也就是给请求排队。\"):::info C --> c(\"为了解决线程阻塞：使用2个嵌套的判空逻辑\"):::lp c -.- ct([\"private volatile static Sun sun;if(sun = null){ synchronized(){if(sun == null){sun = new Sun();}\"]):::lg c -.- ct2[\"1. 外层放宽入口，保证线程并发的高效性2. 内层加锁同步，保证实例化的单次运行\"]:::info classDef p fill:#ddaebd classDef b fill:#aab7d2 classDef lp fill:#f4e4e9 classDef lb fill:#d9dfeb classDef lg fill:#cde2da classDef info fill:#f6f6f7,color:#433f40,stroke-dasharray: 3 3, stroke-width: 2px 1. 用时才创建 单例的“饿汉模式”，让太阳一开始就准备就绪，随时供应免费日光。 然而，如果始终没人获取日光，那就白造了太阳，白白浪费一块内存区域。类似于商家货品滞销的情况，货架上堆放着商品却没人买，白白浪费空间。因此，商家为了降低风险，规定有些商品必须提前预订，这就是“懒汉模式”(lazy initialization)。 public class Sun &#123; private static Sun sun; // 这里不进行实例化 private Sun()&#123; // 构造方法私有化 &#125; public static Sun getInstance() &#123; if(sun == null) &#123; // 如果无日才造日 sun = new Sun(); &#125; return sun; &#125;&#125; 关键字 说明 去掉 final 一开始并没有造太阳，所以去掉了关键字final。 用时才实例化 仅在某线程第一次调用第9行的getInstance()方法时才会运行对太阳进行实例化的逻辑代码，之后再请求就直接返回此实例了。❗️缺点：初次请求时速度较之前的饿汉初始化模式慢，因为要消耗CPU资源去临时造这个太阳。 2. 排队 因为上述程序在多线程模式下有缺陷：并发请求时判空逻辑会同时成立，导致多次实例化太阳、多次赋值，违背单例理念。 public class Sun &#123; private static Sun sun; // 这里不进行实例化 private Sun()&#123; // 构造方法私有化 &#125; public static synchronized Sun getInstance() &#123; // 此处加入同步锁 if(sun == null) &#123; // 如果无日才造日 sun = new Sun(); &#125; return sun; &#125;&#125; 关键字 说明 synchronized 将太阳类Sun中第9行的getInstance()改成了同步方法，如此可避免多线程陷阱。 3. 需要时再排队 如果仅为了实例化一个单例对象，直接加锁排队,使用synchronized让所有请求排队等候：会造成线程阻塞，资源与时间被白白浪费。 public class Sun &#123; private volatile static Sun sun; private Sun() &#123; // 构造方法私有化 &#125; public static Sun getInstance() &#123; // 华山入口 if(sun = null)&#123; synchronized(Sun.class)&#123; // 观日者进行排队 if(sun == null)&#123; sun = new Sun(); // 只有排头兵造了太阳，旭日东升 &#125; &#125; &#125; return sun; // ……阳光普照，其余人不必再造日 &#125;&#125; 关键字 说明 去掉 final 第3行对sun变量的定义不再使用final关键字，说明它不再是常量，而是需要后续赋值的变量； volatile 关键字volatile对静态变量的修饰则能保证sun变量值在各线程访问时的同步性、唯一性。 去掉入口的同步锁 对于第9行的getInstance()方法，去掉方法上的关键字synchronized，使大家都能同时进入方法并对其进行开发。 判空逻辑1 有些人（线程）起早就是为了观看日出，那么这些人会通过第10行的判空逻辑进入观日台。 判空逻辑2 在第12行我们又进行一次判空逻辑，这就意味着只有队伍中的第一个人造了太阳，有幸看到了日出的第一缕阳光，而后面的人则统统离开，直到第17行得到已经造好的太阳。 最后：太阳高高升起，实例化操作完毕，起晚的人们都无须再进入观日台，直接获取太阳实例即可，温暖阳光普照大地。 四. 大道至简相比“懒汉模式”，其实更常用“饿汉模式”，因为这个单例迟早是要被实例化占用内存的，延迟懒加载的意义并不大，加锁解锁反而是一种资源浪费，同步更是会降低CPU的利用率，使用不当的话反而会带来不必要的风险。越简单的包容性越强，而越复杂的反而越容易出错。 单例模式的类结构： classDiagram class Singleton{ - instance : singleton - Sigleton() + getInstance() Singleton } Singleton --> Singleton Singleton（单例）：包含一个自己的类实例的属性，并把构造方法用privat关键字隐藏起来，对外只提getInstance()方法以获得这个单例对象。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://equnee.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://equnee.github.io/tags/Java/"},{"name":"singleton","slug":"singleton","permalink":"https://equnee.github.io/tags/singleton/"}]},{"title":"Mac远程连接Windows（Microsoft Remote Desktop）","slug":"guide/mac_mrd_windows","date":"2021-03-25T07:49:07.000Z","updated":"2023-03-07T18:09:04.157Z","comments":true,"path":"guide/mac_mrd_windows/","link":"","permalink":"https://equnee.github.io/guide/mac_mrd_windows/","excerpt":"","text":"摘要: 同时带两台电脑出门很麻烦，于是选择在Mac上使用 Microsoft Remote Desktop 远程连接使用不带出门的 Windows，从此只需要把Windows放在家里连接电源和wifi一直放着就行！顺便整理了一些别人遇到的错误和解决方法。 日期: 2021/3/25 环境 : MacOS 11.2.2 + Windows10 一. 软件下载下载 Microsoft Remote Desktop，根据情况下载对应版本的app： 使用 Windows 控制 windows：&gt;&gt; 官网下载 使用 Mac 控制 windows： App Store 下载，仅国外的应用商店提供下载，因此只能使用国外的 AppleID，可参考&gt; &gt; 国外AppleID申请方法。 其他渠道下载（俺也没试过 二. 创建连接2.1 Windows 配置 首先确保将被控制的 Windows 开启了远程桌面连接配置： （1）系统属性 设置了系统属性为允许远程桌面连接 若选项都是灰色无法允许远程连接，&gt; 参考这里。 运行 gpedit.msc 回车打开本地组策略编辑器,在左侧的列表中依次展开：计算机配置&gt;管理模板&gt;Windows组件&gt;远程桌面会话主机&gt;连接 双击打开右侧的”允许用户通过使用远程桌面服务进行远程连接“,看一下之前是否有配置,如果有的话改成”未配置”,如果之前就是未配置,那可以改成已启用,然后您再看一下系统属性&gt;远程桌面中的相关设置区域是否恢复正常. （2）防火墙 设置了防火墙允许远程桌面通过防火墙通信 （3）端口 开启了用于远程桌面连接的服务端口： 在cmd中输入netstat -aon|findstr 3389，查看默认端口号3389是否开启。 若端口号未开启：打开任务管理器，开启下面两项服务。（UmRdpServise可播放声音) 若修改过或无法查询到3389端口，&gt; 参考这里。 （4）本地策略 设置本地策略非来宾。在运行中输入：gpedit.msc （5）关闭 Windows hello 确保关闭了设置内 仅允许 Windows hello 登录 (未设置可忽略。) Windows Hello：使您可以使用脸部，虹膜，指纹或PIN登录设备，应用程序，在线服务和网络。 （6）AAD 确保不是通过 Microsoft Authenticator ，而是通过手动输入密码进行验证登录的： 因为 Microsoft Authenticator 登录使用的认证方式与其他域不互通，就不能直接开启连接啦。 2.2 添加计算机 配置Windows允许远程桌面连接后，使用Mac准备开始连接，在Microsoft Remote Desktop中添加PC，输入主机名 + 用户账号信息。 PC name：IP地址。 查看方法：在 Windows 的命令提示符(win+R 键打开的运行窗口输入cmd) 输入命令 ipconfig，可查看ipv4地址。 User account：登录该PC的账号密码。建议选择 Ask when required，先不输入账号密码，在连接时输入，确保能连接成功后再添加记录，防止这里保存的账号密码有误，后面怎么都连不上。 2.3 填写账户信息（1） 本地用户 使用本地用户名登录： 本地用户名(cmd输入 whoami 查看) + 本地解锁密码。 （2） 微软账户 使用微软账户登录： 本地创建的英文账户若关联了微软账号，可使用该微软账号邮箱进行远程登录，用户名为邮箱格式的微软账号(username@outlook.com) + 对应的微软账号密码。 （3） 空密码 或使用空密码进行远程桌面连接：在 windows 中设置 打开运行，输入gpedit.msc，打开本地组策略编辑器 2.4 报错解决（1） The User Account Did Not work 🔒 提示：The User Account Did Not Work.The user account used to connect to xx.xx.xx.xx (remote PC) did not work. Try again.（–&gt; 你输的这个账户信息连不上。） 🔑 解决方法：需要输入正确的账号密码。 微软账号登录：邮箱格式的微软账号(username@outlook.com) + 对应的微软账号密码 本地用户登录：本地主机名或本地账户名 + 本地账户解锁密码 以前可以，现在突然连不上了：检查上面两个密码是不是改过了，如果改过记得同步修改。 （2） 0x204 🔒 连接时提示：We couldn’t connect to the remote PC.Make sure the PC is turned on and connected to the network, and thar remote access is enabled. Error code:0x204（–&gt; 我们无法连接到远程电脑，确保电脑已打开并连接到网络，并且已启用远程访问。） 🔑 解决方法： 开电脑。检查是否打开windows电源，确保非关机或睡眠状态，开启电源解锁屏幕就可以啦。 连Wi-Fi。 开服务。确保已开启 Windows 的远程桌面连接配置。 （3） 0x207 🔒 提示： 🔑：确保windows的本地组策略不是 仅来宾 状态。 三. Mac配置3.1 创建目录 在mac电脑上，根据需要创建用于文件传输的目录。 3.2 编辑配置 开启Microsoft Remote Desktop 软件，点击编辑。 如图所示，添加重定向刚创建的文件夹对应的路径 3.3 完成 可查看windows上的文件夹映射，没出现的话重新连接试试。 四. 结尾第一次完成mac和windows之间远程桌面的配置，回头看感觉写得有些复杂，因为多记录了一些自己也没遇到过的问题和情况。如果各位还遇到了文中没提到的情况，欢迎评论留言，我会继续补充～","categories":[],"tags":[{"name":"windows","slug":"windows","permalink":"https://equnee.github.io/tags/windows/"},{"name":"Mac","slug":"Mac","permalink":"https://equnee.github.io/tags/Mac/"}]},{"title":"超棒的文档神器搭档！Markdown+ Mermaid","slug":"tool/markdown+mermaid","date":"2020-04-01T16:37:51.048Z","updated":"2023-03-13T08:00:28.369Z","comments":true,"path":"tool/markdown+mermaid/","link":"","permalink":"https://equnee.github.io/tool/markdown+mermaid/","excerpt":"","text":"一. Markdown（基本人人会用，不多介绍。 二. Mermaid 在线体验：https://mermaid.live/ 1. 为什么用 Mermaid 在配合 Markdown 写笔记时，最让我头疼的就是如何以最省时省力的方式插入流程图。我做过很多尝试：如，手绘、使用Xmind导图软件、ProcessOn之类的在线绘图工具等。但它们都有最显著的缺点：最终以图像形式导入文档，因此修改和导出非常繁琐。 而 Mermaid 对我来说是一个说近乎完美的方案！ 高效易用 它直接在 Markdown 中以代码段的形式创建和修改图表，并实时渲染为 Svg 视图，可以高效制作简易的流程图。并且随时修改、立即可见。 它和 Markdown 一样都是纯文本格式存储的语言，易于保存和分享。 Web友好 它不受制于特定编辑器，大部分支持 Markdown 的编辑器都支持 Mermaid。 它基于 Javascript，可集成嵌入前端框架，如 Vue、Hexo等。 2. Mermaid 用法Mermaid 可绘制流程图、时序图、Git图、类图、饼图、甘特图等图表，详细可查阅 官方文档。下面以我常用的两个流程图模版作为示例（主要展示样式的两种使用方法）： 基础（使用基本样式） graph LR T((\"Title\")):::p T ==> A([\"Pink\"]):::p T --> B([\"Green\"]):::g T --> C([\"Blue\"]):::b A -.-> a(\"light Pink\"):::lp B -.-> b(\"light Green\"):::lg C -.-> c(\"light Blue\"):::lb a -.- info[\"Info\"]:::info classDef p fill:#ddaebd classDef b fill:#aab7d2 classDef g fill:#9ac5bb classDef lp fill:#f4e4e9 classDef lb fill:#d9dfeb classDef lg fill:#ddebe6 classDef info fill:#f6f6f7,color:#737379,stroke-dasharray: 3 3, stroke-width: 2px graph LR T((&quot;Title&quot;)):::p T ==&gt; A([&quot;Pink&quot;]):::p T --&gt; B([&quot;Green&quot;]):::g T --&gt; C([&quot;Blue&quot;]):::b A -.-&gt; a(&quot;light Pink&quot;):::lp B -.-&gt; b(&quot;light Green&quot;):::lg C -.-&gt; c(&quot;light Blue&quot;):::lb a -.- info[&quot;Info&quot;]:::info%% 样式： style T color:#fff classDef p fill:#ddaebd classDef b fill:#aab7d2 classDef g fill:#9ac5bb classDef lp fill:#f4e4e9 classDef lb fill:#d9dfeb classDef lg fill:#ddebe6 classDef info fill:#f6f6f7,color:#737379,stroke-dasharray: 3 3, stroke-width: 2px 进阶（使用预加载样式） %%{ init: { 'themeVariables': { 'fontFamily': 'Noto Serif SC', 'mainBkg': '#f4e4e9', 'edgeLabelBackground': '#ddebe6' } } }%% graph TD T((\"Title\")):::pink T --> A A -.-> |\"text2\"| B subgraph \"subgraph\" A --> |\"text3\"|C:::lb end classDef pink fill:#ddaebd style B fill:#d9dfeb, stroke:#657eae,stroke-width:3px,stroke-dasharray: 5 3 %%&#123; init: &#123; &#x27;themeVariables&#x27;: &#123; &#x27;fontFamily&#x27;: &#x27;Noto Serif SC&#x27;, &#x27;mainBkg&#x27;: &#x27;#f4e4e9&#x27;, &#x27;edgeLabelBackground&#x27;: &#x27;#ddebe6&#x27; &#125; &#125;&#125;%%graph TDT((&quot;Title&quot;)):::pinkT --&gt; AA -.-&gt; |&quot;text2&quot;| Bsubgraph &quot;subgraph&quot;A --&gt; |&quot;text3&quot;|C:::lbendclassDef pink fill:#ddaebdstyle B fill:#d9dfeb, stroke:#657eae,stroke-width:3px,stroke-dasharray: 5 3 3. Hexo + Mermaid 插件 代码仓库: https://github.com/webappdevelp/hexo-filter-mermaid-diagrams （1）安装插件$ yarn add hexo-filter-mermaid-diagrams 或 $ npm install hexo-filter-mermaid-diagrams （2）编辑配置安装完成后，编辑hexo配置文件：config.yml # mermaid chartmermaid: enable: true version: &quot;7.1.2&quot; options: （3）添加脚本修改完配置文件后，编辑博客页面组件的footer部分。这是为了将 mermaid.js 以 script 形式插入到 html 尾部，使其能正常渲染。 footer文件如，footer.pug， after_footer.pug , after-footer.ejs 或 swig，该文件通常存放在主题目录下的layout目录中。 若博客使用pug模版引擎渲染，在 after_footer.pug文件中添加如下代码: if theme.mermaid.enable == true script(type=&#x27;text/javascript&#x27;, id=&#x27;maid-script&#x27; mermaidoptioins=theme.mermaid.options src=&#x27;https://unpkg.com/mermaid@&#x27;+ theme.mermaid.version + &#x27;/dist/mermaid.min.js&#x27; + &#x27;?v=&#x27; + theme.version) script. if (window.mermaid) &#123; var options = JSON.parse(document.getElementById(&#x27;maid-script&#x27;).getAttribute(&#x27;mermaidoptioins&#x27;)); mermaid.initialize(options); &#125; 若使用ejs引擎渲染，则在after-footer.ejs文件中添加如下代码： &lt;% if (theme.mermaid.enable) &#123; %&gt; &lt;script src=&#x27;https://unpkg.com/mermaid@&lt;%= theme.mermaid.version %&gt;/dist/mermaid.min.js&#x27;&gt;&lt;/script&gt; &lt;script&gt; if (window.mermaid) &#123; mermaid.initialize(&#123;theme: &#x27;neutral&#x27;&#125;); &#125; &lt;/script&gt;&lt;% &#125; %&gt; swig模版引擎： &#123;% if theme.mermaid.enable %&#125; &lt;script src=&#x27;https://unpkg.com/mermaid@&#123;&#123; theme.mermaid.version &#125;&#125;/dist/mermaid.min.js&#x27;&gt;&lt;/script&gt; &lt;script&gt; if (window.mermaid) &#123; mermaid.initialize(&#123;&#123; JSON.stringify(theme.mermaid.options) &#125;&#125;); &#125; &lt;/script&gt;&#123;% endif %&#125; （4）踩坑以上为官方文档中的配置方法，而我在初次配置的过程中，还遇到以下问题可供参考： html页面中，mermaid段落仅显示为代码块，开发者工具中该段落为普通源代码。 这是因为插件没有生效，应确保正确完成上面两个步骤（安装插件、打开配置）。 html页面中，mermaid段落显示为空白图片，开发者工具中查看该段落为svg文件，控制台报错： Uncaught TypeError: Cannot read properties of null (reading’mermaid’)。 此时插件已经生效，而js代码文件引入有误，无法成功渲染。 继续查看html代码发现，文件底部的&lt;sctipt&gt;标签中，显示我引入mermaid的url为： &lt;script type=&quot;text/javascript&quot; id=&quot;maid-script&quot; src=&quot;https://unpkg.com/mermaid@10.0.2/dist/mermaid.min.js?v=undefined&quot;&gt;&lt;/script&gt; 这段代码是由官方提供的脚本、在footer文件中根据用户的配置组合成的： script(type=&#x27;text/javascript&#x27;, id=&#x27;maid-script&#x27; mermaidoptioins=theme.mermaid.options src=&#x27;https://unpkg.com/mermaid@&#x27;+ theme.mermaid.version + &#x27;/dist/mermaid.min.js&#x27; + &#x27;?v=&#x27; + theme.version) 如果配置有误则会生成错误的url，看起来是version的问题，于是我将url改为直接引入jsdelivr上的资源，遂能正常渲染： src=&#x27;https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js&#x27;)","categories":[{"name":"工具","slug":"工具","permalink":"https://equnee.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Mermaid","slug":"Mermaid","permalink":"https://equnee.github.io/tags/Mermaid/"},{"name":"Markdown","slug":"Markdown","permalink":"https://equnee.github.io/tags/Markdown/"}]}],"categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://equnee.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"设计模式","slug":"设计模式","permalink":"https://equnee.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"工具","slug":"工具","permalink":"https://equnee.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://equnee.github.io/tags/Java/"},{"name":"HashMap","slug":"HashMap","permalink":"https://equnee.github.io/tags/HashMap/"},{"name":"Chain","slug":"Chain","permalink":"https://equnee.github.io/tags/Chain/"},{"name":"singleton","slug":"singleton","permalink":"https://equnee.github.io/tags/singleton/"},{"name":"windows","slug":"windows","permalink":"https://equnee.github.io/tags/windows/"},{"name":"Mac","slug":"Mac","permalink":"https://equnee.github.io/tags/Mac/"},{"name":"Mermaid","slug":"Mermaid","permalink":"https://equnee.github.io/tags/Mermaid/"},{"name":"Markdown","slug":"Markdown","permalink":"https://equnee.github.io/tags/Markdown/"}]}