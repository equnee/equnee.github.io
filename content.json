{"meta":{"title":"🍧 Peach","subtitle":"equne","description":"蜜桃想学打代码","author":"equne","url":"https://equnee.github.io","root":"/"},"pages":[],"posts":[{"title":"🌷 设计模式 - 单例模式","slug":"note/Design-pattern/design-pattern_sigleton","date":"2023-03-07T17:32:40.177Z","updated":"2023-03-08T14:54:17.042Z","comments":true,"path":"note/Design-pattern/design-pattern_sigleton/","link":"","permalink":"https://equnee.github.io/note/Design-pattern/design-pattern_sigleton/","excerpt":"","text":"来自《秒懂设计模式》 一. 孤独的太阳我们可以把太阳系看作一个庞大的系统，其中有各种各样的对象存在，丰富多彩的实例造就了系统的美好。这个系统里的某些实例是唯一的，如我们赖以生存的恒星太阳。 与其他行星或卫星不同的是，太阳是太阳系内唯一的恒星实例。但倘若天上有9个太阳，那么将会带来一场灾难。太阳不多不少仅此一例。 二. 饿汉造日%%{ init: { 'themeVariables': { 'fontSize': '22px', 'fontFamily': 'Noto Serif SC' } } }%% graph LR T((\"饿汉造日\")):::b T --> A([\"1. 开始\"]):::p T --> B([\"2. 构造方法私有化\"]):::p T --> C([\"3. 自有永有\"]):::p T --> D([\"4. 公开访问\"]):::p T --> E([\"5. 总结\"]):::b A --> a(\"既然太阳系里只有一个太阳，就需要严格把控太阳实例化的过程。\"):::lp a -.-> at([\"Public class Sun {} // 一个最简单的Sun类\"]):::lg B --> b(\"太阳只有一个，不能随意创建实例。但由于Java会自动生成一个无参构造器，因此必须禁止外部调用构造器*。\"):::lp b -.-> bt([\"private Sun(){}\"]):::lg C --> c(\"让它在类加载时就自己创建自己，并使其自有永有\"):::lp c -.-> ct([\"private static final Sun sun = new Sun();\"]):::lg D --> d(\"使用静态方法*getInstance()来获取太阳的单例对象并将其设置为“public”以暴露给外部使用\"):::lp d -.- dt([\"public static Sun getInstance(){ return sun; }\"]):::lg d -.- d2t[\"*如同程序入口的静态方法main(), 不需要任何对象引用就能被访问\"]:::info T -..-> e(\"（还可以添加其他功能方法，如发光和发热等）\"):::info d --> et(\"最后，不管谁得到或得到几次，得到的都是同一个太阳实例，这样就确保了整个太阳系中恒星太阳的唯一合法性，他人无法伪造。\"):::lb E --> e2t(\"这就是“饿汉模式”(eager initialization)：即在初始阶段(static)就主动进行实例化，并时刻保持一种渴求的状态(public)，无论此单例是否有人使用。\"):::lb classDef p fill:#ddaebd classDef b fill:#aab7d2 classDef lp fill:#f4e4e9 classDef lb fill:#d9dfeb classDef lg fill:#cde2da classDef info fill:#f6f6f7,color:#5a5a5f,stroke-dasharray: 3 3, stroke-width: 2px 1. 开始 public class Sun &#123;&#125; 2. 构造方法私有化 接下来我们得确保任何人都不能创建太阳的实例，否则一旦程序员调用代码“new Sun()”，天空就会出现多个太阳，便又需要“后羿”去解决了。 实例化工作完全归属于内部事务，任何外部类都无权干预 public class Sun &#123; private Sun()&#123; // 构造方法私有化 &#125; &#125; 3. 自有永有 public class Sun &#123; private static final Sun sun = new Sun(); // 自有永有的太阳单例 private Sun()&#123; // 构造方法私有化 &#125; &#125; 关键字 说明 private 确保太阳实例的私有性、不可见性和不可访问性； static 确保太阳的静态性，将太阳放入内存里的静态区，在类加载的时候就初始化了，它与类同在，也就是说它是与类同时期且早于内存堆中的对象实例化的，该实例在内存中永生，内存垃圾收集器(Garbage Collector, GC)也不会对其进行回收； final 确保这个太阳是常量、恒量，它是一颗终极的恒星，引用一旦被赋值就不能再修改； new 初始化太阳类的静态实例，并赋予静态常量sun。 4. 公开访问 单例的太阳对象写好了，可一切皆是私有的，外部如何访问？—— 使用静态方法getInstance()来获取太阳的单例对象。 public class Sun &#123; private static final Sun sun = new Sun(); // 自有永有的太阳单例 private Sun()&#123; // 构造方法私有化 &#125; public static Sun getInstance()&#123; // 阳光普照，方法公开化 return sun; &#125; &#125; 三. 懒汉的队伍%%{ init: { 'themeVariables': { 'fontFamily': 'Noto Serif SC' } } }%% graph LR T((懒汉的队伍)):::b T --> A([\"1. 用时才创建\"]):::p T --> B([\"2. 排队（同步锁）\"]):::p T --> C([\"3. 需要时再排队（双检锁）\"]):::p A --> a(\"若无请求就不实例化，节省内存空间\"):::lp a -.-> at([\"去掉 finalif(sun == null)\"]):::lg B --> b(\"由于多线程时的缺陷：请求方法加上同步锁synchronized\"):::lp b -.- bt2([\"public static synchronized Sun getInstance() \"]):::lg b -.-> bt3(\"加锁后某线程调用前必须获取同步锁，调用完会释放锁给其他线程用，也就是给请求排队。\"):::info C --> c(\"为了解决线程阻塞：使用2个嵌套的判空逻辑\"):::lp c -.- ct([\"private volatile static Sun sun;if(sun = null){ synchronized(){if(sun == null){sun = new Sun();}\"]):::lg c -.- ct2[\"1. 外层放宽入口，保证线程并发的高效性2. 内层加锁同步，保证实例化的单次运行\"]:::info classDef p fill:#ddaebd classDef b fill:#aab7d2 classDef lp fill:#f4e4e9 classDef lb fill:#d9dfeb classDef lg fill:#cde2da classDef info fill:#f6f6f7,color:#433f40,stroke-dasharray: 3 3, stroke-width: 2px 1. 用时才创建 单例的“饿汉模式”，让太阳一开始就准备就绪，随时供应免费日光。 然而，如果始终没人获取日光，那就白造了太阳，白白浪费一块内存区域。类似于商家货品滞销的情况，货架上堆放着商品却没人买，白白浪费空间。因此，商家为了降低风险，规定有些商品必须提前预订，这就是“懒汉模式”(lazy initialization)。 public class Sun &#123; private static Sun sun; // 这里不进行实例化 private Sun()&#123; // 构造方法私有化 &#125; public static Sun getInstance() &#123; if(sun == null) &#123; // 如果无日才造日 sun = new Sun(); &#125; return sun; &#125;&#125; 关键字 说明 去掉 final 一开始并没有造太阳，所以去掉了关键字final。 用时才实例化 仅在某线程第一次调用第9行的getInstance()方法时才会运行对太阳进行实例化的逻辑代码，之后再请求就直接返回此实例了。❗️缺点：初次请求时速度较之前的饿汉初始化模式慢，因为要消耗CPU资源去临时造这个太阳。 2. 排队 因为上述程序在多线程模式下有缺陷：并发请求时判空逻辑会同时成立，导致多次实例化太阳、多次赋值，违背单例理念。 public class Sun &#123; private static Sun sun; // 这里不进行实例化 private Sun()&#123; // 构造方法私有化 &#125; public static synchronized Sun getInstance() &#123; // 此处加入同步锁 if(sun == null) &#123; // 如果无日才造日 sun = new Sun(); &#125; return sun; &#125;&#125; 关键字 说明 synchronized 将太阳类Sun中第9行的getInstance()改成了同步方法，如此可避免多线程陷阱。 3. 需要时再排队 如果仅为了实例化一个单例对象，直接加锁排队,使用synchronized让所有请求排队等候：会造成线程阻塞，资源与时间被白白浪费。 public class Sun &#123; private volatile static Sun sun; private Sun() &#123; // 构造方法私有化 &#125; public static Sun getInstance() &#123; // 华山入口 if(sun = null)&#123; synchronized(Sun.class)&#123; // 观日者进行排队 if(sun == null)&#123; sun = new Sun(); // 只有排头兵造了太阳，旭日东升 &#125; &#125; &#125; return sun; // ……阳光普照，其余人不必再造日 &#125;&#125; 关键字 说明 去掉 final 第3行对sun变量的定义不再使用final关键字，说明它不再是常量，而是需要后续赋值的变量； volatile 关键字volatile对静态变量的修饰则能保证sun变量值在各线程访问时的同步性、唯一性。 去掉入口的同步锁 对于第9行的getInstance()方法，去掉方法上的关键字synchronized，使大家都能同时进入方法并对其进行开发。 判空逻辑1 有些人（线程）起早就是为了观看日出，那么这些人会通过第10行的判空逻辑进入观日台。 判空逻辑2 在第12行我们又进行一次判空逻辑，这就意味着只有队伍中的第一个人造了太阳，有幸看到了日出的第一缕阳光，而后面的人则统统离开，直到第17行得到已经造好的太阳。 最后：太阳高高升起，实例化操作完毕，起晚的人们都无须再进入观日台，直接获取太阳实例即可，温暖阳光普照大地。 四. 大道至简相比“懒汉模式”，其实在大多数情况下我们通常会更多地使用“饿汉模式”，原因在于这个单例迟早是要被实例化占用内存的，延迟懒加载的意义并不大，加锁解锁反而是一种资源浪费，同步更是会降低CPU的利用率，使用不当的话反而会带来不必要的风险。越简单的包容性越强，而越复杂的反而越容易出错。 单例模式的类结构： classDiagram class Singleton{ - instance : singleton - Sigleton() + getInstance() Singleton } Singleton --> Singleton Singleton（单例）：包含一个自己的类实例的属性，并把构造方法用privat关键字隐藏起来，对外只提getInstance()方法以获得这个单例对象。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://equnee.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://equnee.github.io/tags/Java/"},{"name":"singleton","slug":"singleton","permalink":"https://equnee.github.io/tags/singleton/"}]},{"title":"Mac远程连接Windows（Microsoft Remote Desktop）","slug":"guide/mac_mrd_windows","date":"2021-03-25T07:49:07.000Z","updated":"2023-03-07T18:09:04.157Z","comments":true,"path":"guide/mac_mrd_windows/","link":"","permalink":"https://equnee.github.io/guide/mac_mrd_windows/","excerpt":"","text":"摘要: 同时带两台电脑出门很麻烦，于是选择在Mac上使用 Microsoft Remote Desktop 远程连接使用不带出门的 Windows，从此只需要把Windows放在家里连接电源和wifi一直放着就行！顺便整理了一些别人遇到的错误和解决方法。 日期: 2021/3/25 环境 : MacOS 11.2.2 + Windows10 一. 软件下载下载 Microsoft Remote Desktop，根据情况下载对应版本的app： 使用 Windows 控制 windows：&gt;&gt; 官网下载 使用 Mac 控制 windows： App Store 下载，仅国外的应用商店提供下载，因此只能使用国外的 AppleID，可参考&gt; &gt; 国外AppleID申请方法。 其他渠道下载（俺也没试过 二. 创建连接2.1 Windows 配置 首先确保将被控制的 Windows 开启了远程桌面连接配置： （1）系统属性 设置了系统属性为允许远程桌面连接 若选项都是灰色无法允许远程连接，&gt; 参考这里。 运行 gpedit.msc 回车打开本地组策略编辑器,在左侧的列表中依次展开：计算机配置&gt;管理模板&gt;Windows组件&gt;远程桌面会话主机&gt;连接 双击打开右侧的”允许用户通过使用远程桌面服务进行远程连接“,看一下之前是否有配置,如果有的话改成”未配置”,如果之前就是未配置,那可以改成已启用,然后您再看一下系统属性&gt;远程桌面中的相关设置区域是否恢复正常. （2）防火墙 设置了防火墙允许远程桌面通过防火墙通信 （3）端口 开启了用于远程桌面连接的服务端口： 在cmd中输入netstat -aon|findstr 3389，查看默认端口号3389是否开启。 若端口号未开启：打开任务管理器，开启下面两项服务。（UmRdpServise可播放声音) 若修改过或无法查询到3389端口，&gt; 参考这里。 （4）本地策略 设置本地策略非来宾。在运行中输入：gpedit.msc （5）关闭 Windows hello 确保关闭了设置内 仅允许 Windows hello 登录 (未设置可忽略。) Windows Hello：使您可以使用脸部，虹膜，指纹或PIN登录设备，应用程序，在线服务和网络。 （6）AAD 确保不是通过 Microsoft Authenticator ，而是通过手动输入密码进行验证登录的： 因为 Microsoft Authenticator 登录使用的认证方式与其他域不互通，就不能直接开启连接啦。 2.2 添加计算机 配置Windows允许远程桌面连接后，使用Mac准备开始连接，在Microsoft Remote Desktop中添加PC，输入主机名 + 用户账号信息。 PC name：IP地址。 查看方法：在 Windows 的命令提示符(win+R 键打开的运行窗口输入cmd) 输入命令 ipconfig，可查看ipv4地址。 User account：登录该PC的账号密码。建议选择 Ask when required，先不输入账号密码，在连接时输入，确保能连接成功后再添加记录，防止这里保存的账号密码有误，后面怎么都连不上。 2.3 填写账户信息（1） 本地用户 使用本地用户名登录： 本地用户名(cmd输入 whoami 查看) + 本地解锁密码。 （2） 微软账户 使用微软账户登录： 本地创建的英文账户若关联了微软账号，可使用该微软账号邮箱进行远程登录，用户名为邮箱格式的微软账号(username@outlook.com) + 对应的微软账号密码。 （3） 空密码 或使用空密码进行远程桌面连接：在 windows 中设置 打开运行，输入gpedit.msc，打开本地组策略编辑器 2.4 报错解决（1） The User Account Did Not work 🔒 提示：The User Account Did Not Work.The user account used to connect to xx.xx.xx.xx (remote PC) did not work. Try again.（–&gt; 你输的这个账户信息连不上。） 🔑 解决方法：需要输入正确的账号密码。 微软账号登录：邮箱格式的微软账号(username@outlook.com) + 对应的微软账号密码 本地用户登录：本地主机名或本地账户名 + 本地账户解锁密码 以前可以，现在突然连不上了：检查上面两个密码是不是改过了，如果改过记得同步修改。 （2） 0x204 🔒 连接时提示：We couldn’t connect to the remote PC.Make sure the PC is turned on and connected to the network, and thar remote access is enabled. Error code:0x204（–&gt; 我们无法连接到远程电脑，确保电脑已打开并连接到网络，并且已启用远程访问。） 🔑 解决方法： 开电脑。检查是否打开windows电源，确保非关机或睡眠状态，开启电源解锁屏幕就可以啦。 连Wi-Fi。 开服务。确保已开启 Windows 的远程桌面连接配置。 （3） 0x207 🔒 提示： 🔑：确保windows的本地组策略不是 仅来宾 状态。 三. Mac配置3.1 创建目录 在mac电脑上，根据需要创建用于文件传输的目录。 3.2 编辑配置 开启Microsoft Remote Desktop 软件，点击编辑。 如图所示，添加重定向刚创建的文件夹对应的路径 3.3 完成 可查看windows上的文件夹映射，没出现的话重新连接试试。 四. 结尾第一次完成mac和windows之间远程桌面的配置，回头看感觉写得有些复杂，因为多记录了一些自己也没遇到过的问题和情况。如果各位还遇到了文中没提到的情况，欢迎评论留言，我会继续补充～","categories":[],"tags":[{"name":"windows","slug":"windows","permalink":"https://equnee.github.io/tags/windows/"},{"name":"Mac","slug":"Mac","permalink":"https://equnee.github.io/tags/Mac/"}]},{"title":"用 Markdown + Mermaid 写文档","slug":"tool/markdown+mermaid","date":"2020-04-01T16:37:51.048Z","updated":"2023-03-07T18:12:32.320Z","comments":true,"path":"tool/markdown+mermaid/","link":"","permalink":"https://equnee.github.io/tool/markdown+mermaid/","excerpt":"","text":"一. Markdown二. Mermaid1. mermaid 语法 Mermaid是一种基于Javascript的绘图工具，使用类似于Markdown的语法，可以方便快捷地通过代码创建和修改图表。掌握了Markdown语法后，学习Mermaid就不成问题。 可创建： 2. Hexo + mermaid插件 from: https://github.com/webappdevelp/hexo-filter-mermaid-diagrams （1）安装插件$ yarn add hexo-filter-mermaid-diagrams 或 $ npm install hexo-filter-mermaid-diagrams （2）编辑配置安装完成后，编辑hexo配置文件：config.yml # mermaid chartmermaid: enable: true version: &quot;7.1.2&quot; options: （3）添加脚本修改完配置文件后，编辑博客页面组件的footer部分。这是为了将 mermaid.js 以 script 形式插入到 html 尾部，使其能正常渲染。 footer文件如，footer.pug， after_footer.pug , after-footer.ejs 或 swig，该文件通常存放在主题目录下的layout目录中。 若博客使用pug模版引擎渲染，在 after_footer.pug文件中添加如下代码: if theme.mermaid.enable == true script(type=&#x27;text/javascript&#x27;, id=&#x27;maid-script&#x27; mermaidoptioins=theme.mermaid.options src=&#x27;https://unpkg.com/mermaid@&#x27;+ theme.mermaid.version + &#x27;/dist/mermaid.min.js&#x27; + &#x27;?v=&#x27; + theme.version) script. if (window.mermaid) &#123; var options = JSON.parse(document.getElementById(&#x27;maid-script&#x27;).getAttribute(&#x27;mermaidoptioins&#x27;)); mermaid.initialize(options); &#125; 若使用ejs引擎渲染，则在after-footer.ejs文件中添加如下代码： &lt;% if (theme.mermaid.enable) &#123; %&gt; &lt;script src=&#x27;https://unpkg.com/mermaid@&lt;%= theme.mermaid.version %&gt;/dist/mermaid.min.js&#x27;&gt;&lt;/script&gt; &lt;script&gt; if (window.mermaid) &#123; mermaid.initialize(&#123;theme: &#x27;neutral&#x27;&#125;); &#125; &lt;/script&gt;&lt;% &#125; %&gt; swig模版引擎： &#123;% if theme.mermaid.enable %&#125; &lt;script src=&#x27;https://unpkg.com/mermaid@&#123;&#123; theme.mermaid.version &#125;&#125;/dist/mermaid.min.js&#x27;&gt;&lt;/script&gt; &lt;script&gt; if (window.mermaid) &#123; mermaid.initialize(&#123;&#123; JSON.stringify(theme.mermaid.options) &#125;&#125;); &#125; &lt;/script&gt;&#123;% endif %&#125; （4）踩坑以上为官方文档中的配置方法，而我在配置的时间过程中，还遇到以下问题可供参考： html页面中，mermaid段落仅显示为代码块，开发者工具中该段落为普通源代码。 这是因为插件没有生效，应确保正确完成上面两个步骤（安装插件、打开配置）。 html页面中，mermaid段落显示为空白图片，开发者工具中查看该段落为svg文件，控制台报错： Uncaught TypeError: Cannot read properties of null (reading’mermaid’)。 此时插件已经生效，而js代码文件引入有误，无法成功渲染。 继续查看html代码发现，文件底部的&lt;sctipt&gt;标签中，显示我引入mermaid的url为： &lt;script type=&quot;text/javascript&quot; id=&quot;maid-script&quot; src=&quot;https://unpkg.com/mermaid@10.0.2/dist/mermaid.min.js?v=undefined&quot;&gt;&lt;/script&gt; 这段代码是由官方提供的脚本，在footer文件中根据用户的配置组合成的： script(type=&#x27;text/javascript&#x27;, id=&#x27;maid-script&#x27; mermaidoptioins=theme.mermaid.options src=&#x27;https://unpkg.com/mermaid@&#x27;+ theme.mermaid.version + &#x27;/dist/mermaid.min.js&#x27; + &#x27;?v=&#x27; + theme.version) 如果配置有误则会生成错误的url，看起来是version的问题，于是我将url改为直接引入jsdelivr上的资源，遂能正常渲染： src=&#x27;https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js&#x27;)","categories":[{"name":"工具","slug":"工具","permalink":"https://equnee.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Mermaid","slug":"Mermaid","permalink":"https://equnee.github.io/tags/Mermaid/"},{"name":"Markdown","slug":"Markdown","permalink":"https://equnee.github.io/tags/Markdown/"}]}],"categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://equnee.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"工具","slug":"工具","permalink":"https://equnee.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://equnee.github.io/tags/Java/"},{"name":"singleton","slug":"singleton","permalink":"https://equnee.github.io/tags/singleton/"},{"name":"windows","slug":"windows","permalink":"https://equnee.github.io/tags/windows/"},{"name":"Mac","slug":"Mac","permalink":"https://equnee.github.io/tags/Mac/"},{"name":"Mermaid","slug":"Mermaid","permalink":"https://equnee.github.io/tags/Mermaid/"},{"name":"Markdown","slug":"Markdown","permalink":"https://equnee.github.io/tags/Markdown/"}]}