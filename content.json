{"meta":{"title":"🍧 Peach","subtitle":"equne","description":"蜜桃学代码","author":"equne","url":"https://equnee.github.io","root":"/"},"pages":[],"posts":[{"title":"IO - 标准设备输入/输出","slug":"note/Basics/IO/IO_StandardIO","date":"2023-05-06T15:10:06.697Z","updated":"2023-05-06T15:39:00.988Z","comments":true,"path":"note/Basics/IO/IO_StandardIO/","link":"","permalink":"https://equnee.github.io/note/Basics/IO/IO_StandardIO/","excerpt":"","text":"%%{ init: { 'themeVariables': { 'fontSize': '14px' } } }%% graph LR T([\"标准设备输入/输出\"]):::p T --> A(\"System\"):::p T --> B(\"Console\"):::b A -.- a(\"标准输出 out 标准输入 in 标准错误输出 err\"):::lp B -.- b(\"读取一行内容 readLine() 输出信息 printf() 读取密码 readPassword()\"):::lb classDef p fill:#ddaebd classDef b fill:#aab7d2 classDef g fill:#9ac5bb classDef lp fill:#f4e4e9 classDef lb fill:#d9dfeb classDef lg fill:#ddebe6 classDef info fill:#f6f6f7,color:#737379,stroke-dasharray: 3 3, stroke-width: 2px 一、标准设备输入/输出类 - SystemSystem是Java系统中一个最常使用的类：Java的系统类。 %%{ init: { 'themeVariables': { 'fontSize': '13px' } } }%% graph LR t((\"System（系统类）\")):::p --> T subgraph 静态方法 T([静态方法]):::p T --> 1(\"标准输出 out 标准输入 in 标准错误输出 err\"):::lp T -.- 2(\"访问外部定义的属性和环境变量\"):::info T -.- 3(\"加载文件和库\"):::info T -.- 4(\"快速复制数组\"):::info T -.- 5(\"取得系统时间：System.currentTimeMillis()\"):::info T -.- 6(\"系统退出命令：System.exit()\"):::info end t --> T2([\"静态成员变量\"]):::b subgraph \"静态成员变量(用于连接到标准输入/输出控制设备（键盘和控制台）)\" T2 --> 7(\"标准输出流：static PrintStream out\"):::lb T2 --> 8(\"标准错误输出流：static PrintStream err\"):::lb T2 --> 9(\"标准输入流：static PrintStream in\"):::lb end 7 -.- 7t(\"System.out.print()System.out.println()\"):::lg 8 -.- 8t(\"System.err.print()\"):::lg 9 -.- 9t(\"System.in.read()System.in.read(b)\"):::lg classDef p fill:#ddaebd classDef b fill:#aab7d2 classDef g fill:#9ac5bb classDef lp fill:#f4e4e9 classDef lb fill:#d9dfeb classDef lg fill:#ddebe6 classDef info color:#737379,stroke-dasharray: 3 3, stroke-width: 2px ① out 标准输出流输出消息到控制台 // ------ * 编写一行输出数据 ----------------------------------System.out.println(data);// ------ 输出各种类型的数值 -----------------------------------void print(boolean b); // 打印boolean值void print(char c); // 打印字符void print(char[]s); // 打印字符数组void print(double d); // 打印双精度浮点数void print(float f); // 打印浮点数void print(int i); // 打印整数void print(long l); // 打印long整数void print(Object obj); // 打印对象void print(String s); // 打印字符串// ------ 输出各种类型的数值 + 换行 -------------------------------void println(boolean x); // 打印boolean值，然后终止行void println(char x); // 打印字符，然后终止该行void println(char[]x); // 打印字符数组，然后终止该行void println(double x); // 打印double，然后终止该行void println(float x); // 打印float，然后终止该行void println(int x); // 打印整数，然后终止该行void println(long x); // 打印long，然后终止该行void println(Object x); // 打印Object，然后终止该行void println(String x); // 打印String，然后终止该行 // ------ 直接输出字节数据（字节流） --------------------------------void write(int b); // 将指定的字节写入此流void write(byte[] buf, int off, int len); // 将len字节从指定的初始偏移量为off的byte数组写入此流 ② err 标准错误输出流输出错误消息到控制台 System.err.println(data); /* 此输出流用于显示错误消息，或者显示那些即使用户输出流（变量out的值）已经重定向到通常不被连续监视的某一文件或其他目标，也应该立刻引起用户注意的其他信息。 */ ③ in 标准输入流接收键盘输入 read() // 读取一个字节read(byte[] b) // 读取一个字节数组 1. read()public class TestSystemInRead &#123; public static void main(String args[]) &#123; try &#123; int c; while((c=System.in.read())!=0)&#123; // 从控制台读入一个字节（8bit） System.out.write(c); // 输出一个字节 &#125; &#125; catch (Exception e) &#123; &#125; &#125;&#125;// 运行该程序，在控制台输入一段字符后按回车键，就会调用read()函数的循环，// 每读到一个字节就会输出一个字节，因此回车前输入的字符串就会原样输出。 2. read(byte[] b)/** * 首先创建了一个长度为100的字节数组，表示一次可以读取100个字节。 * 然后使用read(byte[] b)读取100个字节到byte中，再调用write()函数输出这个字节数组到控制台中。 */public class TestSystemInReadByte &#123; public static void main(String args[]) &#123; try &#123; byte[]b=new byte[100]; // 创建字节数组 System.in.read(b); // 读取到数组中 System.out.write(b,0,100); // 输出字节数组 &#125; catch (Exception e) &#123; &#125; &#125;&#125;// 运行该程序，输入一个字符串，回车后就会输出回车前字符串的前100个字符。// 如果你输入的字符串长度小于100，那么为了补全100个字节，剩余的字节将会使用方框“□”表示，实际上是这个字节没有数据。// 如果输入的字符串长度大于100，多余的字节就会被抛弃。 二、控制台读写类 - Console Console类优点： %%{ init: { 'themeVariables': { 'fontSize': '13px' } } }%% graph LR A([\"System 缺点\"]):::g B([\"Console 优点\"]):::p A -.- 1(\"读入的字节数组长度有100的限制：若字符串长度小于100将会使用方框代替，若大于100将会被抛弃。\"):::lg B -.- 2(\"不需要捕捉异常，该函数没有抛出异常\"):::lp B -.- 3(\"不需要将字节数组转化为字符串，直接读入即字符串\"):::lp B -.- 4(\"可以完整读取一行输入并完整输出，没有抛弃和填充\"):::lp classDef p fill:#ddaebd classDef b fill:#aab7d2 classDef g fill:#9ac5bb classDef lp fill:#f4e4e9 classDef lb fill:#d9dfeb classDef lg fill:#ddebe6 classDef info fill:#f6f6f7,color:#737379,stroke-dasharray: 3 3, stroke-width: 2px Console类方法可访问与当前Java虚拟机关联的基于字符的控制台设备(若有)，常指键盘。 虚拟机是否具有控制台取决于底层平台，还取决于调用虚拟机的方式： %%{ init: { 'themeVariables': { 'fontSize': '14px' } } }%% graph T([\"访问与虚拟机关联的控制台设备\"]):::p T --> A(\"① 虚拟机从交互式命令行启动，且没有重定向标准输入和输出流\"):::lp T --> B(\"② 虚拟机自动启动 （如，由后台作业调度程序启动）\"):::lg A -.- a([\"控制台存在\"]):::p B -.- b([\"无控制台\"]):::g a -.- |\"连接到设备（键盘）\"|1(\"由此类唯一的实例表示（调用 System.console() 获得）\"):::lp a -.- |\"无可用设备\"|2(\"对该方法的调用返回null\"):::info %% 将由此类唯一的实例表示（可通过调用 System.console() 获得）\") classDef p fill:#ddaebd classDef b fill:#aab7d2 classDef g fill:#9ac5bb classDef lp fill:#f4e4e9 classDef lb fill:#d9dfeb classDef lg fill:#ddebe6 classDef info fill:#f6f6f7,color:#737379,stroke-dasharray: 3 3, stroke-width: 2px ① 读取信息从控制台读取输入的字符串 /** * 使用了System.console()函数取得了Console对象， * 然后使用readLine()函数即可读取一行字符串的输入。该函数在用户执行回车时调用。 */public class TestConsole &#123; public static void main(String args[]) &#123; while (true) &#123; String str = System.console().readLine(); // 取得输入字符串 System.out.println(str); // 输出字符串 &#125; &#125;&#125; ② 输出信息从控制台输出消息 System.console().printf(str); 注：其读写操作是同步的，以保证关键操作能完整完成。因此调用readLine()、printf()时可能阻塞。 ③ 读取密码 应用程序需要读取密码或其他安全数据，则应使用 readPassword() 或 readPassword(String, Object…)，并在执行后手工将返回的字符数组归零，以最大限度地缩短内存中敏感数据的生存期。 读取密码 public class TestConsolePassword &#123; public static void main(String args[]) &#123; while (true) &#123; char password[] = System.console().readPassword(); // 取得密码 System.out.println(password); // 输出字符串 &#125; &#125;&#125;// 它直接监控键盘的输入，回车后即可取得密码字符串。 读取密码时添加提示信息 System.console().readPassword(&quot;[%s]&quot;, &quot;请输入密码：&quot;);// 字符串“请输入密码：”将作为提示信息显示在控制台窗口中。 - end - 🔖 笔记来自：《Java高手真经（编程基础卷）》","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://equnee.github.io/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://equnee.github.io/tags/Java/"},{"name":"I/O","slug":"I-O","permalink":"https://equnee.github.io/tags/I-O/"}]},{"title":"☕️ java.io","slug":"note/Basics/IO/IO","date":"2023-05-06T06:33:02.934Z","updated":"2023-05-06T06:51:54.234Z","comments":true,"path":"note/Basics/IO/IO/","link":"","permalink":"https://equnee.github.io/note/Basics/IO/IO/","excerpt":"","text":"一、标准设备输入/输出二、文件基本处理三、输入/输出流","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://equnee.github.io/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://equnee.github.io/tags/Java/"},{"name":"I/O","slug":"I-O","permalink":"https://equnee.github.io/tags/I-O/"}]},{"title":"IO - 对象序列化","slug":"note/Basics/IO/IO_Object_serialization","date":"2023-05-05T12:22:20.301Z","updated":"2023-05-06T15:40:47.181Z","comments":true,"path":"note/Basics/IO/IO_Object_serialization/","link":"","permalink":"https://equnee.github.io/note/Basics/IO/IO_Object_serialization/","excerpt":"","text":"","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://equnee.github.io/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://equnee.github.io/tags/Java/"},{"name":"I/O","slug":"I-O","permalink":"https://equnee.github.io/tags/I-O/"}]},{"title":"IO - RandomAccessFile 任意访问文件","slug":"note/Basics/IO/IO_RandomAccessFile","date":"2023-05-04T09:09:58.497Z","updated":"2023-05-06T15:11:49.863Z","comments":true,"path":"note/Basics/IO/IO_RandomAccessFile/","link":"","permalink":"https://equnee.github.io/note/Basics/IO/IO_RandomAccessFile/","excerpt":"","text":"📌 RandomAccessFile既可以读取文件内容，也可以向文件输出数据，是一个更接近于操作系统API的封装类。 与普通的输入/输出流不同的是， 它支持“随机访问”的方式，程序可以直接跳转到文件的任意地方来读写数据。（与InputStream、Reader需要依次向后读取相区分） 它将文件内容存储在一个大型byte数组中。它存在着指向该隐含byte数组的光标或索引，称为文件指针，该指针位置可以通过seek方法设置 一、使用场景%%{ init: { 'themeVariables': { 'fontSize': '13px' } } }%% graph LR T([\"RandomAccessFile 的使用场景\"]):::p T --> A(\"仅访问文件部分内容\"):::lp T --> B(\"向已存在的文件后追加内容\"):::lp classDef p fill:#ddaebd classDef b fill:#aab7d2 classDef g fill:#9ac5bb classDef lp fill:#f4e4e9 classDef lb fill:#d9dfeb classDef lg fill:#ddebe6 classDef info fill:#f6f6f7,color:#737379,stroke-dasharray: 3 3, stroke-width: 2px 只访问文件部分内容，而不是把文件从头读到尾，使用RandomAccessFile更好。 向已存在的文件后追加内容：与OutputStream、Writer等输出流不同的是，RandomAccessFile允许自由定位文件记录指针，所以RandomAccessFile可以不从开始的地方开始输出，所以RandomAccessFile可以向已存在的文件后追加内容。 二、方法java.io.RandomAccessFile ① 操作文件指针RandomAccessFile对象的记录指针：指向当前读写的位置，各种read/write操作都会自动更新该指针（移动单位：字节）。 方法 说明 long getFilePointer() 返回文件记录指针的当前位置。 void seek(long pos) 将文件记录指针定位到pos位置。 void skipBytes(int n) 使文件指针向前移动指定的n个字节。 ② 读写方法RandomAccessFile实现了DataInput/DataOutput接口： * 读取：// ------ 基本读取 --------------------------------------------int read(); // 从该文件读取一个字节的数据。int read(byte[] b); // 从文件中最多读取b.length个字节的数据，并将其存储在字节数组b中。int read(byte[] b, int off, int len); // 从指定的off位置开始，从文件中最多读取len个字节的数据。// ------ 读取指定类型的数值 -----------------------------------boolean readBoolean(); // 读取一个booleanbyte readByte(); // 读取一个有符号的8位值char readChar(); // 读取一个字符double readDouble(); // 读取一个doublefloat readFloat(); // 读取一个floatint readInt(); // 读取一个有符号的32位整数long readLong(); // 读取一个有符号的64位整数short readShort(); // 读取一个有符号的16位数int readUnsignedByte(); // 读取一个无符号的8位数int readUnsignedShort(); // 读取一个无符号的16位数// ------ 读取一行字符串 ---------------------------------------String readLine() // ------ 读取中文字符串 ---------------------------------------String readUTF() // 以上函数均按照字节码读取的，若有中文出现，readLine()会显示乱码，可使用readUTF()读取。 // 它从当前文件指针开始读取前两个字节，类似于使用readUnsignedShort。 * 写入：// ------ 基本读取 --------------------------------------------void write() // 在该文件的当前指针位置写入一个字节，并覆盖原有的字节。void write(byte[] b) // 将b.length字节从指定的字节数组写入文件（从当前文件指针开始）void write(byte[] b, int off, int len) // 从参数off指定的起始位置，将指定字节数组中的len个字节写入文件。 // ------ 写入固定类型的数值 -----------------------------------void writeBoolean(boolean v); // 按单字节值将boolean写入该文件void writeByte(int v); // 按单字节值将byte写入该文件void writeBytes(String s); // 按字节序列将该字符串写入该文件void writeChar(int v); // 按双字节值将char写入该文件，先写高字节void writeChars(String s); // 按字符序列将一个字符串写入该文件void writeDouble(double v); /* 使用Double类中的doubleToLongBits方法将双精度参数转换为一个long， 然后按8字节数量将该long值写入该文件，先写高字节 */void writeFloat(float v); /* 使用Float类中的floatToIntBits方法将浮点参数转换为一个int， 然后按4字节数量将该int值写入该文件，先写高字节 */void writeInt(int v); // 按4个字节将int写入该文件，先写高字节void writeLong(long v); // 按8个字节将long写入该文件，先写高字节void writeShort(int v); // 按2个字节将short写入该文件，先写高字节// ------ 写入一个字符串（按字节写入，若中文会乱码）----------------writeBytes() writeChars() // 按照双字节写入，即一个字符占用2个字节。 // ------ 写入中文字符串 ---------------------------------------String writeUTF() /* 它把2个字节从文件的当前文件指针写入到此文件，类似于使用writeShort方法 并给定要跟随的字节数。此值是实际写出的字节数，而不是该字符串的长度。 */ ③ 构造方法 方法 说明 RandomAccessFile(File file, String mode) 使用File参数来指定文件本身（打开文件） RandomAccessFile(String name, String mode) 使用String参数来指定文件名（打开文件） RandomAccessFile的4种访问模式： 参数值 说明 r 以只读方式打开指定文件。若试图对该RamdomAceessFile执行写入方法，都将执行IOException异常 rw 以读、写方式打开指定文件。如果该文件尚不存在，则尝试创建该文件。 rws 以读、写方式打开指定文件。相对于”rw”模式，还要求对文件的内容或元数据的每个更新都同步写入到底层存储设备。 rwd 以读、写方式打开指定文件。相对于”rw”模式，还要求对文件内容的每个更新都同步写入到底层存储设备。 三、实例① 访问指定的中间部分数据public class RandomAccessFileTest &#123; public static void main(String[] args) &#123; try( RandomAccessFile raf = new RandomAccessFile( &quot;RandomAccessFileTest.java&quot; , &quot;r&quot;)) // 以只读方式打开，只能读取 &#123; // 🔹 获取RandomAccessFile对象文件指针的位置，初始位置是0 System.out.println(&quot;RandomAccessFile的文件指针的初始位置：&quot; + raf.getFilePointer()); // 🔹 移动raf的文件记录指针的位置（将从300字节处开始读、写） raf.seek(300); byte[] bbuf = new byte[1024]; // 用于保存实际读取的字节数 int hasRead = 0; // 🔹 使用循环来重复“取水”过程 while ((hasRead = raf.read(bbuf)) &gt; 0 ) &#123; // 取出“竹筒”中的水滴（字节），将字节数组转换成字符串输入 System.out.print(new String(bbuf , 0 , hasRead )); &#125; &#125; catch (IOException ex) &#123; ex.printStackTrace(); &#125; &#125;&#125;// 运行上面程序，将看到程序只读取后面部分的效果。 ② 向指定文件后追加内容public class AppendContent &#123; public static void main(String[] args) &#123; try( // 🔹 以读、写方式打开一个 RandomAccessFile 对象 RandomAccessFile raf=new RandomAccessFile(&quot;out.txt&quot; , &quot;rw&quot;)) &#123; // 🔹 将 RandomAccessFile 对象的记录指针 移动到out.txt文件的最后 raf.seek(raf.length()); // 🔹 使用 RandomAccessFile 执行输出 raf.write(&quot;追加的内容！\\r\\n&quot;.getBytes()); &#125; catch (IOException ex) &#123; ex.printStackTrace(); &#125; &#125;&#125;// 每运行上面程序一次，都可以看到out.txt文件中多一行“追加的内容！”字符串。 ③ 向指定文件、指定位置插入内容/** * 程序先将文件中插入点后的内容读入临时文件中，然后重新定位到插入点，将需要插入的内容添加到文件后面， * 最后将临时文件的内容添加到文件后面，通过这个过程就可以向指定文件、指定位置插入内容。 */public class InsertContent &#123; public static void insert(String fileName, long pos, String insertContent) throws IOException &#123; // 🔹 创建一个临时文件来保存插入点后的数据（该临时文件将在JVM退出时被删除） File tmp = File.createTempFile(&quot;tmp&quot; , null); tmp.deleteOnExit(); try( RandomAccessFile raf = new RandomAccessFile(fileName , &quot;rw&quot;); FileOutputStream tmpOut=new FileOutputStream(tmp); FileInputStream tmpIn=new FileInputStream(tmp)) &#123; raf.seek(pos); // ------🔹 下面代码将插入点后的内容读入临时文件中保存------ byte[] bbuf=new byte[64]; // 用于保存实际读取的字节数 int hasRead=0; // 使用循环方式读取插入点后的数据 while ((hasRead=raf.read(bbuf)) &gt; 0 )&#123; // 将读取的数据写入临时文件 tmpOut.write(bbuf , 0 , hasRead); &#125; // ----------🔹 下面代码用于插入内容---------- // 把文件记录指针重新定位到pos位置 raf.seek(pos); // 追加需要插入的内容 raf.write(insertContent.getBytes()); // 追加临时文件中的内容 while ((hasRead=tmpIn.read(bbuf)) &gt; 0 )&#123; raf.write(bbuf , 0 , hasRead); &#125; &#125; &#125; public static void main(String[] args) throws IOException &#123; insert(&quot;InsertContent.java&quot; , 45 , &quot;插入的内容\\r\\n&quot;); &#125;&#125;// 每次运行上面程序，都会看到向InsertContent.java中插入了一行字符串 四、应用 多线程断点的网络下载工具（如FlashGet等）就可通过RandomAccessFile类来实现： %%{ init: { 'themeVariables': { 'fontSize': '13px' } } }%% graph LR subgraph \"[ 多线程断点的网络下载工具 ]\" A[[\"与被下载文件大小相同的空文件\"]]:::lp B[[\"记录文件指针的位置文件\"]]:::lb end net(\"网络数据\"):::info -.->|\"写入\"| A A --> |\"每写一些数据：记下文件指针位置\"|B B -.-> |\"断网后再次下载：根据记录的位置继续向下写数据\"|A classDef p fill:#ddaebd classDef b fill:#aab7d2 classDef g fill:#9ac5bb classDef lp fill:#f4e4e9 classDef lb fill:#d9dfeb classDef lg fill:#ddebe6 classDef info fill:#f6f6f7,stroke-dasharray: 3 3, stroke-width: 2px, stroke: #676666 下载工具用多条线程启动输入流来读取网络数据，并使用RandomAccessFile将从网络上读取的数据写入前面建立的空文件中，每写一些数据后，记录文件指针的文件就分别记下每个RandomAccessFile当前的文件指针位置。 - end - 🔖 笔记来自： 《Java编程的逻辑》 《疯狂Java讲义》 《Java高手真经（编程基础卷）》","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://equnee.github.io/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://equnee.github.io/tags/Java/"},{"name":"I/O","slug":"I-O","permalink":"https://equnee.github.io/tags/I-O/"}]},{"title":"IO - 输入/输出流","slug":"note/Basics/IO/IO_IO","date":"2023-03-23T12:22:11.950Z","updated":"2023-05-06T15:12:06.944Z","comments":true,"path":"note/Basics/IO/IO_IO/","link":"","permalink":"https://equnee.github.io/note/Basics/IO/IO_IO/","excerpt":"","text":"（编辑中） 一、I/O流Java中把不同的输入/输出源（键盘、文件、网络连接等）抽象表述为“流”（stream），通过流的方式允许Java程序使用相同的方式来访问不同的输入/输出源。 stream是从起源（source）到接收（sink）的有序数据。 1.1 流分类%%{ init: { 'themeVariables': { 'fontSize': '13px' } } }%% graph LR T([\"IO流分类可操作文件中的内容\"]):::p T --> A([\"按照(读/写)方向分类\"]):::p T --> B([\"按照(读/写)字节数大小分类\"]):::b T --> C([\"按照流的角色分类\"]):::g A -.-> |\"in（读取）\"| a(\"文件输入流字节型文件输入流字符型文件输入流\"):::lp A -.-> |\"out（写入）\"| a2(\"文件输出流字节型文件输出流字符型文件输出流\"):::lp B -.-> |\"1字节\"| b(\"字节型文件流（二进制内容）FileInputStreamFileOUtputStream\"):::lb B -.-> |\"1字符（2字节）\"| b2(\"字符型文件流（文本内容）FileReaderFileWriter\"):::lb C -.-> |\"直接连接到数据源\"| c(\"底层节点流（低级流）\"):::lg C -.-> |\"封装已存在的流\"| c2(\"上层处理流（高级流）\"):::lg classDef p fill:#ddaebd classDef b fill:#aab7d2 classDef g fill:#9ac5bb classDef lp fill:#f4e4e9 classDef lb fill:#d9dfeb classDef lg fill:#ddebe6 classDef info fill:#f6f6f7,color:#737379,stroke-dasharray: 3 3, stroke-width: 2px 1.2 流模型（1）流的基本概念模型%%{ init: { 'themeVariables': { 'fontSize': '13px' } } }%% graph TD T([\"流的模型\"]):::p --> t(\"4个抽象基类Java IO流40多个类都由它们派生\") t --> |\"输入流\"| A(\"InputStrean（字节输入流）Reader（字符输入流）\"):::lp t --> |\"输出流\"| B(\"OutputStream（字节输出流）Writer（字符输出流）\"):::lp A -.-> a(\"把输入设备抽象成“水管”，水管里的每个“水滴”依次排列\"):::info B -.-> b(\"把输出设备抽象成“水管”，水管里没有任何水滴\"):::info classDef p fill:#ddaebd classDef b fill:#aab7d2 classDef g fill:#9ac5bb classDef lp fill:#f4e4e9 classDef lb fill:#d9dfeb classDef lg fill:#ddebe6 classDef info fill:#f6f6f7,color:#737379,stroke-dasharray: 3 3, stroke-width: 2px 输入流： 输入流使用隐式的记录指针来表示当前正准备从哪个“水滴”开始读取，每当程序从InputStream或Reader里取出一个或多个“水滴”后，记录指针自动向后移动。 输出流： 当执行输出时，程序相当于依次把“水滴”放入到输出流的水管中，输出流同样采用隐式的记录指针来标识当前水滴即将放入的位置，每当程序向OutputStream或Writer里输出一个或多个水滴后，记录指针自动向后移动。 注：划分输入/输出流时是从程序运行所在内存的角度来考虑的，因此（内存 —&gt; 硬盘）应该是输出流。 （2）处理流模型 节点流和处理流 使用节点流（低级流）进行输入/输出时，程序直接连接到实际的数据源，和实际的输入/输出节点连接。 处理流（高级流）则用于对一个已存在的流进行连接或封装，通过封装后的流来实现数据读/写功能。 处理流的功能 graph LR T([\"处理流模型\"]) T --> t(\"体现Java I/O流设计的灵活性\") t --> A(\"① 性能提高\") t --> B(\"② 操作简单\") A -.-> a(\"以增加缓冲的方式来提高输入/输出的效率\") B -.-> b(\"处理流可能提供了一系列便捷的方法来一次输入/输出大批量的内容，而不是输入/输出一个或多个“水滴”。\") 处理流模型图 使用处理流来包装节点流，程序通过处理流来执行输入/输出功能，让节点流与底层的I/O设备、文件交互。（处理流可以“嫁接”在任何已存在的流的基础之上） 💡 Java使用处理流来包装节点流是一种典型的装饰器设计模式，通过使用处理流来包装不同的节点流，既可以消除不同节点流的实现差异，也可以提供更方便的方法来完成输入/输出功能。因此处理流也被称为包装流。 1.3 字节流和字符流（1）InputStream 和 Reader InputStream包含的3个方法： 方法 说明 int read() 从输入流中读取单个字节，返回所读取的字节数据（字节数据可直接转换为int类型）。 int read(byte[] b) 从输入流中读取数据（最多b.length个字节），并将其存储在字节数组b中，返回实际读取的字节数。 int read(byte[] b, int off, int len) 从输入流中读取数据（最多len个字节），并将其存储在数组b中，放入数组b中时从off位置开始（并不是从数组起点开始），返回实际读取的字节数。 reader包含的3个方法： 方法 说明 int read() 从输入流中读取单个字符，返回所读取的字符数据（字符数据可直接转换为int类型）。 int read(char[] cbuf) 从输入流中读取数据（最多cbuf.length个字符），并将其存储在字符数组cbuf中，返回实际读取的字符数。 int read(char[] cbuf, int off, int len) 从输入流中读取数据（最多len个字符），并将其存在字符数组cbuf中，从off位置开始，返回实际读取的字符数。 模型： InputStream 和 Reader 都是将输入数据抽象成如图所示的水管： 所以程序既可以通过 read() 方法每次读取一个“水滴”，也可以通过 read(char[] cbuf) 或 read(byte[] b) 方法来读取多个“水滴”。 使用数组作为 read() 方法的参数时，可以理解为使用一个“竹筒”到水管中取水。直到read(char[] cbuf)或read(byte[] b)方法返回-1，即表明到了输入流的结束点。 文件流 InputStrea 和 Reade 都是抽象类，本身不能创建实例，但它们分别有一个用于读取文件的输入流：*FileInputStream 和 *FileReader，它们都是节点流——会直接和指定文件关联。（见下文） （2）OutputStream 和 Writer OutputStream包含的3个方法： 方法 说明 void write(int c) 将指定的字节/字符c输出到输出流中。 int write(byte[]/char[] buf) 将字节数组/字符数组中的数据输出到指定输出流中。 int write(byte[]/char[] buf, int off, int len) 从输入流中读取数据（最多len个字节），并将其存储在数组b中，放入数组b中时从off位置开始（并不是从数组起点开始），返回实际读取的字节数。 Writer包含的2个方法： Writer可以用字符串来代替字符数组，即以String对象作为参数 方法 说明 int write(String str) 将str字符串里包含的字符输出到指定输出流中。 int write(String str, int off, int len) 将str字符串里从off位置开始，长度为len的字符输出到指定输出流中。 *Demo：直接输出字符串内容（FileWriter）* public class FileWriterTest &#123; public static void main(String[] args) &#123; try(FileWriter fw=new FileWriter(&quot;poem.txt&quot;))&#123; fw.write(&quot;锦瑟 - 李商隐\\r\\n&quot;); fw.write(&quot;锦瑟无端五十弦，一弦一柱思华年。\\r\\n&quot;); fw.write(&quot;庄生晓梦迷蝴蝶，望帝春心托杜鹃。\\r\\n&quot;); fw.write(&quot;沧海月明珠有泪，蓝田日暖玉生烟。\\r\\n&quot;); fw.write(&quot;此情可待成追忆，只是当时已惘然。\\r\\n&quot;); &#125;catch (IOException ioe)&#123; ioe.printStackTrace(); &#125; &#125;&#125;// 运行上面程序，将会在当前目录下输出一个poem.txt文件，文件内容就是程序中输出的内容。 1.4 *流体系Java把所有传统的流类型（类或抽象类）都放在 java.io 包中，以实现输入/输出功能。 分类 字节输入流 字节输出流 字符输入流 字符输出流 抽象基类 InputStream OutputStream Reader Writer 访问文件 File-InputStrean File-OutputStream File-Reader File-Writer 访问数组 ByteArray-InputStream ByteArray-OutputStream CharArray-Reader CharArray-Writer 访问管道 Pipe-InputStream Piped-OutputStream Piped-Reader Piped-Writer 访问字符串 String-Reader String-Writer 缓冲流 Buffered-InputStream Buffered-OutputStream Buffered-Reader Buffered-Writer 转换流 InputStream-Reader OutputStream-Writer 对象流 Object-InputStream Object-OutputStream 抽象基类 Filter-InputStream Filter-OutputStream Filter-Reader Filter-Writer 打印流 Print-Stream Print-Writer 推回输入流 Pushback-InputStream Pushback-Reader 数据流 Data-InputStream Data-OutputStream 说明： 分类 说明 抽象基类 无法直接创建实例，必须通过子类创建。 节点流（粗体） 必须与指定的物理节点关联。如，需传入数组或字符串。 管道流 用于实现进程之间通信功能。 缓冲流 增加缓冲功能，可以提高输入、输出的效率。（对流起缓冲装饰）* 需要使用 flush() 才可以将缓冲区的内容写入实际的物理节点。 转换流 用于实现将字节流转换成字符流。 对象流 主要用于实现对象的序列化。 打印流（格式化） 可以将基本类型、对象输出为其字符串表示。 推回输入流 将读取内容推回到推回缓冲区里以重复读取。 数据流 可以按8种基本类型和字符串对流进行读写。 二、文件流2.1 文件（1）File - 文件%%{ init: { 'themeVariables': { 'fontSize': '13px', } } }%% graph TD t([\"File文件对象\"]):::p t --> T T(\"file对象不是真正的文件，而是堆内存中创建出来的一个对象空间\"):::lp T --> A(\"File类能操作文件本身的属性\"):::lb T --> B(\"File对象不能操作文件中的内容\"):::lb A -.-> a(\"* 查看文件属性* 创建新文件、文件夹* 查看父级目录* 遍历、删除文件夹\"):::info B --> b(\"需要通过 I/O 的方式来完成\"):::info classDef p fill:#ddaebd classDef b fill:#aab7d2 classDef g fill:#9ac5bb classDef lp fill:#f4e4e9 classDef lb fill:#d9dfeb classDef lg fill:#ddebe6 classDef info fill:#f6f6f7,color:#737379,stroke-dasharray: 3 3, stroke-width: 2px ① 所属的包java.io ② 实现的接口Serializable， Comparable ③ 构造方法 构造方法 说明 （没有无参构造方法） File(String pathname) 创建一个File对象 File(File parent, String child) 在A文件夹里创建B文件 File(String parent, String child) 给A文件夹对象，再给B文件夹名字 File(URI uri) 通过网络路径创建 ④ 常用方法 文件基本属性 常用方法 说明 canExecute() 可执行 canRead() 可读 canWrite() 可写 exists() 文件名或路径是否存在 isHidden() 是否隐藏 isFile() 判断当前file是否是一个文件 isDirectory() 判断当前file是否是一个目录 isAbsolute() 判断File对象所对应的文件或目录是否是绝对路径 length() 获取文件中字节的个数 lastModified() 获取文件最后的修改时间（long类型：毫秒值） 文件名 常用方法 说明 返回值类型 getName() 获取文件名字（Test.txt） String name getAbsolutePath() 获取文件的绝对路径（D://test//Test.txt） String path getPath() 获取文件的完整路径 String path renameTo() 重命名，命名成功返回true Boolean true 创建 常用方法 说明 返回值类型 createNewFile() 创建新的文件 boolean mkdir() 创建新的文件夹 boolean mkdirs() 同时创建外层新文件夹 boolean 获取对象 常用方法 说明 返回值类型 getParent() 获取当前file的父目录的完整路径 String name getParentFile() 获取当前file的父亲file对象 File file getAbsoluteFile() 返回此File对象所对应的绝对路径所对应的File对象 File file list() 获取当前file对象的所有儿子名字 String[] names listFiles() 获取当前file对象的所有儿子对象 File[] files static listRoots() 列出系统所有的根路径。 File[] files 删除 常用方法 说明 返回值类型 delete() 彻底删除文件或空目录，无法删除带元素的文件夹 boolean deleteOnExit() 删除文件或目录并关闭流操作 boolean - Demopackage com.equne;import java.io.File;import java.io.IOException;public class FileTest&#123; public static void main(String[] args) throws IOException &#123; // 以当前路径来创建一个File对象 File file=new File(&quot;.&quot;); // 直接获取文件名，输出一点 System.out.println(file.getName()); // 获取相对路径的父路径可能出错，下面代码输出null System.out.println(file.getParent()); // 获取绝对路径 System.out.println(file.getAbsoluteFile()); // 获取上一级路径 System.out.println(file.getAbsoluteFile().getParent()); // 在当前路径下创建一个临时文件 File tmpFile=File.createTempFile(&quot;aaa&quot;, &quot;.txt&quot;, file); // 指定当JVM退出时删除该文件 tmpFile.deleteOnExit(); // 以系统当前时间作为新文件名来创建新文件 File newFile=new File(System.currentTimeMillis() + &quot;&quot;); System.out.println(&quot;newFile对象是否存在：&quot; + newFile.exists()); // 以指定newFile对象来创建一个文件 newFile.createNewFile(); // 以newFile对象来创建一个目录，因为newFile已经存在 // 所以下面方法返回false，即无法创建该目录 newFile.mkdir(); // 使用list()方法列出当前路径下的所有文件和路径 String[] fileList=file.list(); System.out.println(&quot;====当前路径下所有文件和路径如下====&quot;); for (String fileName : fileList) &#123; System.out.println(fileName); &#125; // listRoots()静态方法列出所有的磁盘根路径 File[] roots=File.listRoots(); System.out.println(&quot;====系统所有根路径如下====&quot;); for (File root : roots) &#123; System.out.println(root); &#125; &#125;&#125;/** * . * null * /Users/equne/Desktop/testJava/Test2/. * /Users/equne/Desktop/testJava/Test2 * newFile对象是否存在：false * ====当前路径下所有文件和路径如下==== * Test2.iml * out * 1679734377738 * aaa5603141847215609264.txt * .idea * src * ====系统所有根路径如下==== * / * */ (摘自《疯狂Java讲义》) . （2）*递归：遍历文件夹① 递归 本质：方法的调用 （即自己调用自己，且每次传的参数都不一样） 方法：盖宝塔 public class newTestFile&#123; public void buildTower(int floor)&#123; // 设计一个方法，描述盖宝塔 if(floor&gt;1)&#123; this.buildTower(floor-1); &#125; System.out.println(&quot;改到第&quot;+ floor + &quot;层啦&quot;); // 自己执行 &#125;&#125; 内存结构图 ② 遍历文件夹import java.io.File;public class newTestFile&#123; // 遍历文件夹。参数：file(代表文件或文件夹) public void showFile(File file)&#123; File[] files = File.listFiles(); // 如果在调用前输出，则相反输出 if(files!=null &amp;&amp; files.length!=0)&#123; // 非文件 &amp;&amp; 非空文件夹 for(File f:files)&#123; // 遍历 this.showFile(); &#125; &#125; System.out.println(file.getAbsolutePath()); &#125;&#125; 删除文件夹：file.delete(); // 将上面的例子替换 2.2 文件流（低级文件流）graph LR T([\"文件流（低级文件流）\"]):::p T --> t(\"可操作文件中的内容\"):::info t --> A([\"按照(读/写)方向分类\"]):::p t --> B([\"按照(读/写)字节数大小分类\"]):::b A -.-> |\"in（读取）\"| a(\"文件输入流字节型文件输入流字符型文件输入流\"):::lp A -.-> |\"out（写入）\"| a2(\"文件输出流字节型文件输出流字符型文件输出流\"):::lp B -.-> |\"1字节\"| b(\"字节型文件流FileInputStreamFileOUtputStream\"):::lb B -.-> |\"1字符（2字节）\"| b2(\"字符型文件流FileReaderFileWriter\"):::lb classDef p fill:#ddaebd classDef b fill:#aab7d2 classDef g fill:#9ac5bb classDef lp fill:#f4e4e9 classDef lb fill:#d9dfeb classDef lg fill:#ddebe6 classDef info fill:#f6f6f7,color:#737379,stroke-dasharray: 3 3, stroke-width: 2px （1）FileInputStram字节型文件输入流 + 所属的包Java.io + 继承关系继承于 InputStream 类（字节型输入流） + 构造方法 构造方法 说明 （没有无参构造方法） FileInputStram(File file) 利用File对象构造 FileInputStram(String name) 通过文件路径字符串构造 + 常用方法 常用方法 说明 返回值类型 finalize() GC对象回收 available() 返回当前流管道中有多少缓存字节，每次读取一个字节对应的 Unicode 码。（读得到返回 0–65536，读不到返回-1） int 🔺 read() 从输入流中读取单个字节，返回读取的字节数据（Unicode码） int read(byte[])：将输入流内容写入数组里，返回实际读取的字节数。 int read(byte[] b, int off, int leng)：将输入流内容写入数组里，从off位置开始，放入len个字节（不是从数组起点开始），返回实际读取的字节数。 int skip() 跳过几个字节读取 long n close() 关闭流管道（⚠️ 必须要做，最好放在 finally{} 里） - read()创建一个字节型文件输入流，读取文件中的内容。 try&#123; File file = new File(&quot;D://Test//test.txt&quot;); FileInputStream fis = new FileInputStram(file); int i = fis.read(); // ← 每次读取一个字节 while(i!=-1)&#123; System.out.ptinln(i); // → 返回字节对应得Unicode码 i = fis.read(); &#125;&#125;catch(IOException e)&#123; e.printStackTrace;&#125; - read(byte[] b)读取文件内容，装入数组内。返回读取的有效字符个数。 try&#123; FileInputStream fis = new FileInputStram(&quot;D://Test//test.txt&quot;); byte[] b = new bytep[5]; int count = fis.read(b); // ← 读取文件内容，装进数组里 while(count!=-1)&#123; // → 返回读取到的有效字节个数 // 🔸 String value = new String(b); String value = new String(b, 0, count); // 使用偏移量构造字节型数组字符串 System.out.ptint(value); // count = fis.read(b); &#125; &#125;catch(IOException e)&#123; e.printStackTrace; &#125;/* 文件内容： * abcdefg * hijklmn * opq *//* 🔸 直接使用String(b)读取内容： * a b c d e * f g \\r \\n h * i j k l m * n \\r \\n o p * q \\r \\n o p &lt;—— 到q结束，但是之前的没有被替换掉 - skip()try &#123; FileInputStream fis = new FileInputStream(&quot;D://Test//test.txt&quot;); fis.skip(2); int code = fis.read(); // c System.out.println((char)code);&#125; catch (IOException e) &#123; e.printStackTrace();&#125; - close()try&#123; File file = new File(&quot;D://Test//test.txt&quot;); FileOutStream fos = new FileOutStram(file); fos.write(97); // 写入code码 fos.flush(); // 刷新 将管道中的字节推入文件中&#125;catch(IOException e)&#123; e.printStackTrace;&#125; （2）FileOutputStream字节型文件输出流 + 所属的包Java.io + 继承关系继承于 OutputStream 类 + 构造方法 构造方法 说明 （没有无参构造方法） FileOutputStram(File file) 利用File对象构造（默认覆盖原文） FileOutputStram(File file, Boolean append) 利用File对象构造、是否将内容追加到文件末尾（true：不覆盖） FileOutputStram(String name) 通过文件路径字符串构造 FileOutputStram(String name, Boolean append) 通过文件路径构造、是否追加到文件末尾 + 常用方法 常用方法 说明 *finalize()* GC对象回收 write() 写入到文件（与read()区别） write(int code)：将给定code写入文件 （’=’字符char也行,会自动转换） write(byte[])： 将数组内容写入文件流里（String—getByte()） flush() 刷新：将管道内字节推入文件 close() * 注意：在finally中关闭 -write()try&#123; File file = new File(&quot;D://Test//test.txt&quot;); FileOutStream fos = new FileOutStram(file); fos.write(97); // 写入code码 fos.flush(); // 刷新 将管道中的字节推入文件中 &#125;&#125;catch(IOException e)&#123; e.printStackTrace;&#125; （3）FileReader字符型文件输入流 + 所属的包Java.io + 继承关系继承于InputStreamReader 类（字节型输入流） + 构造方法 构造方法 说明 （没有无参构造方法） FileReader(File file) 通过File对象构造（默认覆盖原文） FIleReader(String fileName) 通过文件路径字符串构造 FileReader(FileDescriptor fd) 通过文件描述符构建（文件描述符的有效范围是 0 到 OPEN_MAX） + 常用方法 常用方法 说明 🔺 read() 从输入流中读取单个字符，返回所读取的字符数据 int read(char[] cbuf) 从输入流中最多读取cbuf.length个字符的数据，并将其存储在字符数组cbuf中，返回实际读取的字符数。 int read(char[] cbuf, int off, int len) 从输入流中最多读取len个字符的数据，并将其存储在字符数组cbuf中，从off位置开始存储（并不是从数组起点开始），返回实际读取的字符数。 （4）FileWriter字符型文件输出流 + 所属的包Java.io + 继承关系继承于 OutputStreamWriter 类 （字节型输出流） + 构造方法 构造方法 说明 （没有无参构造方法） FileWriter(File file) 利用File对象构建（默认覆盖原文） FileWriter(File file, Boolean boolean) 利用File对象构造、是否将内容追加到文件末尾（true：不覆盖） FileWriter(String name) 通过文件路径字符串构造 FileWriter(String name, Boolean boolean) 通过文件路径字符串构造、是否追加到文件末尾 + 常用方法 常用方法 说明 write() 读取 write(char) write(String) - write()String str = &quot;abc&quot;;char[] c = str.toCharArray();FileWriter fw = new FileWriter(file);fw.write(97);fw.write(c); 🔸 Demo① 文件的复制import java.io.*;public class OperateFile &#123; public void copyFile(File file, String path)&#123; try &#123; // 🔻 0 创建对象 FileInputStream fis = new FileInputStream(new File(&quot;D://test.txt&quot;)); File newFile = new File(path + &quot;//&quot; + file.gsetName()); FileOutputStream fos = new FileOutputStream(newFile); // 🔻 1 读取文件 byte[] b = new byte[1024]; // 通常创建的数组：1kb-8kb之间 int count = fis.read(b); // count记录读取的有效字节数，读取到byte数组b里 // 🔻 2 写入文件 while(count!=-1)&#123; // 当能读取到内容时 // 🔸（做点手脚） fos.write(b, 0, count); // 写入有效字节数 fos.flush(); count = fis.read(b); // 最后再次读取，读取不到内容时，count=-1时退出while循环 &#125; System.out.println(&quot;复制完毕！&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; // 关闭 &#125; &#125; public static void main(String[] args) &#123; OperateFile of = new OperateFile(); of.copyFile(new File(&quot;D://test.txt&quot;), &quot;D://test&quot;); &#125;&#125; ② 文件的加密// 读取文件 -&gt; 做点手脚 -&gt; 写入文件byte temp = b[0];b[0] = b[1];b[1] = temp; ③ 文件夹的复制public void superCopyFile(File file, String newPath)&#123; String oldFilePath = file.getAbsolutePath(); String newFilePath = newPath + oldFilePath.split(&quot;:&quot;)[1]; File[] files = file.listFiles(); // 获取当前传递进来的File对象的所有子元素 File newFile = new File(newFilePath); // 判断当前传递进来的file是个文件还是个文件夹 （①isFile isDirectory ②listFile) if(files!=null)&#123; // 🔻 1. 文件夹（才能构成文件数组对象） newFile.mkdir(); // 通过新的file对象操作 在硬盘上创建一个文件夹 if(files.length!=0)&#123; // 🔻 3. 文件夹内有文件 for(File f:files)&#123; this.superCopyFile(f, newPath); // 👈 使用递归 &#125; &#125; System.out.println(newFile.getName() + &quot;文件夹复制完成！&quot;); &#125; else &#123; // 🔻 2. 文件 （没有子文件了） FileInputStream fis = null; FileOutputStream fos = null; try &#123; fis = new FileInputStream(new File(oldFilePath)); fos = new FileOutputStream(newFile); byte[] b = new byte[1024]; int count = fis.read(b); while(count!=-1)&#123; fos.write(b,0,count); fos.flush(); count = fis.read(b); &#125; System.out.println(newFile.getName() + &quot;文件复制完成！&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(fis!=null)&#123; try &#123; fis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (fos!=null)&#123; try &#123; fos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 2.3 缓冲流（高级文件流） 三、缓冲流 四、转换流转换流（InputStreamReader、OutputStreamWriter），Reader的子类，可以将 InputStream 包装成 Reader。用于实现将字节流转换成字符流。—— 可解决文件乱码问题。 Demo：获取键盘输入 /* 该程序将 System.in 包装成 BufferedReader， BufferedReader流具有缓冲功能，它可以一次读取一行文本： 以换行符为标志，若没有读到换行符，则程序阻塞，等到读到换行符为止。*/public class KeyinTest &#123; public static void main(String[] args) &#123; try&#123; // 将Sytem.in对象转换成Reader对象 InputStreamReader reader = new InputStreamReader(System.in); // 将普通的Reader包装成BufferedReader BufferedReader br = new BufferedReader(reader)) String buffer = null; // 采用循环方式来逐行地读取 while ((buffer = br.readLine()) !=null) &#123; //如果读取的字符串为&quot;exit&quot;，则程序退出 if (buffer.equals(&quot;exit&quot;)) &#123; System.exit(1); &#125; //打印读取的内容 System.out.println(&quot;输入内容为:&quot; + buffer); &#125; &#125; catch (IOException ioe) &#123; ioe.printStackTrace(); &#125; &#125;&#125; InputStreamReader Java使用 System.in 代表标准输入（即键盘输入），但这个标准输入流是 InputStream 类的实例，使用不太方便，且键盘输入内容都是文本内容，所以可用 InputStreamReader 将其转换成字符输入流。 BufferedReader： 由于 BufferedReader 具有一个 readLine() 方法，可以非常方便地一次读入一行内容，所以经常把读取文本内容的输入流包装成 BufferedReader，用来方便地读取输入流的文本内容。 🔸 只有字节转字符：因为字符流比字节流操作更方便 五、推回输入流 PushbackInputStream 和 PushbackReader 的3个方法： 方法 说明 void unread(int b) 将一个字节/字符推回到推回缓冲区里，从而允许重复读取刚刚读取的内容。 void unread(byte[]/char[] buf) 将一个字节/字符数组内容推回到推回缓冲区里，从而允许重复读取刚刚读取的内容。 void unread(byte[]/char[] b, int off, int len) 将一个字节/字符数组里从off开始，长度为len字节/字符的内容推回到推回缓冲区里，从而允许重复读取刚刚读取的内容。 推回输入流的处理示意图 异常： 当创建一个 PushbackInputStream 和 PushbackReader 时需要指定推回缓冲区的大小，默认的推回缓冲区的长度为1。 若程序中推回到推回缓冲区的内容超出了推回缓冲区的大小，将会引发 Pushback buffer overflow 的 IOException 异常。 Demo： public class TestPushbackInputStream &#123; public static void main(String[] args) &#123; try &#123; // 创建文件输入流 FileInputStream fis = new FileInputStream(&quot;D:/demo/test.txt&quot;); // 创建推回输入流 PushbackInputStream pis = new PushbackInputStream(fis); // 读取对象数据 int c = pis.read(); System.out.print((char)c); pis.unread(c); // 🔻 推回一个字节 c=pis.read(); // 再次读取 System.out.print((char)c); // 关闭输入流 pis.close(); fis.close(); &#125; catch (IOException e) &#123; &#125; &#125;&#125;// 运行该程序将会重复输出第一个字符。 六、打印流参考：《廖雪峰Java教程》 6.1 PrintStream%%{ init: { 'themeVariables': { 'fontSize': '13px' } } }%% graph LR A([\"PrintStream（与OutputStream相比）\"]):::p A -.-> a(\"添加了一组 print() / println() 方法，可以打印各种数据类型，比较方便。\"):::lp A -.-> b(\"不会抛出IOException\"):::lp A -.-> c(\"自动刷新机制：写入内容后自动调用flush()方法\"):::lp classDef p fill:#ddaebd classDef lp fill:#f4e4e9 （字节型）PrintStream 是一种 FilterOutputStream，在 OutputStream 的接口上，额外提供了一些写入各种数据类型的方法。以及对应的一组 println() 方法（自动加上换行符）。 方法 说明 void print(boolean) 将boolean类型数据对应字符串写到PrintStream流中 void print(char) 将char类型数据对应字符串写到PrintStream流中 void print(int) 将int类型数据对应字符串写到PrintStream流中 void print(long) 将long类型数据对应字符串写到PrintStream流中 void print(float) 将float类型数据对应字符串写到PrintStream流中 void print(double) 将double类型数据对应字符串写到PrintStream流中 void print(char[]) 将字符串数组写到PrintStream流中 void print(String) 将字符串写到PrintStream流中 void print(Obj) 将对象对应字符串写到PrintStream中 🔺 两方法写入数据时都会将数据转换成字符串，实际调用的方法：write(String s)。 ptrint(0x61) = write(String.valueOf(0x61)) 6.2 PrintWriter （字符型）PrintWriter扩展了 Writer 接口，它的 print() / println() 方法最终输出的是 char 数据。使用方法同 PrintStream。 6.3 重定向标准输入/输出 重定向标准输入/输出 Java的标准输入/输出分别通过 System.in（从键盘输入）和 System.out（输出到屏幕）来代表。而 System 类里提供了如下3个重定向标准输入/输出的方法。 方法 说明 static void setErr(PrintStream err) 重定向 “标准”错误输出流。 static void setIn(InputStream in) 重定向“标准”输入流。 static void setOut(PrintStream out) 重定向 “标准”输出流。 demo：重定向标准输出 /** * 通过重定向标准输出流，将System.out的输出重定向到文件输出，而不是在屏幕上输出。 */public class RedirectOut &#123; public static void main(String[] args) &#123; try( // 一次性创建PrintStream输出流 PrintStream ps=new PrintStream(new FileOutputStream(&quot;out.txt&quot;))) &#123; // 将系统的标准输出重定向到ps输出流 System.setOut(ps); // 向标准输出输出一个字符串 System.out.println(&quot;普通字符串&quot;); // 向标准输出输出一个对象 System.out.println(new RedirectOut()); &#125; catch (IOException ex) &#123; ex.printStackTrace(); &#125; &#125;&#125; 该代码创建了一个 PrintStream 输出流，并将系统的标准输出重定向到该 Print Stream 输出流。运行该程序无任何输出：因为标准输出不再输出到屏幕，而是输出到 out.txt 文件。 demo：重定向标准输入 /** * 下面程序重定向标准输入，从而可以将System.in重定向到指定文件，而不是键盘输入。 */public class RedirectIn &#123; public static void main(String[] args) &#123; try( FileInputStream fis=new FileInputStream(&quot;RedirectIn.java&quot;)) &#123; // 将标准输入重定向到fis输入流 System.setIn(fis); // 使用System.in创建Scanner对象，用于获取标准输入 Scanner sc=new Scanner(System.in); // 增加下面一行只把回车作为分隔符 sc.useDelimiter(&quot;\\n&quot;); // 判断是否还有下一个输入项 while(sc.hasNext()) &#123; // 输出输入项 System.out.println(&quot;键盘输入的内容是：&quot; + sc.next()); &#125; &#125; catch (IOException ex) &#123; ex.printStackTrace(); &#125; &#125;&#125; 该代码创建了一个 FileInputStream 输入流，并使用 System 的 setIn() 方法将系统标准输入重定向到该文件输入流。 运行上面程序，程序不会等待用户输入，而是直接输出了 RedirectIn.java 文件的内容，这表明程序不再使用键盘作为标准输入，而是使用指定文件作为标准输入源。 七、对象流对象的序列化（Serialize）指将一个Java对象写入IO流中；对象的反序列化（Deserialize）则指从IO流中恢复该Java对象。只有支持java.io.Serializable或java.io.Externalizable接口的对象才能从流读取。 序列化细节： %%{ init: { 'themeVariables': { 'fontSize': '13px' } } }%% graph LR T([序列化细节]):::p T -.-> 1(\"① 读写顺序要一致\"):::lp T -.-> 2(\"② 要求必须实现 Serializable 接口\"):::lp T -.-> 3(\"③ 在序列化的类中添加 SerialVersionUID，提高版本兼容性\"):::lp T -.-> 4(\"④ 序列化对象时默认所有属性都序列化，除 static 和 transit\"):::lp T -.-> 5(\"⑤ 序列化可继承性，若某类实现序列化，其子类也默认实现序列化\"):::lp classDef p fill:#ddaebd classDef lp fill:#f4e4e9 7.1 序列化 Person 类： public class Person implements java.io.Serializable &#123; // 🔹 使用Serializable来实现序列化，让目标类实现Serializable标记接口 private String name; private int age; // 注意此处没有提供无参数的构造器：🔻反序列化机制无须通过构造器来初始化Java对象 public Person(String name , int age) &#123; System.out.println(&quot;有参数的构造器&quot;); this.name=name; this.age=age; &#125; // 省略name与age的setter和getter方法 ...&#125; 使用 ObjectOutputStream 将一个Person对象写入磁盘文件： public class WriteObject&#123; public static void main(String[] args) &#123; try( // 🔹（1）创建一个ObjectOutputStream输出流 ObjectOutputStream oos = new ObjectOutputStream( new FileOutputStream(&quot;object.txt&quot;))) // 这个输出流是一个处理流，所以必须建立在其他节点流（文件输出流）的基础之上 &#123; Person per = new Person(&quot;孙悟空&quot;, 500); // 🔹（2）调用ObjectOutputStream对象的writeObject()方法输出可序列化对象 oos.writeObject(per); // 将per对象写入输出流 &#125; catch (IOException ex)&#123; ex.printStackTrace(); &#125; &#125; &#125;// 运行上面程序，将会看到生成了一个object.txt文件，该文件的内容就是Person对象。 7.2 反序列化如果希望从二进制流中恢复Java对象，则需要使用反序列化。 从刚刚生成的object.txt文件中读取Person对象： public class ReadObject &#123; public static void main(String[] args) &#123; try( // 🔹（1）创建一个ObjectInputStream输入流 ObjectInputStream ois=new ObjectInputStream( new FileInputStream(&quot;object.txt&quot;))) // 这个输入流是一个处理流，所以必须建立在其他节点流的基础之上。 &#123; // 🔹（2）从输入流中读取一个Java对象，并将其强制类型转换为Person类 Person p = (Person)ois.readObject(); // 调用ObjectInputStream对象的readObject() System.out.println(&quot;名字为：&quot; + p.getName() + &quot;\\n年龄为：&quot; + p.getAge()); &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; &#125;&#125; - end - 🔖 笔记来自： 《Java编程的逻辑》 《Java高手真经（编程基础卷）》 《疯狂Java讲义》","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://equnee.github.io/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://equnee.github.io/tags/Java/"},{"name":"I/O","slug":"I-O","permalink":"https://equnee.github.io/tags/I-O/"}]},{"title":"🦋 HashMap 原理及源码分析","slug":"note/Data-Structure/data-structure_HashMap","date":"2023-03-09T15:11:32.969Z","updated":"2023-05-04T09:28:31.248Z","comments":true,"path":"note/Data-Structure/data-structure_HashMap/","link":"","permalink":"https://equnee.github.io/note/Data-Structure/data-structure_HashMap/","excerpt":"","text":"（本文编辑中） 注：本文制作的流程图仅为个人理解，仅供参考。 一、HashMap介绍1. 原理（1）HashMap怎么存取%%{ init: { 'themeVariables': { 'fontSize': '13px' } } }%% graph TD T((\"HashMap怎么存取值\")):::p T --> |\"数据以键值对形式存储\"| A[\"key — value\"] A --> |\"包装为Node数组对象\"| B[\"Node { key, value }\"] B --> |\"通过node数组下标保存对应数据\"| C[\"node[0] = new Node { key, value }node[1] = new Node { key, value }node[2] = new Node { key, value } ...\"] C -.-> |\"[ 保存 ] 遍历数组，对应key和value\"| D[\"for (Node node : nodes)\"] C --> |\"[ 获取 ] 通过 数组索引 获取（key的hash值）\"|E[\"node[ hash(key) ] = value\"]:::lb classDef p fill:#ddaebd style E fill:#d9dfeb, stroke:#657eae,stroke-width:2px,stroke-dasharray: 3 3 使用Node数组保存、通过Node数组索引获取。 （2）Hash算法怎么写%%{ init: { 'themeVariables': { 'fontSize': '13px', 'clusterBorder': 'none', 'clusterBkg': '#f0f2f7' } } }%% graph TD T((\"Hash算法怎么写？\")):::p T --> |\"如何计算出数组索引？hash(key)\"| A[\"* 因为Node数组有固定的初始化默认长度（length）* 索引值需限定在数组长度范围内（0～length-1）* 索引值还要尽可能平衡、分布均匀\"] A --> B([\"取模运算：hash % length\"]) B ==> |\"（更好的方案：使用位运算效率更高）\"| C([\"位运算：hash & (length - 1)\"]) C -.- c(\"length必须是2的n次幂\"):::b subgraph \"前置条件\" c -.- c2[\"假如 key = 20, length = 16, hash & (length-1):0001 0100 // 20 0000 1111 // 150000 0100 // =4\"]:::c2 end classDef p fill:#ddaebd classDef b fill:#d2d9e7, stroke-width: 0px style c2 color: #86868b, fill:#ebedf3, stroke-dasharray: 3 3 %% 取模运算 style B fill: #f4e4e9 %% \"位运算\" style C fill:#b8c3d9, stroke:#657eae,stroke-width:2px 为了解决取模的效率问题，采用了位运算的方法：index = hash值 &amp; (length -1)此时需要一个前置条件：length的长度必须是2的n次幂。当length的长度是2n时，有以下公式成立： num%2n = num&amp;(2n-1) 。 🦋 因为就像十进制取余数一样，若除以10或10的整次幂数，余数刚好是取低位上的数字。同理，二进制取余数只要除以2的n次幂数，低位上的数字就是我们需要的余数。而(2n - 1)的二进制有效位都是1，和n位的1作与运算相当于取低n位的值。 length的长度刚好是2的n次幂，扩容也是按原来的2倍容量进行扩容，可以加快hash计算、减少hash冲突。 🦋 加快hash计算： 两倍扩容机制使容量一直保持在2的n次幂数，就可以使用位运算代替取模运算，提升hash计算效率。 当容量保持为2的n次幂时，每次扩容时位运算计算得出的余数不变，数据存放的索引位置也保持不变。而使用%计算时，结果会因为容量的变化而改变（模运算会产生小数点），每次扩容时数据在数组中存放的位置会发生改变（数据漂移），影响性能。 🦋 减少hash冲突： 将容量保持为偶数进行hash计算时，经过(length-1)后，计算出的索引值为奇数和偶数的概率相同（取决于随机生成的hash值）； 而使用奇数容量进行hash计算时，经过(length-1)后，最终结果均为偶数，这样任何 hash 值都只会被散列到数组的偶数下标位置上，这浪费了近一半的空间。 因此2的n次幂容量、双倍扩容机制可以使容量保持在偶数值，可以使添加的元素在HashMap的数组中均匀分布，减少hash碰撞。 （3）Hash冲突怎么办%%{ init: { 'themeVariables': { 'fontSize': '13px', 'edgeLabelBackground': '#ddebe6' } } }%% graph TD T((\"1. Hash冲突怎么优化\")):::p --> T1(\"hash表里可以存储元素的位置被称为“桶（bucket）”\") T1 --> |\"通常情况\"| A(\"单个“桶”里存储一个元素，此时性能最佳\"):::g A -.-> |\"O(1)\"| a[\"hash算法可以根据hashCode值计算出“桶”的存储位置，接着从“桶”中取出元素。\"] T1 --> |\"哈希冲突的情况\"| B(\"单个桶会存储多个元素（hash值相同）\"):::g B -.-> |\"O(n)\"|b([\"多个元素以 链表 形式存储\"]):::B b --> 2T((\"2. Hash冲突很大怎么优化\")):::p subgraph \"（链表必须按顺序搜索，存取性能差）\" 2T --> C([\"将链表结构转为红黑树\"]):::B C -.- |\"O(logn)\"|c[\"以树的高度为最差查询性能，永远不会出现O(n)的情况。\"]:::info end classDef p fill:#ddaebd classDef g fill:#f4e4e9 classDef B fill:#d9dfeb, stroke:#657eae,stroke-width:2px classDef info fill:#f6f6f7,color:#737379, stroke-width: 2px, stroke-dasharray: 3 3 Hash冲突示意图 %%{ init: { 'themeVariables': { 'clusterBorder': 'none', 'clusterBkg': '#ececee' } } }%% %% 链表超过8时树化成红黑树 graph TD subgraph \"Node[]\" Entry0[\"Node0Node＜K,V>\"] -.- Node1 -.- Node2 -.- Node3 -.- Node4 -.- Node5 -.- Node6 end subgraph 链表 Node1 --> A[Node] --> B[Node] --> C[Node] --> D[Node] --> E[Node] --> F[Node] end subgraph 红黑树 Node4 --> a[Node] a[Node] --> b[Node] b --> b1[Node] b --> b2[Node] a --> c[Node] c --> c1[Node] c --> c2[Node] b1 --> d[Node] b1 --> d2[Node] end style 链表 fill:#ddebe6 style 红黑树 fill:#f4e4e9 （4）内存结构示意图 创建对象，内存结构示意图： Map&lt;String, Integer&gt; countMap = new HashMap&lt;&gt;();countMap.put(&quot;hello&quot;, 1);countMap.put(&quot;world&quot;, 3);countMap.put(&quot;position&quot;, 4); 保存键值对 “hello”的hash值为96207088，模16的结果为0，所以插入table[0]指向的链表头部，内存结构变为： “world”的hash值为111207038，模16结果为14，所以保存完“world”后，内存结构： “position”的hash值为771782464，模16结果也为0, table[0]已经有节点了，新节点会插到链表头部，内存结构变为如图： 2. 使用（1）基本使用Printer.printHashMapStructures(map); // 打印树结构getMapFromStringParam(); （2）如何遍历graph LR T((\"遍历HashMap的5种方法\")):::p T --> A([\"entrySet\"]):::lp T --> B([\"keySet\"]):::lp T --> C([\"forEach\"]):::lp T --> |\"流操作\"|D([\"StreamApi.forEach\"]):::lp T -.-> E([\"values\"]) A -.-> a(\"（1）entrySet\") A -.-> a2(\"（2）entrySet + 迭代器\") B -.-> |\"（效率低）\"| b(\"（3）keySet + get()\") C -.-> c(\"（4）forEach + Lambda\") D -.-> d(\"（5）Stream().forEach（单线程）\") D -.-> d2(\"（6）Stream().forEach（多线程）\") E -.-> e(\"（7）仅遍历value\") classDef p fill:#ddaebd classDef lp fill:#f4e4e9 classDef B fill:#d9dfeb, stroke:#657eae,stroke-width:2px 遍历HashMap代码： package com.equne;import java.util.HashMap;import java.util.Iterator;import java.util.Map;public class Main &#123; /** （1）entrySet */ public static void traverse1(Map&lt;String, String&gt; map) &#123; for (Map.Entry&lt;String, String&gt; entry : map.entrySet())&#123; System.out.println(entry.getKey() + &quot;, &quot; + entry.getValue()); &#125; &#125; /** （2）迭代器（entrySet） */ public static void traverse2(Map&lt;String, String&gt; map) &#123; Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = map.entrySet().iterator(); while (iterator.hasNext())&#123; Map.Entry&lt;String, String&gt; entry = iterator.next(); System.out.println(entry.getKey() + &quot;, &quot; + entry.getValue()); &#125; &#125; /** （3）keySet + get() */ public static void traverse3(Map&lt;String, String&gt; map) &#123; for (String key : map.keySet())&#123; System.out.println(key + &quot;, &quot; + map.get(key)); &#125; &#125; /** （4）forEach + Lambda */ public static void traverse4(Map&lt;String, String&gt; map) &#123; map.forEach((key, value) -&gt; &#123; System.out.println(key + &quot;, &quot; + value); &#125;); &#125; /** （5）StreamApi（单线程） */ public static void traverse5(Map&lt;String, String&gt; map) &#123; map.entrySet().stream().forEach((entry) -&gt; &#123; System.out.println(entry.getKey() + &quot;, &quot; +entry.getValue()); &#125;); &#125; /** （6）StreamApi（多线程） */ public static void traverse6(Map&lt;String, String&gt; map) &#123; map.entrySet().stream().parallel().forEach((entry) -&gt; &#123; System.out.println(entry.getKey() + &quot;, &quot; +entry.getValue()); &#125;); &#125; /** （7）仅遍历value */ public static void traverse7(Map&lt;String, String&gt; map) &#123; for (String v : map.values())&#123; System.out.println(v); &#125; &#125; public static void main(String[] args) &#123; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;key1&quot;, &quot;value1&quot;); map.put(&quot;key2&quot;, &quot;value2&quot;); traverse1(map); traverse2(map); traverse3(map); traverse4(map); traverse5(map); traverse6(map); traverse7(map); &#125;&#125; entrySet 和 keySet Map.entrySet 迭代器会生成 EntryIterator，其返回的实例是一个包含 key/value 键值对的对象。 而 keySet 中迭代器返回的只是 key 对象，还需要到 map 中二次取值（多一个get方法的调用）。故 entrySet 要比 keySet 快一倍左右。（keySet适合仅需要操作key时使用）🔗 摘自：《Java修炼指南：高频源码解析》 foreach + Lambda 表达式（Java8 的新特性） forEach()：用于遍历动态数组中每一个元素并执行特定操作。 Lambda 表达式：箭头符号 -&gt;，其两边连接着输入参数和函数体。 Stream() 其实用Iterable本身的forEach方法即可，没有必要用流式操作。StreamApi适合在对集合进行其他流式操作之后使用。 补充：用流获取映射值的极端案例：Optional&lt;String&gt; value = map .entrySet() .stream() .filter(entry -&gt; entry.getKey().equals(key)) .map(Entry::getValue) // 双冒号：引用方法 .findFirst(); 🔗 摘自：《好代码，坏代码》 . 二、HashMap源码 注：本文源码版本均为：JDK 8 1. 属性// 🔹 常量// 默认的初始容量值（16）- 必须是2的n次幂static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;// 最大容量上限（2的30次方）static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;// 默认的负载因数（0.75）static final float DEFAULT_LOAD_FACTOR = 0.75f;// 树化阈值：当一个桶中的元素个数大于等于8时进行树化static final int TREEIFY_THRESHOLD = 8;// 树降级为链表的仓位计数阈值，当一个桶中的元素个数小于等于6时把树转化为链表。static final int UNTREEIFY_THRESHOLD = 6;// 将table树化的最小容量值（64）：当桶的个数达到64的时候才进行树化（至少应为4*TREEIFY_THRESHOLD，以避免调整大小和树化阈值之间的冲突。）static final int MIN_TREEIFY_CAPACITY = 64;// 🔹 变量// Node数组，又叫作桶（bucket）transient Node&lt;K,V&gt;[] table;// 作为entrySet()的缓存transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;// 元素的数量transient int size;// 记录hashMap的修改次数（每次扩容和更改 map 结构的计数器）transient int modCount;// 扩容阈值 = table.length * loadFactor（当size大于阈值时扩容）int threshold;// 负载因数：表示整体上table被占用的程度final float loadFactor; 2. 构造方法graph LR T((\"HashMap构造方法\")):::p T --> A([\"HashMap map1 = new HashMap();\"]):::lp T --> B([\"HashMap map2 = new HashMap(30);\"]):::lp T --> C([\"HashMap map3 = new HashMap(30, 0.5f);\"]):::lp T --> D([\"HashMap map4 = new HashMap(map);\"]):::lp A --- |\"无参构造方法\"|a(\"不指定容量，默认:16\") B --- |\"initialCapacoty\"| b(\"指定初始化容量：30\") C --- |\"initialCapacotyloadFactor\"| c(\"指定初始化容量、负载因数\") D --- |\"Map map\"| d(\"以指定map构造新map\") D -.- ci(\"* 注意：与上述仅创建空HashMap不同，此方法内部调用了put()存值table才真正进行了初始化。\"):::info classDef p fill:#ddaebd classDef lp fill: #f4e4e9 classDef info fill:#f6f6f7,color:#737379,stroke-dasharray: 3 3, stroke-width: 2px （1）HashMap() 无参数的构造方法/** * Constructs an empty HashMap with the default initial capacity(16) and the default load factor (0.75). * 以默认初始容量(16)和默认负载因数(0.75)，构造一个空的HashMap。 */public HashMap() &#123; // 🔻 将负载因数赋为默认值。 this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted&#125; （2）HashMap(20) 带初始容量的构造方法：/** * Constructs an empty HashMap with the specified initial capacity and the default load factor (0.75). * 以特定的初始容量和默认的负载因数(0.75)，构造一个空的HashMap * * @param initialCapacity 初始容量 * @throws IllegalArgumentException 初始容量为负值时抛出非法数据异常。 */ public HashMap(int initialCapacity) &#123; // 🔻 调用了带初始容量、负载因数的构造方法（详见下文(3)） this(initialCapacity, DEFAULT_LOAD_FACTOR); &#125; （3）HashMap(20, 0.5f) 带初始容量、负载因数的构造方法/** * Constructs an empty HashMap with the specified initial capacity and load factor. * 以特定的初始容量和负载因数构造一个空的HashMap。 * * @param initialCapacity 初始化容量 * @param loadFactor 负载因数 * @throws IllegalArgumentException if the initial capacity is negative * or the load factor is nonpositive * 当初始容量为负值、或负载因数为非正时抛出非法数据异常。 */public HashMap(int initialCapacity, float loadFactor) &#123; // 🔴 一、判断传入参数的合法性 // 🔹 初始容量值非负数 if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity); // 🔹 初始容量值不超过最大容量 if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; // 🔹 负载因数大于0且为数字 if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor); // 🔴 二、为配置参数赋值 // 🔹 为负载因数赋值 this.loadFactor = loadFactor; // 🔹 为扩容阈值赋值：使用tableSizeFor()将给定数值调整为2的次幂数。 this.threshold = tableSizeFor(initialCapacity);&#125; （4）HashMap(map)- HashMap() 带map的构造方法 /** * Constructs a new HashMap with the same mappings as the specified Map. * The HashMap is created with default load factor (0.75) and an initial capacity sufficient to hold the mappings in the specified Map. * 使用与指定Map相同的映射构造新的HashMap。 * 此HashMap由：默认负载因数(0.75)、足够的初始容量（足以存下指定Map）创建。 * * @param m the map whose mappings are to be placed in this map * @参数： m，原map * @throws NullPointerException if the specified map is null * @异常： 当原map为空时抛出空指针异常。 */public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; // 🔻 将负载因数赋为默认值。 this.loadFactor = DEFAULT_LOAD_FACTOR; // 🔻 调用putMapEntries()，将原有map存入新map。 putMapEntries(m, false);&#125; - putMapEntries() 赋值并初始化函数/** * Implements Map.putAll and Map constructor. * 赋值并构造函数。 * * @param m the map * @参数： m，传入的map * @param evict false when initially constructing this map, else true (relayed to method afterNodeInsertion). * @参数： evict，首次创建此map时返回false，非首次创建返回true。 */final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) &#123; int s = m.size(); // m的元素个数 // 🔴 一、若m中有元素，需要根据新Map的初始化情况为其扩容阈值赋值。 （若m无元素则无需赋值，直接使用给定的负载因数和扩容阈值(lf*cap)完成构造。） if (s &gt; 0) &#123; // 🔹 若数组未初始化：根据m中元素数量和负载因数计算新Map的扩容阈值。 if (table == null) &#123; // pre-size // m的扩容阈值 = 元素数量 / 负载因数（🔸+1.0F：对小数做向上取整以尽可能保证更大容量） float ft = ((float)s / loadFactor) + 1.0F; // 将m扩容阈值的数据类型转为整型，并限定在默认容量上限内 int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ? (int)ft : MAXIMUM_CAPACITY); // 若计算出m的扩容阈值 &gt; 新Map扩容阈值，调用tableSizeFor方法，将新Map扩容阈值设置为：该值最接近容量的2次幂数。 if (t &gt; threshold) threshold = tableSizeFor(t); &#125; // 🔹 若数组已初始化、且Map中的元素数量超过了其扩容阈值：扩容。 else if (s &gt; threshold) resize(); // 🔴 二、赋值：遍历m的entry，逐个赋值到新Map上。 for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123; K key = e.getKey(); V value = e.getValue(); // 🔹 调用putVal()为每个节点赋值（此时新Map才真正初始化完成） putVal(hash(key), key, value, false, evict); &#125; &#125;&#125; ((float)s / loadFactor) + 1.0F + 1.0F：为了让浮点数进行除法计算后向上取整，以尽可能保证足够容量。 3. 静态实用程序- hash() 计算key.hashCode()/* ---------------- Static utilities -------------- *//** * Computes key.hashCode() and spreads (XORs) higher bits of hash to lower. * 计算key.hashCode()并将哈希的高位扩展（异或运算）到低位。 */static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; (h=key.hashCode()) ^ (h &gt;&gt;&gt;16) hash(Object) 方法通过以上表达式得到指定对象的Hash值。这里是取得当前对象的Hash值，首先进行带符号位的右移16位操作（这时候对象Hash值的高位段就变成了低位段），然后与对象原来的Hash值进行异或运算。 异或的原因： 因为数组容量总是2的n次幂数，计算索引位置时，散列真正生效的只是低nbit的有效位，很容易发生碰撞。因此，把高16bit和低16bit异或一下，既减少了系统的开销，也不会造成因为高位没有参与下标的计算(table长度比较小)时，引起碰撞。 - tableSizeFor() 返回最接近给定目标容量的二次幂数值/** * Returns a power of two size for the given target capacity. * 返回给定目标容量的二次幂数。 */static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125;/* 以下为备注： ------------------------------------------------- * 该位运算用于求出高位1之后每位都为1的结果。 因为将每位变为1，则加上1后刚好是一个二次幂数。 如(0000 1000)，使其第一位1后面都为1，即(0000 1111) ------------------------------------------------- */ // 如，initialCapacity = 9 // 🔴 将 n - 1 int n = cap -1; // n = 8 // 🔴 作位运算：1. 无符号位移 2. 与n作或的位运算。 n |= n &gt;&gt;&gt; 1; n = 0000 1000 n = 0000 0100 n = 0000 1100 n |= n &gt;&gt;&gt; 2; n = 0000 1100 n = 0000 0011 n = 0000 1111 // =15 n |= n &gt;&gt;&gt; 4; n = 0000 1111 n = 0000 0000 n = 0000 1111 n |= n &gt;&gt;&gt; 8; n = 0000 1111 n = 0000 0000 n = 0000 1111 n |= n &gt;&gt;&gt; 16; // 🔸 因为int是32位的，所以执行到16即可. // 🔴 返回位移结果n + 1 return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUN_CAPACITY : n + 1; n &lt; 0, 则返回 n = 1 n &gt;= 0, 且 n &gt;= 最大容量, 则返回最大容量 n &gt;= 0, 且 n &lt; 最大容量, 则返回 n + 1 （=16） 为什么先进行n-1操作：为了处理n刚好是二次幂数的情况。 🦋 若n已经是2的n次幂了，按照逻辑变1之后再加1，结果就会变成n的2倍了，与应有的结果不一致。如，n=16（0001 0000），位运算后 n=31（0001 1111）。 - Comparable /** * Returns x&#x27;s Class if it is of the form &quot;class C implements * Comparable&lt;C&gt;&quot;, else null. */static Class&lt;?&gt; comparableClassFor(Object x) &#123; if (x instanceof Comparable) &#123; Class&lt;?&gt; c; Type[] ts, as; Type t; ParameterizedType p; if ((c = x.getClass()) == String.class) // bypass checks return c; if ((ts = c.getGenericInterfaces()) != null) &#123; for (int i = 0; i &lt; ts.length; ++i) &#123; if (((t = ts[i]) instanceof ParameterizedType) &amp;&amp; ((p = (ParameterizedType)t).getRawType() == Comparable.class) &amp;&amp; (as = p.getActualTypeArguments()) != null &amp;&amp; as.length == 1 &amp;&amp; as[0] == c) // type arg is c return c; &#125; &#125; &#125; return null;&#125;/** * Returns k.compareTo(x) if x matches kc (k&#x27;s screened comparable * class), else 0. */@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) // for cast to Comparablestatic int compareComparables(Class&lt;?&gt; kc, Object k, Object x) &#123; return (x == null || x.getClass() != kc ? 0 : ((Comparable)k).compareTo(x));&#125; 4. 实现方法（1）Get() - 获取%%{ init: { 'themeVariables': { 'fontSize': '13px' } } }%% graph TD T([\"如何从HashMap获取元素？\"]):::p T --> B(\"先根据key找到桶位\") B --> A([\"判断当前位置的元素是否就要找的值\"]):::lp A --> |\"是\"| C2[\"核对k-v值后返回\"]:::b A --> |\"否（有hash冲突）\"| C([\"判断为链表或红黑树\"]):::lp C -.-> |\"链表\"|a[\"遍历链表、核对k-v值后返回\"]:::b C -.-> |\"红黑树\"|b[\"从树的根节点查找、核对k-v值后返回\"]:::b classDef p fill:#ddaebd classDef b fill:#d9dfeb classDef lp fill: #f4e4e9 - get() 通过key获取value/** * Returns the value to which the specified key is mapped, * or null if this map contains no mapping for the key. * 返回指定key所映射的value值。若找不到对应value时返回null。 * * 但返回null不一定代表不存在该key映射的值，有可能是该key保存的value值正是&quot;null&quot;。 * 可以使用containsKey()来识别。 */public V get(Object key) &#123; // Node Node&lt;K,V&gt; e; // 🔻 使用key和其hash值调用getNode()方法，返回Node的value值。 return (e = getNode(hash(key), key)) == null ? null : e.value;&#125; null ? null : e.value：若该值为null，返回null；若该值不为null，返回e.value - getNode() 获取Node/** * Implements Map.get and related methods. * 实现了Map.get()和相关方法 * * @param hash key的hash值 * @param key key * @return 返回该key对应的Node，若无返回null */final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; // Node数组 Node&lt;K,V&gt; first, e; // Node int n; // 数组长度 K k; // key // 🔻 判断该数组非空 // 并根据传入key的hash值计算出该hash值对应的Node的下标，将该数组下标对应的值赋值给first-Node（意为hash冲突时第一个节点） if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; // 🔹 先判断若first刚好是我们要找的Node时：直接返回first if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; // 🔹 当first尾部还有元素（即有hash冲突）时，根据Node的结构取值。 if ((e = first.next) != null) &#123; // 🔸 红黑树：将Node转为TreeNode类型，并调用getTreeNode()取值。 if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); // 🔸 链表：遍历取值。 do &#123; if (e.hash == hash &amp;&amp; // 判断hash值和key值都相同 ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; // 🔻 数组为空，返回null return null;&#125; （2）Remove() - 删除%%{ init: { 'themeVariables': { 'fontSize': '13px' } } }%% graph TD T([\"如何从HashMap删除元素？\"]):::p T --> B(\"先根据key找到桶位\") B --> A([\"判断当前位置的元素是否就要删除的值\"]):::lp A --> |\"是\"| C2[\"直接删除该元素\"]:::b A --> |\"否（有hash冲突）\"| C([\"判断为链表或红黑树\"]):::lp C --> |\"链表\"|a[\"将上个位置的指针（跳过该值）指向下个位置\"]:::b C --> |\"红黑树\"|b[\"去掉当前节点后自平衡\"]:::b b -.- bt[\"（树长度小于6时转为链表）\"]:::info classDef info fill:#f6f6f7,color:#737379stroke-width: 3px, stroke-dasharray: 3 3 classDef p fill:#ddaebd classDef b fill:#d9dfeb classDef lp fill: #f4e4e9 - remove() 删除元素 /** * Removes the mapping for the specified key from this map if present. * 根据指定key删除映射。 * * @param key 要从map中删除映射的键 * @return 返回与键关联的前值，若前值为空返回null */public V remove(Object key) &#123; Node&lt;K,V&gt; e; // 🔻 调用removeNode()删除该键映射，若前值为空返回null，若前值非空返回前值。 return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value;&#125; - removeNode() 删除Node /** * Implements Map.remove and related methods. * 实现删除和相关方法。 * * @param hash key的hash值 * @param key key * @param value 若有值时匹配该值 * @param matchValue 若为真：仅值相等时删除 * @param movable 为false:删除时不移动其他值 * @return 返回Node，若无该Node返回null */final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) &#123; Node&lt;K,V&gt;[] tab; // Node数组（引用当前hashMap的散列表） Node&lt;K,V&gt; p; // 当前Node元素：p int n, index; // n：数组长度，index：数组下标 // 数组非空、当前索引位置的Node元素p非空 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) &#123; Node&lt;K,V&gt; node = null, e; // 要删除的Node元素：node；当前节点的下个节点：e(=p.next) K k; V v; // 当前元素p的key和value值 // 🔹 第一个位置刚好是要删除的元素：赋值给node，执行下方修改指针的代码 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) node = p; // 🔹 存在哈希冲突时：根据链表或红黑树结构获取要删除的元素node else if ((e = p.next) != null) &#123; // 🔸 红黑树：使用getTreeNode()获取元素，赋值给node。 if (p instanceof TreeNode) node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key); // 🔸 链表：用hash值和键值对遍历：赋值给node。 else &#123; do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; node = e; break; &#125; p = e; &#125; while ((e = e.next) != null); &#125; &#125; // 🔴 根据元素(node)的结构删除 if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) &#123; // 🔹 若要删除树结构节点：使用removeTreeNode()移除树节点 if (node instanceof TreeNode) ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable); // 🔹 若要删除Node节点上的元素（刚好是第一个元素）：将该节点赋值为下个元素 else if (node == p) tab[index] = node.next; // 🔹 若要删除链表节点：指向其下个元素的next，将链表链接起来。 else p.next = node.next; ++modCount; // 记录修改次数（可以判断是否修改成功） --size; // 数组长度自减 afterNodeRemoval(node); return node; &#125; &#125; return null;&#125; （3）Put() - 添加%%{ init: { 'themeVariables': { 'fontSize': '13px' } } }%% graph TD T([\"如何向HashMap添加元素？\"]):::p T --> B(\"先根据key找到桶位\") B --> A([\"判断当前索引是否就是要添加元素的位置\"]):::lp A --> |\"无元素\"| C2[\"直接将元素添加到该位置\"]:::b A --> |\"有元素（有hash冲突）\"| C([\"判断为链表或红黑树\"]):::lp C --> |\"链表\"|a[\"将元素添加到链表尾部\"]:::b C --> |\"红黑树\"|b[\"将元素添加到树尾部\"]:::b a -.- at[\"链表长度超过8、且桶数量大于64时转为树（*桶数小于64时不会树化，只会扩容）\"]:::info classDef info fill:#f6f6f7,color:#737379stroke-width: 3px, stroke-dasharray: 3 3 classDef p fill:#ddaebd classDef b fill:#d9dfeb classDef lp fill: #f4e4e9 + put() 添加元素/** * Associates the specified value with the specified key in this map. If the map previously contained a mapping for the key, the old value is replaced. * 存值：将指定值与此映射中的指定键相关联。如果映射先前包含键的映射，则将替换旧值。 * * @param key * @param value * @return 返回被替换的原值 */public V put(K key, V value) &#123; // 调用putVal()方法存值 return putVal(hash(key), key, value, false, true);&#125; - putVal() 赋值方法（若key已有值时默认替换）/** * Implements Map.put and related methods. * 实现了Map赋值以及相关方法。 * * @param hash key的hash值 * @param key key值 * @param value 需要赋的值 * @param onlyIfAbsent 是否保留原值（默认为false：会替换原值） * @param evict false:表处于创建状态 * @return 返回前值，如果没有则为空 */final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; // Node数组 Node&lt;K,V&gt; p; // Node int n, i; // n：数组长度， i：数组索引 // 🔴 一、若空数组：初始化 // 当数组为空、长度为0时：扩容，并获得Node数组长度n（容量） if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 🔴 二、若空索引：直接存 // 若传入的key计算出的索引位置无元素，则使用键值对在该位置上创建Node，putVal()完成。 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); // 🔴 三、若索引非空：根据情况存值 // 可能有hash冲突，判断该Node是否为链表或红黑树进行存值。 else &#123; Node&lt;K,V&gt; e; // node K k; // key // 🔹 若p刚好在当前索引位置的第一个节点上（未涉及到链表或红黑树），将该Node赋值给e以备存值（当前Node的key值和传入的key值相等） if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // 🔹 TreeNode类型：通过putTreeVal()方法在红黑树上插入键值对，赋值给e以备存值。 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 🔹 链表类型：循环直到将元素插入链表尾部，赋值给e以备存值。 else &#123; for (int binCount = 0; ; ++binCount) &#123; // binCount：链表节点个数 // 🔸 若已遍历到链表尾部：使用newNode()在尾部再添加一个新节点并存值。 if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); // * 若添加节点后链表的长度超过树化阈值： // 通过treeifyBin()将链表转化为红黑树，跳出循环，putVal()完成。 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; // 🔸 若还未遍历到尾部、且该节点的key值与传入key值相等： // 则跳出循环，执行下方替换原值的判断。 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; // 🔸 继续循环遍历链表 p = e; &#125; &#125; // 🔻 替换并输出原值（key已有值时） if (e != null) &#123; // existing mapping for key V oldValue = e.value; // 若设置了替换原值、或原值为空时：存值 if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); // 访问后回调（❓ return oldValue; &#125; &#125; ++modCount; // 记录修改次数（方便在迭代中检测结构性变化） // 🔻 若存值后元素数量大于扩容阈值，则扩容。 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); // 插入后回调（❓ return null;&#125; 比较时先比较hash值，hash相同的时候，再使用equals方法进行比较：if(e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) 因为hash是整数，比较的性能一般要比equals()高很多，使用短路与：hash不同，就没有必要调用equals方法了，这样整体上可以提高比较性能。 + putIfAbsent() 赋值，且已有值时不进行覆盖@Overridepublic V putIfAbsent(K key, V value) &#123; // 🔻 与默认的put()区别在于第四个参数：onlyIfAbsent（为true时不覆盖原值） return putVal(hash(key), key, value, true, true);&#125; （4）*Resize() - 扩容① 何时扩容%%{ init: { 'themeVariables': { 'fontSize': '14px' } } }%% graph TD T([\"HashMap何时需要扩容？\"]):::p T --> |\"1. 初始化\"| A(\"1. table为null 或长度为0时\"):::lp T --> |\"2. 存值\"| B(\"2. 添加元素且元素数量即将超过扩容阈值（threshold）时\"):::lp B -.- |\"hreshold 可以由 tableSizeFor() 计算得到\"| b[\"tableSizeFor()：可以计算出大于当前方法入参值，并且和当前方法入参值最接近的2的幂数。\"]:::info classDef p fill: #ddaebd classDef lp fill: #f4e4e9 classDef lb fill: #d9dfeb classDef info fill:#f6f6f7,color:#737379, stroke-width: 2px, stroke-dasharray: 3 3 ② 如何扩容 %%{ init: { 'themeVariables': { 'fontSize': '14px' } } }%% graph TD T([\"HashMap如何扩容？\"]):::p T --> A(\"2倍扩容，创建新数组\") A --> B(\"移动元素到新数组（重新计算hash）\") B --> b([\"判断元素类型调整位置\"]):::lp b -.-|\"单个值\"| b1[\"①原位置② 原位置 + 原容量\"]:::lb b -.-|\"红黑树\"| b2[\"split()分割树①一棵：原位置②另一棵：原位置 + 原容量\"]:::lb b -.-|\"链表\"| b3[\"①低位链表：原位置②高位链表：原位置 + 原容量\"]:::lb b2 -.- b2t[\"若树节点数量≤6：转链表\"]:::info classDef p fill: #ddaebd classDef lp fill: #f4e4e9 classDef lb fill: #d9dfeb classDef info fill:#f6f6f7,color:#737379, stroke-width: 2px, stroke-dasharray: 3 3 调整位置的原因： 因为HashMap计算索引位置是根据hash值 &amp; (当前容量 -1)，因此当容量改变时，一些原本的索引位置也会发生改变。扩容的同时重新调整元素位置，取值时才能正确匹配到相应的键值对。 ③ 如何调整位置 元素位置如何改变？ %%{ init: { 'themeVariables': { 'fontSize': '14px' } } }%% graph TD T([\"元素位置如何改变？\"]):::p T --> A(\"hash值 & 原长度\"):::lb A --> a[\"结果为0，位置不变\"]:::lp A --> b[\"结果为1，在新位置\"]:::lp a -.- at[\"如，原hash值=3（原位置=3），数组长度16， hash & 16： 0000 0011 // 3 0001 0000 // 16 0000 0000 // =0则，新位置 = 原位置 = 3\"]:::info b -.- bt[\"如，原hash值=19（原位置=3），数组长度16，hash & 16： 0001 0011 // 19 0001 0000 // 16 0001 0000 // =1则，新位置 = 原位置 + 原容量 = 19\"]:::info classDef p fill: #ddaebd classDef lp fill: #f4e4e9 classDef lb fill: #d9dfeb classDef info fill:#f6f6f7,color:#737379, stroke-width: 2px, stroke-dasharray: 3 3 满足“(e.hash &amp; oldCap)==0”条件的节点可以继续在原索引位上存储，不满足该条件的节点则需要进行移动操作。 HashMap中，table数组都是以2的幂数进行扩容操作的，就是将原容量值左移1位。 因此进行扩容操作后，各个K-V键值对节点是否仍能在原索引位上，取决于新增的一位（oldCap的值）在进行与运算时是否为0。 链表元素移动： 满足“(e.hash &amp; oldCap)==0”条件的节点会构成新的单向链表，这个链表中的节点会按照原索引位顺序存储于新的HashMap集合的table数组中； 满足“(e.hash &amp;oldCap) !=0”条件的节点会构成另一个新的单向链表，并且将原索引值+原数组长度的计算结果作为新的索引值存储于新的HashMap集合的table数组中。 红黑树元素移动： 将这棵红黑树拆分成两棵新的红黑树：（若红黑树中节点数≤6，会将树结构转为链表结构）① 一棵红黑树（或链表）留在原索引位上，② 另一棵红黑树（或链表）放到原索引值+原数组容量值计算结果对应的新索引位上。 - resize() 扩容/** * Initializes or doubles table size. If null, allocates in accord with initial capacity target held in field threshold. * Otherwise, because we are using power-of-two expansion, the elements from each bin must either stay at same index, or move with a power of two offset in the new table. * 初始化或二倍扩容。若为空，根据阈值和初始容量分配。 * 由于使用2次幂扩容，因此每个元素保持相同索引，或在新表中以二次幂偏移量移动。 * * @return table*/final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; // 原table int oldCap = (oldTab == null) ? 0 : oldTab.length; // 扩容前的table长度，若无元素返回0 int oldThr = threshold; // 原阈值 int newCap, newThr = 0; // 新长度、新阈值 // 🔴 一、设置扩容阈值 // 🔹 ① 若已初始化(原数组有元素)：检查数组长度并设置2倍扩容阈值。 if (oldCap &gt; 0) &#123; // 🔸 若原数组长度超过最大容量值：—&gt; 已到达容量上值，无法再扩容，返回原表。 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; // 🔸 若原数组长度2倍扩容后仍未超过容量上限，且原数组长度超过了默认初始容量：—&gt; 原扩容阈值设置为2倍。 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; // 🔹 ② 若未初始化(原数组无元素)，但已设置过扩容阈值(&gt;0) ：将新数组长度设置为该扩容阈值。 else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; // 🔹 ③ 若未初始化(原数组无元素)，且未设置过扩容阈值：使用系统设置的默认数组长度和默认阈值赋值。 else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; // 🔴 二、检查扩容阈值 // 若新扩容阈值仍为0：使用新数组长度计算新的扩容阈值（并将数组长度限制在最大容量上限内） if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; // 设置扩容阈值 threshold = newThr; // 🔴 三、扩容 @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) // 🔹 新建数组 Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; // 使用新的数组长度创建新数组 table = newTab; // 🔹 移动元素到新数组 // - 若原数组为空，无需移动，直接返回该数组。 // - 若原数组非空：移动数据到新数组。 if (oldTab != null) &#123; // 🔸 外层循环：遍历原数组元素 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; // 清空原值，便于GC回收。 oldTab[j] = null; // ① 单个值 if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; // 原位 或 +旧容量oldCap // ② 红黑树：分割 else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); // ③ 链表： else &#123; // preserve order // 低位链表：位置不变 Node&lt;K,V&gt; loHead = null, loTail = null; // 高位链表：位置 + 容量 Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; // 🔸 内层循环：计算新节点的索引位置。 do &#123; next = e.next; // true：位置不变（低位链表） if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; // false：位置 + 容量（高位链表） else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); // 低位链表赋值 if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; // 高位链表赋值 if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; // 🔹 返回新数组 return newTab;&#125; 5. 内部类（1）Node HashMap.Node类： /** * Basic hash bin node, used for most entries. (See below for TreeNode subclass, and in LinkedHashMap for its Entry subclass.) * 基本hash的bin节点，用于大部分节点。（TreeNode子类见下文，Entry子类见LinkedHashMap。） */static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; // final：由于key是计算元素排列位置的依据，因此一旦初始化就不允许改变。 V value; Node&lt;K,V&gt; next; // 下一个节点（因为需要用Node节点构建单向链表） Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + &quot;=&quot; + value; &#125; // 🔻 重写hashCode()：将key的Hash值、value的Hash值进行异或运算。 public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; // 🔻 重写equals() public final boolean equals(Object o) &#123; // 🔹 ① 判断两个节点的内存起始地址相同 if (o == this) return true; // 🔹 ② 判断两个Map类型节点的key和value值都相等 if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125;&#125; 重写HashCode() Java官方对重写对象的 hashCode() 方法有严格的要求 —— 若重写 hashCode() 方法，则需要重写相应的 equals() 方法。 补充：Objects工具类 graph LR T([\"Objects工具类\"]):::p T --> A(\"提供了进行对象比较、检验的基本操作\"):::lb A --> 1([\"compare(T, S, Comparator)\"]):::lp A --> 2([\"hashCode(Object)\"]):::lp A --> 3([\"hashCode(Object[])\"]):::lp A --> 4(\"isNull(Object)、nonNull(Object)、requireNonNull(Object)等\"):::lp A --> 5([\"toString(Object)\"]):::lp 1 -.- 1t[\"两个对象的比较操作\"] 2 -.- 2t[\"计算对象Hash值\"] 3 -.- 3t[\"计算多个对象的Hash值组合\"] 4 -.- 4t[\"校验或确认当前对象是否为空\"] 5 -.- 5t[\"返回对象的字符串信息\"] classDef p fill: #ddaebd classDef lp fill: #f4e4e9 classDef lb fill: #d9dfeb 根据哈希值存取对象、比较对象是计算机程序中一种重要的思维方式。 它使得存取对象主要依赖于自身Hash值，而不是与其他对象进行比较，存取效率也与集合大小无关，高达O(1)，即使进行比较，也利用Hash值提高比较性能。 （2）TreeNode TreeNode 继承自 LinkedHashMap.Entry 类。 HashMap集合使用 HashMap.TreeNode 类的对象表示红黑树中的节点，来构成红黑树。 ① 当某个索引位上的链表长度达到指定的阈值（默认为单向链表长度超过8）时，单向链表会转化为红黑树；② 当红黑树中的节点足够少（默认为红黑树中的节点数量少于6个）时，红黑树会转换为单向链表。 - 属性static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123; // 父节点 TreeNode&lt;K,V&gt; parent; // red-black tree links // 左节点 TreeNode&lt;K,V&gt; left; // 右节点 TreeNode&lt;K,V&gt; right; // 前节点：删除时需要取消链接&quot;next&quot; TreeNode&lt;K,V&gt; prev; // needed to unlink next upon deletion // 节点颜色：true红色；false黑色 boolean red; // 构造方法，参数：hash值、key、value、下一个Node节点 TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) &#123; super(hash, key, val, next); &#125; // ... // 还有构建红黑树、解构红黑树、添加节点、移除节点等方法&#125; - getTreeNode() 获取红黑树节点 /** * Calls find for root node. * 调用查找根节点 */final TreeNode&lt;K,V&gt; getTreeNode(int h, Object k) &#123; // 🔻 调用find()查找节点 return ((parent != null) ? root() : this).find(h, k, null); // 若根节点不为空，调用root节点查找；若根节点为空，使用this查找。&#125; - find() 查找树节点 /** * Finds the node starting at root p with the given hash and key. The kc argument caches comparableClassFor(key) upon first use comparing keys. * 使用给定的key和hash值查找从根p开始的节点。 */final TreeNode&lt;K,V&gt; find(int h, Object k, Class&lt;?&gt; kc) &#123; TreeNode&lt;K,V&gt; p = this; // 当前树形Node：p // 遍历整树： do &#123; int ph, dir; K pk; TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q; // 当前Node左节点、右节点、 // 若当前节点hash值较大：p取其左节点 if ((ph = p.hash) &gt; h) p = pl; // 若当前节点hash值较小：p取其右节点 else if (ph &lt; h) p = pr; // 若当前节点key值等于给定key值，返回当前节点 else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk))) return p; // 若左节点为空，p取其右节点 else if (pl == null) p = pr; // 若右节点为空，p取其左节点 else if (pr == null) p = pl; // 根据compareTo比较 else if ((kc != null || (kc = comparableClassFor(k)) != null) &amp;&amp; (dir = compareComparables(kc, k, pk)) != 0) p = (dir &lt; 0) ? pl : pr; // 根据compareTo的结果，若右节点能找到：返回右节点 else if ((q = pr.find(h, k, kc)) != null) return q; // 若compareTo的结果在左节点上：继续查找 else p = pl; &#125; while (p != null); return null;&#125; - split() 分割树结构（HashMap扩容时使用到的方法）/** * Splits nodes in a tree bin into lower and upper tree bins, or untreeifies if now too small. Called only from resize; see above discussion about split bits and indices. * 分割该树为两棵树，若树太小则链化。 * * @param map * @param tab table * @param index 被分割树的索引位置 * @param bit 扩容前的原数组容量 */final void split(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int index, int bit) &#123; TreeNode&lt;K,V&gt; b = this; // 当前树节点 // Relink into lo and hi lists, preserving order TreeNode&lt;K,V&gt; loHead = null, loTail = null; TreeNode&lt;K,V&gt; hiHead = null, hiTail = null; int lc = 0, hc = 0; // 遍历时计算链表的长度 // 🔴 一、重新计算索引位置（遍历双向链表结构） for (TreeNode&lt;K,V&gt; e = b, next; e != null; e = next) &#123; // 🔻 拆分：割断当前节点的next引用。 next = (TreeNode&lt;K,V&gt;)e.next; e.next = null; // 🔹 原位置： if ((e.hash &amp; bit) == 0) &#123; // 无需移动元素即可组成新链表： if ((e.prev = loTail) == null) loHead = e; else loTail.next = e; loTail = e; ++lc; // 记录链表长度 &#125; // 🔹 新位置： else &#123; if ((e.prev = hiTail) == null) hiHead = e; else hiTail.next = e; hiTail = e; ++hc; // 记录长度 &#125; &#125; // 🔴 二、移动元素（将两个新链表树化或取消树化） // 🔹 0：原位置 if (loHead != null) &#123; // 🔸 若节点≤树化阈值：取消树化，转为链表 if (lc &lt;= UNTREEIFY_THRESHOLD) tab[index] = loHead.untreeify(map); // 🔸 若节点≥树化阈值：树化 else &#123; // 将链表存入table索引位置 tab[index] = loHead; // 确认链表存在元素后树化 if (hiHead != null) // (else is already treeified) loHead.treeify(tab); &#125; &#125; // 🔹 1：新位置（原位置 + 原容量）：同上 if (hiHead != null) &#123; if (hc &lt;= UNTREEIFY_THRESHOLD) tab[index + bit] = hiHead.untreeify(map); else &#123; tab[index + bit] = hiHead; if (loHead != null) hiHead.treeify(tab); &#125; &#125;&#125; 🦋 红黑树中隐含的双向链表结构： ① 在将红黑树结构转换为链表结构的过程中，需要使用这个隐含的双向链表进行遍历； ② 在红黑树结构的拆分过程中，也需要使用这个隐含的双向链表进行遍历。 （3）Iterators- nextNode() HashMap实现了Iterator(迭代器)接口。 abstract class HashIterator &#123; Node&lt;K,V&gt; next; // 将返回的下个entry Node&lt;K,V&gt; current; // 当前 entry int expectedModCount; // 用于快速失败的属性 int index; // 当前索引 HashIterator() &#123; expectedModCount = modCount; Node&lt;K,V&gt;[] t = table; current = next = null; index = 0; if (t != null &amp;&amp; size &gt; 0) &#123; // advance to first entry do &#123;&#125; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null); &#125; &#125; final Node&lt;K,V&gt; nextNode() &#123; Node&lt;K,V&gt;[] t; Node&lt;K,V&gt; e = next; // 若modCount不等于expectedModCount：抛出异常 if (modCount != expectedModCount) throw new ConcurrentModificationException(); // 若指定Node为空：抛出异常 if (e == null) throw new NoSuchElementException(); // 若next指向的Node（即当前Node的next的值）不为空，且数组不为空： if ((next = (current = e).next) == null &amp;&amp; (t = table) != null) &#123; // 限定索引不超出长度、且下个位置仍有元素。 do &#123;&#125; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null); &#125; return e; &#125; // ... // EntryIterator，继承自HashIterator final class EntryIterator extends HashIterator implements Iterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123; public final Map.Entry&lt;K,V&gt; next() &#123; return nextNode(); &#125; &#125;&#125; 遍历元素时使用modCount属性判断HashMap是否发生结构性变化 🔹 属性：- modCount：HashMap类中的一个成员变量，表示对HashMap的修改次数。（与ArrayList和LinkedList相同）- expectedModCount：表示对hashMap修改次数的期望值，它的初始值为modCount。- ConcurrentModificationException()异常：此异常为了防止在使用Iterator遍历容器的同时又对容器作增加或删除操作，或者使用多线程操作。 🔹 说明：HashMap的Iterator是fail-fast迭代器。每次发生结构性变化时modCount都会增加，而每次迭代器操作时都会检查expectedModCount是否与modCount相同，这样就能检测出结构性变化。当有其他线程改变了HashMap的结构（增加、删除、修改元素），将会抛出ConcurrentModificationExceptidon。 🔹 解决方法：在遍历的过程中把需要删除的对象保存到一个集合中，等遍历结束后再调用removeAll方法来删除，或者通过Iterator的remove()方法移除元素。 参考： HashMap扩容部分：《Java高并发与集合框架：JCF和JUC源码分析与实现》 内存结构示意图部分：《Java编程的逻辑》","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://equnee.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://equnee.github.io/tags/Java/"},{"name":"HashMap","slug":"HashMap","permalink":"https://equnee.github.io/tags/HashMap/"}]},{"title":"🌷《秒懂设计模式》—— 责任链模式","slug":"note/Design-pattern/design-pattern_Chain_of_Responsibility","date":"2023-03-08T15:14:10.467Z","updated":"2023-05-04T09:26:08.332Z","comments":true,"path":"note/Design-pattern/design-pattern_Chain_of_Responsibility/","link":"","permalink":"https://equnee.github.io/note/Design-pattern/design-pattern_Chain_of_Responsibility/","excerpt":"","text":"笔记来自《秒懂设计模式》 %%{ init: { 'themeVariables': { 'fontSize': '13px' } } }%% graph LR T([\"责任链介绍\"]):::p T --> A([\"责任链\"]):::g T --> B([\"责任链模式\"]):::p T --> C([\"业务责任链\"]):::b A -.-> a(\"责任链是由很多责任节点串联起来的一条任务链条，其中每一个责任节点都是一个业务处理环节。\"):::lg B -.-> b(\"责任链模式(Chain of Responsibility) 允许业务请求者将责任链视为一个整体并对其发起请求，而不必关心链条内部具体的业务逻辑与流程走向。\"):::lp B -.-> b2(\"请求者不必关心具体是哪个节点起了作用，总之业务最终能得到相应的处理。\"):::info C -.->c(\"在软件系统中，当一个业务需要经历一系列业务对象去处理时，我们可以把这些业务对象串联起来成为一条业务责任链，请求者可以直接通过访问业务责任链来完成业务的处理，最终实现请求者与响应者的解耦。\"):::lb classDef p fill:#ddaebd classDef g fill:#9ac5bb classDef b fill:#aab7d2 classDef lp fill:#f4e4e9 classDef lg fill:#ddebe6 classDef lb fill:#d9dfeb classDef info fill:#f6f6f7,color:#737379,stroke-dasharray: 3 3, stroke-width: 2px 一、简单的生产线 最简单的责任链模式例子：汽车生产线的制造流程。 %%{ init: { 'themeVariables': { 'fontSize': '14px' } } }%% graph LR T([\"汽车生产线的制造流程\"]):::p T --- A(\"劳动分工\"):::lp T --- B(\"架构生产线\"):::lp a --> C(\"最终 通过生产线的传递，汽车便从零件到成品得以量产，生产效率大大提升\"):::B b --> C A -.- a(\"将汽车零件的安装工作拆分并分配给各安装节点\") B -.-b(\"将安装节点组织起来，首尾相接，规划操作流程\") classDef p fill:#ddaebd classDef lp fill:#f4e4e9 classDef B fill:#d9dfeb, stroke:#657eae,stroke-width:2px classDef lb fill: #d9dfeb classDef info fill:#f6f6f7,color:#737379, stroke-width: 2px, stroke-dasharray: 3 3 我们将汽车生产线从左至右分为3个功能节点：这样将产品逐级传递，每经过一个节点就完成一部分工作，最终完成产品交付。 %%{ init: { 'themeVariables': { 'fontSize': '12px' } } }%% graph LR T([\"汽车生产线节点\"]):::p T --> A(\"A节点\"):::lp T --> B(\"B节点\"):::lp T --> C(\"C节点\"):::lp A -.- a[\"负责组装车架、安装车轮\"] B -.- b[\"负责安装发动机、油箱、传动轴等内部机件\"] C -.- c[\"负责组装外壳、喷漆等操作\"] classDef p fill:#ddaebd classDef lp fill:#f4e4e9 classDef B fill:#d9dfeb, stroke:#657eae,stroke-width:2px classDef lb fill: #d9dfeb classDef info fill:#f6f6f7,color:#737379, stroke-width: 2px, stroke-dasharray: 3 3 二、工作流程拆分 带有一些逻辑的责任链：报销审批流程。 审批流程按负责人或者工作职责进行拆分：需要依次通过财务专员、财务经理、财务总监的审批。如果申请金额在审批人的审批职权范围内则审批通过并终止流程，反之则会升级至更高层级的上级去继续审批，直至最终的财务总监，如果仍旧超出财务总监的审批金额则驳回申请，流程终止。 如何设计这个审批流程：首先按角色对业务进行拆分，将不同的业务代码放在不同的角色类中，如此达到职权分拆的目的，可扩展性、可维护性也能得到提高。 . 三、踢皮球1. 实例 基于上述审批流程，来做一个简单的实例：假设某公司的报销审批流程有3个审批角色%%{ init: { 'themeVariables': { 'fontSize': '12px' } } }%% %% 假设某公司的报销审批流程有3个审批角色 graph LR T([\"报销审批流程（3个角色）\"]):::p T --> A(\"财务专员\"):::lp T --> B(\"财务经理\"):::lp T --> C(\"财务总监\"):::lp A -.- a[\"1000元审批权限\"] B -.- b[\"5000元审批权限\"] C -.- c[\"10000元审批权限\"] classDef p fill:#ddaebd classDef lp fill:#f4e4e9 classDef B fill:#d9dfeb, stroke:#657eae,stroke-width:2px classDef lb fill: #d9dfeb classDef info fill:#f6f6f7,color:#737379, stroke-width: 2px, stroke-dasharray: 3 3 2. 代码 Staff /** * 财务专员类 */public class Staff &#123; private String name; public Staff(String name)&#123; this.name = name; &#125; public boolean approve(int amount) &#123; if (amount &lt;= 1000) &#123; System.out.println(&quot;审批通过。【专员：&quot; + name + &quot;】&quot;); return true; &#125; else &#123; System.out.println(&quot;无权审批，请找上级。【专员：&quot; + name + &quot;】&quot;); return false; &#125; &#125;&#125; Manager /** * 财务经理类 */public class Manager &#123; private String name; public Manager(String name)&#123; this.name = name; &#125; public boolean approve(int amount) &#123; if (amount &lt;= 5000) &#123; System.out.println(&quot;审批通过。【经理：&quot; + name + &quot;】&quot;); return true; &#125; else &#123; System.out.println(&quot;无权审批，请找上级。【经理：&quot; + name + &quot;】&quot;); return false; &#125; &#125;&#125; CFO /** * 财务总监类 */public class CFO &#123; private String name; public Manager(String name)&#123; this.name = name; &#125; /* 定义了财务总监类CFO的审批方法approve()并接受要审批的金额， 如果金额在10000元以内则审批通过，否则驳回此申请。 */ public boolean approve(int amount) &#123; if (amount &lt;= 10000) &#123; System.out.println(&quot;审批通过。【总监：&quot; + name + &quot;】&quot;); return true; &#125; else &#123; System.out.println(&quot;驳回申请。【总监：&quot; + name + &quot;】&quot;); return false; &#125; &#125;&#125; 3个审批角色的代码都比较类似，只要超过其审批金额的权限就驳回申请，反之则审批通过。 接下来，客户端开始提交申请了：Client /** * 客户端类 */public class Client &#123; public static void main(String[] args)&#123; int amount = 10000; // 出差花费10000元 // 先找专员张飞审批 Staff staff = new Staff(&quot;张飞&quot;); if (!staff.approve(amount)) &#123; // 被驳回，找关二爷问问 Manager manager = new Manager(&quot;关羽&quot;); if (!manager.approve(amount))&#123; // 还是被驳回，只能找老大了 CFO cfo = new CFO(&quot;刘备&quot;); cfo.approve(amount); &#125; &#125; &#125;&#125;/******************************* 无权审批，请找上级。【专员：张飞】 无权审批，请找上级。【经理：关羽】 审批通过。【总监：刘备】 *******************************/ 3. 问题graph LR T([\"问题出在哪里？\"]):::p T --> A(\"流程繁琐\"):::lp T --> B(\"维护困难\"):::lp T --> C(\"职权限制\"):::lp A -.- a(\"办事效率低，审批流程太过烦琐，有种被踢皮球的感觉。\"):::info B -.- b(\"若后期优化业务流程而添加新的审批角色，或增加更复杂的逻辑，申请人就不得不学习新流程，不停修改自己的申请逻辑，增加了维护成本。\"):::info C -.- c(\"审批人的业务之间有环环相扣的关联，对于超出审批人职权范围的申请会传递给上级，直到解决问题为止。\"):::info a --> D([\"工作流架构设计不合理申请人终将被淹没在一堆复杂的审批流程中。\"]):::B b --> D c --> D classDef p fill:#ddaebd classDef lp fill:#f4e4e9 classDef B fill:#d9dfeb, stroke:#657eae,stroke-width:2px classDef lb fill: #d9dfeb classDef info fill:#f6f6f7,color:#737379, stroke-width: 2px, stroke-dasharray: 3 3 类似如上环环相扣的传递机制，就需要我们搭建一个链式结构的工作流，这也是责任链模式的精髓之所在。 . 四、架构工作流我们用抽象类来定义审批人： 审批人 Approverpublic abstract class Approver &#123; protected String name; // 抽象出审批人的姓名 protected Approver nextApprover; // 下一位审批人，更高级别的领导 public Approver(String name)&#123; this.name = name; &#125; protected Approver setNextApprover(Approver nextApprover) &#123; this.nextApprover = nextApprover; return this.nextApprover; // 返回下一位审批人，使其支持链式编程 &#125; public abstract void approve(int amount); // 抽象审批方法由具体审批人子类实现 /* * 由于审批人在无权审批时需要传递业务给其上级领导，因此我们在第4行定义上级领导的引用nextApprover，与下一位审批人串联起来，同时将其注入第10行。 * 当然，每位审批人的角色不同，其审批逻辑也有所区别，所以我们在第15行对审批方法进行抽象，交由具体的子类审批角色去继承和实现。 */&#125; 接着对3个审批角色的代码进行重构： Staff /** * 财务专员类 */ public class Staff extends Approver &#123; public Staff(String name) &#123; super(name); &#125; @Override public void approve(int amount) &#123; if(amount &lt;= 1000) &#123; System.out.println(&quot;审批通过。【专员：&quot; + name + &quot;】&quot;); &#125; else &#123; System.out.println(&quot;无权审批，升级处理。【专员：&quot; + name + &quot;】&quot;); this.nextApprover.approve(amount); &#125; &#125;&#125;/* 财务专员类继承了审批人抽象类并实现了审批方法approve()， 接收到报销申请金额后自第9行开始申明自己的审批权限为1000元， 若超出则调用自己上级领导的审批方法nextApprover() ，将审批业务传递下去。*/ Manager /** * 财务经理类 */ public class Manager extends Approver &#123; public Manager(String name) &#123; super(name); &#125; @Override public void approve(int amount) &#123; if(amount &lt;= 5000) &#123; System.out.println(&quot;审批通过。【经理：&quot; + name + &quot;】&quot;); &#125; else &#123; System.out.println(&quot;无权审批，升级处理。【经理&quot; + name + &quot;】&quot;); this.nextApprover.approve(amount); &#125; &#125;&#125; CFO /** * 财务专员类 */ public class CFO extends Approver &#123; public CFO(String name) &#123; super(name); &#125; @Override public void approve(int amount) &#123; if(amount &lt;= 1000) &#123; System.out.println(&quot;审批通过。【财务总监：&quot; + name + &quot;】&quot;); &#125; else &#123; System.out.println(&quot;驳回申请。【财务总监：&quot; + name + &quot;】&quot;); &#125; &#125;&#125;/* 比较特殊的审批人是责任链末节点的财务总监类，最高职级的财务总监CFO的审批逻辑略有不同， 当申请金额超出10000元后就再有下一个审批人了，所以此时就会驳回报销申请。*//** * 财务专员类 */ public class CFO extends Approver &#123; public CFO(String name) &#123; super(name); &#125; @Override public void approve(int amount) &#123; if(amount &lt;= 1000) &#123; System.out.println(&quot;审批通过。【财务总监：&quot; + name + &quot;】&quot;); &#125; else &#123; System.out.println(&quot;驳回申请。【财务总监：&quot; + name + &quot;】&quot;); &#125; &#125;&#125;/* 比较特殊的审批人是责任链末节点的财务总监类，最高职级的财务总监CFO的审批逻辑略有不同， 当申请金额超出10000元后就再有下一个审批人了，所以此时就会驳回报销申请。*/ Client /** * 客户端类 */ public class Client &#123; public static void main(String[] args)&#123; Aprrovrt flightJohn = new Staff(&quot;张飞&quot;); // 此处使用链式编程配置责任链 flightJogn.setNextApprover(new Manager(&quot;关羽&quot;)).setNextApprover(new CFO(&quot;刘备&quot;)); // 直接找专员张飞审批 flightJohn.approve(1000); /************************ 审批通过。【专员：张飞】 ************************/ flightJohn.approve(4000); /************************ 无权审批，升级处理。【专员：张飞】 审批通过。【经理：关羽】 ************************/ flightJohn.approve(9000); /************************ 无权审批，升级处理。【专员：张飞】 无权审批，升级处理。【专员：关羽】 审批通过。【CEO：刘备】 ************************/ flightJohn.approve(9000); /************************ 无权审批，升级处理。【专员：张飞】 无权审批，升级处理。【专员：关羽】 驳回申请。【CEO：刘备】 ************************/ &#125; &#125; 至此，以责任链模式为基础架构的工作流搭建完成： 各审批角色：只需要定义其职权范围内的工作，再依靠高层抽象实现角色责任的链式结构，审批逻辑得以拆分、串联，让业务申请在责任链上逐级传递。 申请人：再也不必关心业务处理细节与结果了，彻底将工作流或业务逻辑抛开，轻松地将申请递交给责任链入口即可得到最终结果。 五、让业务飞一会儿1. 类结构 责任链模式的类结构： %%{ init: { 'themeVariables': { 'fontSize': '14px' } } }%% classDiagram Handler --o Handler Handler C(\"Client客户端\"):::lp A -.- |\"审批人Approver\"| a[\"所有业务处理节点的顶层抽象* 定义了抽象业务处理方法 handle() 并留给子类实现* 实体方法 setSuccessor()-注入继任者 ：构建责任链\"] B -.- |\"StaffManagerCFO\"| b[\"实际业务处理的实现类，可以有任意多个，每个都实现了 handle() 方法以处理自己职权范围内的业务，职权范围之外的事则传递给下一位继任者\"] C -.- c[\"业务申请人，只需对业务链条的第一个入口节点发起请求即可得到最终响应。\"] classDef p fill:#ddaebd classDef lp fill:#f4e4e9 3. 总结%%{ init: { 'themeVariables': { 'fontSize': '14px' } } }%% graph LR T([\"责任链模式总结\"]):::p T --> A([\"本质\"]):::g T --> C([\"优点\"]):::p A ---> a[\"处理某种连续的工作流，并确保业务能够被传递至相应的责任节点上得到处理。\"]:::lg C --> c1([\"可扩展\"]):::lp C --> c2([\"低耦合\"]):::lp c1 -.- c1t[\"对责任链模式的应用让我们可以泰然自若地应对业务需求的变更，方便地对业务链条进行拆分、重组，以及对单独节点的增、删、改。\"]:::lp c1 -.- c1t2[\"结构松散的业务处理节点让系统具备更加灵活的可伸缩性、可扩展性。\"]:::info c2 -.- c2t[\"责任链模式让申请方与处理方解耦，申请人能彻底从业务细节中解脱出来，无论审批流程多么复杂，都只需要简单的等待，让业务在责任链上飞一会儿。\"]:::lp classDef p fill:#ddaebd classDef g fill:#9ac5bb classDef lp fill:#f4e4e9 classDef lg fill:#ddebe6 classDef info fill:#f6f6f7,color:#737379,stroke-dasharray: 3 3, stroke-width: 2px","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://equnee.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Chain","slug":"Chain","permalink":"https://equnee.github.io/tags/Chain/"}]},{"title":"🌷《秒懂设计模式》—— 单例模式","slug":"note/Design-pattern/design-pattern_Singleton","date":"2023-03-07T17:32:40.177Z","updated":"2023-05-04T09:26:02.193Z","comments":true,"path":"note/Design-pattern/design-pattern_Singleton/","link":"","permalink":"https://equnee.github.io/note/Design-pattern/design-pattern_Singleton/","excerpt":"","text":"来自《秒懂设计模式》 一. 孤独的太阳我们可以把太阳系看作一个庞大的系统，其中有各种各样的对象存在，丰富多彩的实例造就了系统的美好。这个系统里的某些实例是唯一的，如我们赖以生存的恒星太阳。 与其他行星或卫星不同的是，太阳是太阳系内唯一的恒星实例。但倘若天上有9个太阳，那么将会带来一场灾难。太阳不多不少仅此一例。 二. 饿汉造日%%{ init: { 'themeVariables': { 'fontSize': '22px', 'fontFamily': 'Noto Serif SC' } } }%% graph LR T((\"饿汉造日\")):::b T --> A([\"1. 开始\"]):::p T --> B([\"2. 构造方法私有化\"]):::p T --> C([\"3. 自有永有\"]):::p T --> D([\"4. 公开访问\"]):::p T --> E([\"5. 总结\"]):::b A --> a(\"既然太阳系里只有一个太阳，就需要严格把控太阳实例化的过程。\"):::lp a -.-> at([\"Public class Sun {} // 一个最简单的Sun类\"]):::lg B --> b(\"太阳只有一个，不能随意创建实例。但由于Java会自动生成一个无参构造器，因此必须禁止外部调用构造器*。\"):::lp b -.-> bt([\"private Sun(){}\"]):::lg C --> c(\"让它在类加载时就自己创建自己，并使其自有永有\"):::lp c -.-> ct([\"private static final Sun sun = new Sun();\"]):::lg D --> d(\"使用静态方法*getInstance()来获取太阳的单例对象并将其设置为“public”以暴露给外部使用\"):::lp d -.- dt([\"public static Sun getInstance(){ return sun; }\"]):::lg d -.- d2t[\"*如同程序入口的静态方法main(), 不需要任何对象引用就能被访问\"]:::info T -..-> e(\"（还可以添加其他功能方法，如发光和发热等）\"):::info d --> et(\"最后，不管谁得到或得到几次，得到的都是同一个太阳实例，这样就确保了整个太阳系中恒星太阳的唯一合法性，他人无法伪造。\"):::lb E --> e2t(\"这就是“饿汉模式”(eager initialization)：即在初始阶段(static)就主动进行实例化，并时刻保持一种渴求的状态(public)，无论此单例是否有人使用。\"):::lb classDef p fill:#ddaebd classDef b fill:#aab7d2 classDef lp fill:#f4e4e9 classDef lb fill:#d9dfeb classDef lg fill:#cde2da classDef info fill:#f6f6f7,color:#5a5a5f,stroke-dasharray: 3 3, stroke-width: 2px 1. 开始 public class Sun &#123;&#125; 2. 构造方法私有化 接下来我们得确保任何人都不能创建太阳的实例，否则一旦程序员调用代码“new Sun()”，天空就会出现多个太阳，便又需要“后羿”去解决了。 实例化工作完全归属于内部事务，任何外部类都无权干预 public class Sun &#123; private Sun()&#123; // 构造方法私有化 &#125; &#125; 3. 自有永有 public class Sun &#123; private static final Sun sun = new Sun(); // 自有永有的太阳单例 private Sun()&#123; // 构造方法私有化 &#125; &#125; 关键字 说明 private 确保太阳实例的私有性、不可见性和不可访问性； static 确保太阳的静态性，将太阳放入内存里的静态区，在类加载的时候就初始化了，它与类同在，也就是说它是与类同时期且早于内存堆中的对象实例化的，该实例在内存中永生，内存垃圾收集器(Garbage Collector, GC)也不会对其进行回收； final 确保这个太阳是常量、恒量，它是一颗终极的恒星，引用一旦被赋值就不能再修改； new 初始化太阳类的静态实例，并赋予静态常量sun。 4. 公开访问 单例的太阳对象写好了，可一切皆是私有的，外部如何访问？—— 使用静态方法getInstance()来获取太阳的单例对象。 public class Sun &#123; private static final Sun sun = new Sun(); // 自有永有的太阳单例 private Sun()&#123; // 构造方法私有化 &#125; public static Sun getInstance()&#123; // 阳光普照，方法公开化 return sun; &#125; &#125; 三. 懒汉的队伍graph LR T((懒汉的队伍)):::b T --> A([\"1. 用时才创建\"]):::p T --> B([\"2. 排队（同步锁）\"]):::p T --> C([\"3. 需要时再排队（双检锁）\"]):::p A --> a(\"若无请求就不实例化，节省内存空间\"):::lp a -.-> at([\"去掉 finalif(sun == null)\"]):::lg B --> b(\"由于多线程时的缺陷：请求方法加上同步锁synchronized\"):::lp b -.- bt2([\"public static synchronized Sun getInstance() \"]):::lg b -.-> bt3(\"加锁后某线程调用前必须获取同步锁，调用完会释放锁给其他线程用，也就是给请求排队。\"):::info C --> c(\"为了解决线程阻塞：使用2个嵌套的判空逻辑\"):::lp c -.- ct([\"private volatile static Sun sun;if(sun = null){ synchronized(){if(sun == null){sun = new Sun();}\"]):::lg c -.- ct2[\"1. 外层放宽入口，保证线程并发的高效性2. 内层加锁同步，保证实例化的单次运行\"]:::info classDef p fill:#ddaebd classDef b fill:#aab7d2 classDef lp fill:#f4e4e9 classDef lb fill:#d9dfeb classDef lg fill:#cde2da classDef info fill:#f6f6f7,color:#433f40,stroke-dasharray: 3 3, stroke-width: 2px 1. 用时才创建 单例的“饿汉模式”，让太阳一开始就准备就绪，随时供应免费日光。 然而，如果始终没人获取日光，那就白造了太阳，白白浪费一块内存区域。类似于商家货品滞销的情况，货架上堆放着商品却没人买，白白浪费空间。因此，商家为了降低风险，规定有些商品必须提前预订，这就是“懒汉模式”(lazy initialization)。 public class Sun &#123; private static Sun sun; // 这里不进行实例化 private Sun()&#123; // 构造方法私有化 &#125; public static Sun getInstance() &#123; if(sun == null) &#123; // 如果无日才造日 sun = new Sun(); &#125; return sun; &#125;&#125; 关键字 说明 去掉 final 一开始并没有造太阳，所以去掉了关键字final。 用时才实例化 仅在某线程第一次调用第9行的getInstance()方法时才会运行对太阳进行实例化的逻辑代码，之后再请求就直接返回此实例了。❗️缺点：初次请求时速度较之前的饿汉初始化模式慢，因为要消耗CPU资源去临时造这个太阳。 2. 排队 因为上述程序在多线程模式下有缺陷：并发请求时判空逻辑会同时成立，导致多次实例化太阳、多次赋值，违背单例理念。 public class Sun &#123; private static Sun sun; // 这里不进行实例化 private Sun()&#123; // 构造方法私有化 &#125; public static synchronized Sun getInstance() &#123; // 此处加入同步锁 if(sun == null) &#123; // 如果无日才造日 sun = new Sun(); &#125; return sun; &#125;&#125; 关键字 说明 synchronized 将太阳类Sun中第9行的getInstance()改成了同步方法，如此可避免多线程陷阱。 3. 需要时再排队 如果仅为了实例化一个单例对象，直接加锁排队,使用synchronized让所有请求排队等候：会造成线程阻塞，资源与时间被白白浪费。 public class Sun &#123; private volatile static Sun sun; private Sun() &#123; // 构造方法私有化 &#125; public static Sun getInstance() &#123; // 华山入口 if(sun = null)&#123; synchronized(Sun.class)&#123; // 观日者进行排队 if(sun == null)&#123; sun = new Sun(); // 只有排头兵造了太阳，旭日东升 &#125; &#125; &#125; return sun; // ……阳光普照，其余人不必再造日 &#125;&#125; 关键字 说明 去掉 final 第3行对sun变量的定义不再使用final关键字，说明它不再是常量，而是需要后续赋值的变量； volatile 关键字volatile对静态变量的修饰则能保证sun变量值在各线程访问时的同步性、唯一性。 去掉入口的同步锁 对于第9行的getInstance()方法，去掉方法上的关键字synchronized，使大家都能同时进入方法并对其进行开发。 判空逻辑1 有些人（线程）起早就是为了观看日出，那么这些人会通过第10行的判空逻辑进入观日台。 判空逻辑2 在第12行我们又进行一次判空逻辑，这就意味着只有队伍中的第一个人造了太阳，有幸看到了日出的第一缕阳光，而后面的人则统统离开，直到第17行得到已经造好的太阳。 最后：太阳高高升起，实例化操作完毕，起晚的人们都无须再进入观日台，直接获取太阳实例即可，温暖阳光普照大地。 四. 大道至简相比“懒汉模式”，其实更常用“饿汉模式”，因为这个单例迟早是要被实例化占用内存的，延迟懒加载的意义并不大，加锁解锁反而是一种资源浪费，同步更是会降低CPU的利用率，使用不当的话反而会带来不必要的风险。越简单的包容性越强，而越复杂的反而越容易出错。 单例模式的类结构： classDiagram class Singleton{ - instance : singleton - Sigleton() + getInstance() Singleton } Singleton --> Singleton Singleton（单例）：包含一个自己的类实例的属性，并把构造方法用privat关键字隐藏起来，对外只提getInstance()方法以获得这个单例对象。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://equnee.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"singleton","slug":"singleton","permalink":"https://equnee.github.io/tags/singleton/"}]},{"title":"Mac远程连接Windows（Microsoft Remote Desktop）","slug":"guide/mac_mrd_windows","date":"2021-03-25T07:49:07.000Z","updated":"2023-03-23T12:00:15.278Z","comments":true,"path":"guide/mac_mrd_windows/","link":"","permalink":"https://equnee.github.io/guide/mac_mrd_windows/","excerpt":"","text":"摘要: 同时带两台电脑出门很麻烦，于是选择在Mac上使用 Microsoft Remote Desktop 远程连接使用不带出门的 Windows，从此只需要把Windows放在家里连接电源和wifi一直放着就行！顺便整理了一些别人遇到的错误和解决方法。 日期: 2021/3/25 环境 : MacOS 11.2.2 + Windows10 一. 软件下载下载 Microsoft Remote Desktop，根据情况下载对应版本的app： 使用 Windows 控制 windows：&gt;&gt; 官网下载 使用 Mac 控制 windows： App Store 下载，仅国外的应用商店提供下载，因此只能使用国外的 AppleID，可参考&gt; &gt; 国外AppleID申请方法。 其他渠道下载（俺也没试过 二. 创建连接2.1 Windows 配置 首先确保将被控制的 Windows 开启了远程桌面连接配置： （1）系统属性 设置了系统属性为允许远程桌面连接 若选项都是灰色无法允许远程连接，&gt; 参考这里。 运行 gpedit.msc 回车打开本地组策略编辑器,在左侧的列表中依次展开：计算机配置&gt;管理模板&gt;Windows组件&gt;远程桌面会话主机&gt;连接 双击打开右侧的”允许用户通过使用远程桌面服务进行远程连接“,看一下之前是否有配置,如果有的话改成”未配置”,如果之前就是未配置,那可以改成已启用,然后您再看一下系统属性&gt;远程桌面中的相关设置区域是否恢复正常. （2）防火墙 设置了防火墙允许远程桌面通过防火墙通信 （3）端口 开启了用于远程桌面连接的服务端口： 在cmd中输入netstat -aon|findstr 3389，查看默认端口号3389是否开启。 若端口号未开启：打开任务管理器，开启下面两项服务。（UmRdpServise可播放声音) 若修改过或无法查询到3389端口，&gt; 参考这里。 （4）本地策略 设置本地策略非来宾。在运行中输入：gpedit.msc （5）关闭 Windows hello 确保关闭了设置内 仅允许 Windows hello 登录 (未设置可忽略。) Windows Hello：使您可以使用脸部，虹膜，指纹或PIN登录设备，应用程序，在线服务和网络。 （6）AAD 确保不是通过 Microsoft Authenticator ，而是通过手动输入密码进行验证登录的： 因为 Microsoft Authenticator 登录使用的认证方式与其他域不互通，就不能直接开启连接啦。 2.2 添加计算机 配置Windows允许远程桌面连接后，使用Mac准备开始连接，在Microsoft Remote Desktop中添加PC，输入主机名 + 用户账号信息。 PC name：IP地址。 查看方法：在 Windows 的命令提示符(win+R 键打开的运行窗口输入cmd) 输入命令 ipconfig，可查看ipv4地址。 User account：登录该PC的账号密码。建议选择 Ask when required，先不输入账号密码，在连接时输入，确保能连接成功后再添加记录，防止这里保存的账号密码有误，后面怎么都连不上。 2.3 填写账户信息（1） 本地用户 使用本地用户名登录： 本地用户名(cmd输入 whoami 查看) + 本地解锁密码。 （2） 微软账户 使用微软账户登录： 本地创建的英文账户若关联了微软账号，可使用该微软账号邮箱进行远程登录，用户名为邮箱格式的微软账号(username@outlook.com) + 对应的微软账号密码。 （3） 空密码 或使用空密码进行远程桌面连接：在 windows 中设置 打开运行，输入gpedit.msc，打开本地组策略编辑器 2.4 报错解决（1） The User Account Did Not work 🔒 提示：The User Account Did Not Work.The user account used to connect to xx.xx.xx.xx (remote PC) did not work. Try again.（–&gt; 你输的这个账户信息连不上。） 🔑 解决方法：需要输入正确的账号密码。 微软账号登录：邮箱格式的微软账号(username@outlook.com) + 对应的微软账号密码 本地用户登录：本地主机名或本地账户名 + 本地账户解锁密码 以前可以，现在突然连不上了：检查上面两个密码是不是改过了，如果改过记得同步修改。 （2） 0x204 🔒 连接时提示：We couldn’t connect to the remote PC.Make sure the PC is turned on and connected to the network, and thar remote access is enabled. Error code:0x204（–&gt; 我们无法连接到远程电脑，确保电脑已打开并连接到网络，并且已启用远程访问。） 🔑 解决方法： 开电脑。检查是否打开windows电源，确保非关机或睡眠状态，开启电源解锁屏幕就可以啦。 连Wi-Fi。 开服务。确保已开启 Windows 的远程桌面连接配置。 （3） 0x207 🔒 提示： 🔑：确保windows的本地组策略不是 仅来宾 状态。 三. Mac配置3.1 创建目录 在mac电脑上，根据需要创建用于文件传输的目录。 3.2 编辑配置 开启Microsoft Remote Desktop 软件，点击编辑。 如图所示，添加重定向刚创建的文件夹对应的路径 3.3 完成 可查看windows上的文件夹映射，没出现的话重新连接试试。 四. 结尾第一次完成mac和windows之间远程桌面的配置，回头看感觉写得有些复杂，因为多记录了一些自己也没遇到过的问题和情况。如果各位还遇到了文中没提到的情况，欢迎评论留言，我会继续补充～","categories":[{"name":"工具","slug":"工具","permalink":"https://equnee.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"windows","slug":"windows","permalink":"https://equnee.github.io/tags/windows/"},{"name":"Mac","slug":"Mac","permalink":"https://equnee.github.io/tags/Mac/"}]},{"title":"🍡 Mermaid — 超好用的文档图形工具！","slug":"tool/markdown+mermaid","date":"2020-04-01T16:37:51.048Z","updated":"2023-05-04T09:26:31.173Z","comments":true,"path":"tool/markdown+mermaid/","link":"","permalink":"https://equnee.github.io/tool/markdown+mermaid/","excerpt":"","text":"一. Markdown（略 二. Mermaid 在线体验：https://mermaid.live/ 1. 为什么用 Mermaid 在配合 Markdown 写笔记时，最让我头疼的就是如何以最省时省力的方式插入流程图。我做过很多尝试：如，手绘、使用Xmind导图软件、ProcessOn之类的在线绘图工具等。但它们都有最显著的缺点：最终以图像形式导入文档，因此修改和导出非常繁琐。 而 Mermaid 对我来说是一个说近乎完美的方案！ 高效易用 它直接在 Markdown 中以代码段的形式创建和修改图表，并实时渲染为 Svg 视图，可以高效制作简易的流程图。并且随时修改、立即可见。 它和 Markdown 一样都是纯文本格式存储的语言，易于保存和分享。 Web友好 它不受制于特定编辑器，大部分支持 Markdown 的编辑器都支持 Mermaid。 它基于 Javascript，可集成嵌入前端框架，如 Vue、Hexo等。 2. Mermaid 用法Mermaid 可绘制流程图、时序图、Git图、类图、饼图、甘特图等图表，详细可查阅 官方文档。下面以我常用的两个流程图模版作为示例（主要展示样式的两种使用方法）： 基础（使用基本样式） graph LR T((\"Title\")):::p T ==> A([\"Pink\"]):::p T --> B([\"Green\"]):::g T --> C([\"Blue\"]):::b A -.-> a(\"light Pink\"):::lp B -.-> b(\"light Green\"):::lg C -.-> c(\"light Blue\"):::lb a -.- info[\"Info\"]:::info classDef p fill:#ddaebd classDef b fill:#aab7d2 classDef g fill:#9ac5bb classDef lp fill:#f4e4e9 classDef lb fill:#d9dfeb classDef lg fill:#ddebe6 classDef info fill:#f6f6f7,color:#737379,stroke-dasharray: 3 3, stroke-width: 2px graph LR T((&quot;Title&quot;)):::p T ==&gt; A([&quot;Pink&quot;]):::p T --&gt; B([&quot;Green&quot;]):::g T --&gt; C([&quot;Blue&quot;]):::b A -.-&gt; a(&quot;light Pink&quot;):::lp B -.-&gt; b(&quot;light Green&quot;):::lg C -.-&gt; c(&quot;light Blue&quot;):::lb a -.- info[&quot;Info&quot;]:::info%% 样式： style T color:#fff classDef p fill:#ddaebd classDef b fill:#aab7d2 classDef g fill:#9ac5bb classDef lp fill:#f4e4e9 classDef lb fill:#d9dfeb classDef lg fill:#ddebe6 classDef info fill:#f6f6f7,color:#737379,stroke-dasharray: 3 3, stroke-width: 2px 进阶（使用预加载样式） %%{ init: { 'themeVariables': { 'fontFamily': 'Noto Serif SC', 'mainBkg': '#f4e4e9', 'edgeLabelBackground': '#ddebe6' } } }%% graph TD T((\"Title\")):::pink T --> A A -.-> |\"text2\"| B subgraph \"subgraph\" A --> |\"text3\"|C:::lb end classDef pink fill:#ddaebd style B fill:#d9dfeb, stroke:#657eae,stroke-width:3px,stroke-dasharray: 5 3 %%&#123; init: &#123; &#x27;themeVariables&#x27;: &#123; &#x27;fontFamily&#x27;: &#x27;Noto Serif SC&#x27;, &#x27;mainBkg&#x27;: &#x27;#f4e4e9&#x27;, &#x27;edgeLabelBackground&#x27;: &#x27;#ddebe6&#x27; &#125; &#125;&#125;%%graph TDT((&quot;Title&quot;)):::pinkT --&gt; AA -.-&gt; |&quot;text2&quot;| Bsubgraph &quot;subgraph&quot;A --&gt; |&quot;text3&quot;|C:::lbendclassDef pink fill:#ddaebdstyle B fill:#d9dfeb, stroke:#657eae,stroke-width:3px,stroke-dasharray: 5 3 3. Hexo + Mermaid 插件 代码仓库: https://github.com/webappdevelp/hexo-filter-mermaid-diagrams （1）安装插件$ yarn add hexo-filter-mermaid-diagrams 或 $ npm install hexo-filter-mermaid-diagrams （2）编辑配置安装完成后，编辑hexo配置文件：config.yml # mermaid chartmermaid: enable: true version: &quot;7.1.2&quot; options: （3）添加脚本修改完配置文件后，编辑博客页面组件的footer部分。这是为了将 mermaid.js 以 script 形式插入到 html 尾部，使其能正常渲染。 footer文件如，footer.pug， after_footer.pug , after-footer.ejs 或 swig，该文件通常存放在主题目录下的layout目录中。 若博客使用pug模版引擎渲染，在 after_footer.pug文件中添加如下代码: if theme.mermaid.enable == true script(type=&#x27;text/javascript&#x27;, id=&#x27;maid-script&#x27; mermaidoptioins=theme.mermaid.options src=&#x27;https://unpkg.com/mermaid@&#x27;+ theme.mermaid.version + &#x27;/dist/mermaid.min.js&#x27; + &#x27;?v=&#x27; + theme.version) script. if (window.mermaid) &#123; var options = JSON.parse(document.getElementById(&#x27;maid-script&#x27;).getAttribute(&#x27;mermaidoptioins&#x27;)); mermaid.initialize(options); &#125; 若使用ejs引擎渲染，则在after-footer.ejs文件中添加如下代码： &lt;% if (theme.mermaid.enable) &#123; %&gt; &lt;script src=&#x27;https://unpkg.com/mermaid@&lt;%= theme.mermaid.version %&gt;/dist/mermaid.min.js&#x27;&gt;&lt;/script&gt; &lt;script&gt; if (window.mermaid) &#123; mermaid.initialize(&#123;theme: &#x27;neutral&#x27;&#125;); &#125; &lt;/script&gt;&lt;% &#125; %&gt; swig模版引擎： &#123;% if theme.mermaid.enable %&#125; &lt;script src=&#x27;https://unpkg.com/mermaid@&#123;&#123; theme.mermaid.version &#125;&#125;/dist/mermaid.min.js&#x27;&gt;&lt;/script&gt; &lt;script&gt; if (window.mermaid) &#123; mermaid.initialize(&#123;&#123; JSON.stringify(theme.mermaid.options) &#125;&#125;); &#125; &lt;/script&gt;&#123;% endif %&#125; （4）踩坑以上为官方文档中的配置方法，而我在初次配置的过程中，还遇到以下问题可供参考： html页面中，mermaid段落仅显示为代码块，开发者工具中该段落为普通源代码。 这是因为插件没有生效，应确保正确完成上面两个步骤（安装插件、打开配置）。 html页面中，mermaid段落显示为空白图片，开发者工具中查看该段落为svg文件，控制台报错： Uncaught TypeError: Cannot read properties of null (reading’mermaid’)。 此时插件已经生效，而js代码文件引入有误，无法成功渲染。 继续查看html代码发现，文件底部的&lt;sctipt&gt;标签中，显示我引入mermaid的url为： &lt;script type=&quot;text/javascript&quot; id=&quot;maid-script&quot; src=&quot;https://unpkg.com/mermaid@10.0.2/dist/mermaid.min.js?v=undefined&quot;&gt;&lt;/script&gt; 这段代码是由官方提供的脚本、在footer文件中根据用户的配置组合成的： script(type=&#x27;text/javascript&#x27;, id=&#x27;maid-script&#x27; mermaidoptioins=theme.mermaid.options src=&#x27;https://unpkg.com/mermaid@&#x27;+ theme.mermaid.version + &#x27;/dist/mermaid.min.js&#x27; + &#x27;?v=&#x27; + theme.version) 如果配置有误则会生成错误的url，看起来是version的问题，于是我将url改为直接引入jsdelivr上的资源，遂能正常渲染： src=&#x27;https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js&#x27;)","categories":[{"name":"工具","slug":"工具","permalink":"https://equnee.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Mermaid","slug":"Mermaid","permalink":"https://equnee.github.io/tags/Mermaid/"},{"name":"Markdown","slug":"Markdown","permalink":"https://equnee.github.io/tags/Markdown/"}]}],"categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://equnee.github.io/categories/Java%E5%9F%BA%E7%A1%80/"},{"name":"数据结构","slug":"数据结构","permalink":"https://equnee.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"设计模式","slug":"设计模式","permalink":"https://equnee.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"工具","slug":"工具","permalink":"https://equnee.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://equnee.github.io/tags/Java/"},{"name":"I/O","slug":"I-O","permalink":"https://equnee.github.io/tags/I-O/"},{"name":"HashMap","slug":"HashMap","permalink":"https://equnee.github.io/tags/HashMap/"},{"name":"Chain","slug":"Chain","permalink":"https://equnee.github.io/tags/Chain/"},{"name":"singleton","slug":"singleton","permalink":"https://equnee.github.io/tags/singleton/"},{"name":"windows","slug":"windows","permalink":"https://equnee.github.io/tags/windows/"},{"name":"Mac","slug":"Mac","permalink":"https://equnee.github.io/tags/Mac/"},{"name":"Mermaid","slug":"Mermaid","permalink":"https://equnee.github.io/tags/Mermaid/"},{"name":"Markdown","slug":"Markdown","permalink":"https://equnee.github.io/tags/Markdown/"}]}