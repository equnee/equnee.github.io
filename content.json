{"meta":{"title":"🍧 Peach","subtitle":"equne","description":"蜜桃想写可爱的代码","author":"equne","url":"https://equnee.github.io","root":"/"},"pages":[],"posts":[{"title":"🦋 HashMap","slug":"note/Data-Structure/data-structure_HashMap","date":"2023-03-09T15:11:32.969Z","updated":"2023-03-12T18:45:08.518Z","comments":true,"path":"note/Data-Structure/data-structure_HashMap/","link":"","permalink":"https://equnee.github.io/note/Data-Structure/data-structure_HashMap/","excerpt":"","text":"注：本文制作的流程图仅为个人理解，仅供参考。 一、Hash算法1. HashMap原理（1）HashMap怎么存取 使用数组保存、通过数组索引获取： %%{ init: { 'themeVariables': { 'fontFamily': 'Noto Serif SC', 'edgeLabelBackground': '#ddebe6' } } }%% graph TD T((\"HashMap怎么存取值\")):::p T --> |\"数据以键值对形式存储\"| A[\"key — value\"] A --> |\"包装为Node数组对象\"| B[\"Node { key, value }\"] B --> |\"通过node数组下标保存对应数据\"| C[\"node[0] = new Node { key, value }node[1] = new Node { key, value }node[2] = new Node { key, value } ...\"] C -.-> |\"[ 保存 ] 遍历数组，对应key和value\"| D[\"for (Node node : nodes)\"] C --> |\"[ 获取 ] 通过 数组索引 获取（key的hash值）\"|E[\"node[ hash(key) ] = value\"]:::lb classDef p fill:#ddaebd style E fill:#d9dfeb, stroke:#657eae,stroke-width:2px,stroke-dasharray: 5 3 （2）Hash算法怎么写 计算数组索引值： %%{ init: { 'themeVariables': { 'fontFamily': 'Noto Serif SC', 'clusterBorder': 'none', 'clusterBkg': '#f0f2f7' } } }%% graph TD T((\"Hash算法怎么写？\")):::p T --> |\"如何计算出数组索引？hash(key)\"| A[\"* 因为Node数组有固定的初始化默认长度（length）* 索引值需限定在数组长度范围内（0～length-1）* 索引值还要尽可能平衡、分布均匀\"] A --> B([\"取模运算：hash % length\"]) B ==> |\"（更好的方案：使用位运算效率更高）\"| C([\"位运算：hash & (length - 1)\"]) C -.- c(\"length必须是2的n次幂\"):::b subgraph \"前置条件\" c -.- c2[\"假如 key = 20, length = 16, hash & (length-1):0001 0100 // 20 0000 1111 // 150000 0100 // =4\"]:::c2 end classDef p fill:#ddaebd classDef b fill:#d2d9e7, stroke-width: 0px style c2 color: #86868b, fill:#ebedf3, stroke-dasharray: 3 3 %% 取模运算 style B fill: #f4e4e9 %% \"位运算\" style C fill:#b8c3d9, stroke:#657eae,stroke-width:2px 为了解决取模的效率问题，采用了位运算的方法：index = hash值 &amp; (length -1)此时需要一个前置条件：length的长度必须是2的n次幂。当length的长度是2n时，有以下公式成立： num%2n = num&amp;(2n-1) 。 🦋 因为就像十进制取余数一样，若除以10或10的整次幂数，余数刚好是取低位上的数字。同理，二进制取余数只要除以2的n次幂数，低位上的数字就是我们需要的余数。而(2n - 1)的二进制有效位都是1，和n位的1作与运算相当于取低n位的值。 length的长度刚好是2的n次幂，扩容也是按原来的2倍容量进行扩容，可以加快hash计算、减少hash冲突。 🦋 加快hash计算： 两倍扩容机制使容量一直保持在2的n次幂数，就可以使用位运算代替取模运算，提升hash计算效率。 当容量保持为2的n次幂时，每次扩容时位运算计算得出的余数不变，数据存放的索引位置也保持不变。而使用%计算时，结果会因为容量的变化而改变（模运算会产生小数点），每次扩容时数据在数组中存放的位置会发生改变（数据漂移），影响性能。 🦋 减少hash冲突： 将容量保持为偶数进行hash计算时，经过(length-1)后，计算出的索引值为奇数和偶数的概率相同（取决于随机生成的hash值）； 而使用奇数容量进行hash计算时，经过(length-1)后，最终结果均为偶数，这样任何 hash 值都只会被散列到数组的偶数下标位置上，这浪费了近一半的空间。 因此2的n次幂容量、双倍扩容机制可以使容量保持在偶数值，可以使添加的元素在HashMap的数组中均匀分布，减少hash碰撞。 （3）Hash冲突怎么办 Hash冲突 %%{ init: { 'themeVariables': { 'fontFamily': 'Noto Serif SC', 'edgeLabelBackground': '#ddebe6' } } }%% graph TD T((\"1. Hash冲突怎么优化\")):::p --> T1(\"hash表里可以存储元素的位置被称为“桶（bucket）”\") T1 --> |\"通常情况\"| A(\"单个“桶”里存储一个元素，此时性能最佳\"):::g A -.-> |\"O(1)\"| a[\"hash算法可以根据hashCode值计算出“桶”的存储位置，接着从“桶”中取出元素。\"] T1 --> |\"哈希冲突的情况\"| B(\"单个桶会存储多个元素（hash值相同）\"):::g B -.-> |\"O(n)\"|b([\"多个元素以 链表 形式存储\"]):::B b --> 2T((\"2. Hash冲突很大怎么优化\")):::p subgraph \"（链表必须按顺序搜索，存取性能差）\" 2T --> C([\"将链表结构转为红黑树\"]):::B C -.- |\"O(logn)\"|c[\"以树的高度为最差查询性能，永远不会出现O(n)的情况。\"]:::info end classDef p fill:#ddaebd classDef g fill:#f4e4e9 classDef B fill:#d9dfeb, stroke:#657eae,stroke-width:2px classDef info fill:#f6f6f7,color:#737379stroke-width: 2px, stroke-dasharray: 5 5 Hash冲突示意图 %%{ init: { 'themeVariables': { 'fontFamily': 'Noto Serif SC', 'edgeLabelBackground': '#cde2da', 'clusterBorder': 'none', 'clusterBkg': '#ececee' } } }%% %% 链表超过8时树化成红黑树 graph TD subgraph \"Node[]\" Entry0[\"Node0Node＜K,V>\"] -.- Node1 -.- Node2 -.- Node3 -.- Node4 -.- Node5 -.- Node6 end subgraph 链表 Node1 --> A[Node] --> B[Node] --> C[Node] --> D[Node] --> E[Node] --> F[Node] --> G[Node] end subgraph 红黑树 Node4 --> a[Node] a[Node] --> b[Node] b --> b1[Node] b --> b2[Node] a --> c[Node] c --> c1[Node] c --> c2[Node] b1 --> d[Node] b1 --> d2[Node] end style 链表 fill:#ddebe6 style 红黑树 fill:#f4e4e9 （4）Hash冲突时 Hash冲突时删除元素： %%{ init: { 'themeVariables': { 'fontFamily': 'Noto Serif SC', 'edgeLabelBackground': '#cde2da' } } }%% graph TD T((\"Hash冲突时怎么删除元素？\")):::p T --> B[\"先根据key找到桶位\"] B --> A(\"判断为红黑树或链表，根据不同结构从当前位置移除\") A -.-> |\"链表\"|a[\"将上个位置指空\"]:::b A -.-> |\"红黑树\"|b[\"去掉当前节点后自平衡\"]:::b classDef p fill:#ddaebd classDef b fill:#d9dfeb 二、HashMap源码1. 属性// 🔹 常量// 默认的初始容量值（16）- 必须是2的n次幂static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;// 最大容量上限（2的30次方）static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;// 默认的负载因数（0.75）static final float DEFAULT_LOAD_FACTOR = 0.75f;// 树化阈值：当一个桶中的元素个数大于等于8时进行树化static final int TREEIFY_THRESHOLD = 8;// 树降级为链表的仓位计数阈值，当一个桶中的元素个数小于等于6时把树转化为链表。static final int UNTREEIFY_THRESHOLD = 6;// 将table树化的最小容量值（64）：当桶的个数达到64的时候才进行树化（至少应为4*TREEIFY_THRESHOLD，以避免调整大小和树化阈值之间的冲突。）static final int MIN_TREEIFY_CAPACITY = 64;// 🔹 变量// Node数组，又叫作桶（bucket）transient Node&lt;K,V&gt;[] table;// 作为entrySet()的缓存transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;// 元素的数量transient int size;// 扩容阈值 = table.length * loadFactor（当size大于阈值时扩容）int threshold;// 负载因数：表示整体上table被占用的程度final float loadFactor; 2. 构造方法%%{ init: { 'themeVariables': { 'fontFamily': 'Noto Serif SC', 'edgeLabelBackground': '#ddebe6' } } }%% graph LR T((\"HashMap构造方法\")):::p T --> A([\"HashMap map1 = new HashMap();\"]):::lp T --> B([\"HashMap map2 = new HashMap(30);\"]):::lp T --> C([\"HashMap map3 = new HashMap(30, 0.5f);\"]):::lp T --> D([\"HashMap map4 = new HashMap(map);\"]):::lp A --- |\"无参构造方法\"|a(\"不指定容量，默认:16\") B --- |\"initialCapacoty\"| b(\"指定初始化容量：30\") C --- |\"initialCapacotyloadFactor\"| c(\"指定初始化容量、负载因数\") D --- |\"Map map\"| d(\"以指定map构造新map\") D -.- ci(\"* 注意：与上述仅创建空HashMap不同，此方法内部调用了put()存值真正进行了初始化。\"):::info classDef p fill:#ddaebd classDef lp fill: #f4e4e9 classDef info fill:#f6f6f7,color:#737379,stroke-dasharray: 3 3, stroke-width: 2px （1）HashMap() 无参数的构造方法/** * Constructs an empty HashMap with the default initial capacity(16) and the default load factor (0.75). * 以默认初始容量(16)和默认负载因数(0.75)，构造一个空的HashMap。 */public HashMap() &#123; // 🔻 将负载因数赋为默认值。 this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted&#125; （2）HashMap(20) 带初始容量的构造方法：/** * Constructs an empty HashMap with the specified initial capacity and the default load factor (0.75). * 以特定的初始容量和默认的负载因数(0.75)，构造一个空的HashMap * * @param initialCapacity 初始容量 * @throws IllegalArgumentException 初始容量为负值时抛出非法数据异常。 */ public HashMap(int initialCapacity) &#123; // 🔻 调用了带初始容量、负载因数的构造方法（详见下文(3)） this(initialCapacity, DEFAULT_LOAD_FACTOR); &#125; （3）HashMap(20, 0.5f)- HashMap() 带初始容量、负载因数的构造方法/** * Constructs an empty HashMap with the specified initial capacity and load factor. * 以特定的初始容量和负载因数构造一个空的HashMap。 * * @param initialCapacity 初始化容量 * @param loadFactor 负载因数 * @throws IllegalArgumentException if the initial capacity is negative * or the load factor is nonpositive * 当初始容量为负值、或负载因数为非正时抛出非法数据异常。 */public HashMap(int initialCapacity, float loadFactor) &#123; // 🔴 一、判断传入参数的合法性 // 🔹 初始容量值非负数 if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity); // 🔹 初始容量值不超过最大容量 if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; // 🔹 负载因数大于0且为数字 if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor); // 🔴 二、开始赋值 // 🔹 为负载因数赋值 this.loadFactor = loadFactor; // 🔹 为临界值赋值：使用tableSizeFor()将给定数值调整为2的次幂数。 this.threshold = tableSizeFor(initialCapacity);&#125; - tableSizeFor() 返回最接近给定目标容量的二次幂数值。/** * Returns a power of two size for the given target capacity. * 返回给定目标容量的二次幂数。 */static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125;/* 以下为备注： ------------------------------------------------- * 该位运算用于求出高位1之后每位都为1的结果。 因为将每位变为1，则加上1后刚好是一个二次幂数。 如(0000 1000)，使其第一位1后面都为1，即(0000 1111) ------------------------------------------------- */ // 如，initialCapacity = 9 // 🔴 将 n - 1 /* 🔸 原因：为了处理n刚好是二次幂数的情况。 若n已经是2的N次方了，按照逻辑变1之后再加1，结果就会变成n的2倍了，与应有的结果不一致。如 n=16（0001 0000），位运算后 n=31（0001 1111）*/ int n = cap -1; // n = 8 // 🔴 作位运算：1. 无符号位移 2. 与n作或的位运算。 n |= n &gt;&gt;&gt; 1; n = 0000 1000 n = 0000 0100 n = 0000 1100 n |= n &gt;&gt;&gt; 2; n = 0000 1100 n = 0000 0011 n = 0000 1111 // =15 n |= n &gt;&gt;&gt; 4; n = 0000 1111 n = 0000 0000 n = 0000 1111 n |= n &gt;&gt;&gt; 8; n = 0000 1111 n = 0000 0000 n = 0000 1111 n |= n &gt;&gt;&gt; 16; // 🔸 因为int是32位的，所以执行到16即可. // 🔴 返回位移结果n + 1 return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUN_CAPACITY : n + 1; n &lt; 0, 则返回 n = 1 n &gt;= 0, 且 n &gt;= 最大容量, 则返回最大容量 n &gt;= 0, 且 n &lt; 最大容量, 则返回 n + 1 （=16） （4）HashMap(map)- HashMap() 带map的构造方法 /** * Constructs a new HashMap with the same mappings as the specified Map. * The HashMap is created with default load factor (0.75) and an initial capacity sufficient to hold the mappings in the specified Map. * 使用与指定Map相同的映射构造新的HashMap。 * 此HashMap由：默认负载因数(0.75)、足够的初始容量（足以存下指定Map）创建。 * * @param m the map whose mappings are to be placed in this map * @参数： m，原map * @throws NullPointerException if the specified map is null * @异常： 当原map为空时抛出空指针异常。 */public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; // 🔻 将负载因数赋为默认值。 this.loadFactor = DEFAULT_LOAD_FACTOR; // 🔻 调用putMapEntries()，将原有map存入新map。 putMapEntries(m, false);&#125; - putMapEntries() 赋值并初始化函数/** * Implements Map.putAll and Map constructor. * 赋值并构造函数。 * * @param m the map * @参数： m，传入的map * @param evict false when initially constructing this map, else true (relayed to method afterNodeInsertion). * @参数： evict，首次创建此map时返回false，非首次创建返回true。 */final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) &#123; int s = m.size(); // m的元素个数 // 🔴 一、若m中有元素，需要根据新Map的初始化情况为其临界值赋值。 （若m无元素则无需赋值，直接使用给定的负载因数和临界值(lf*cap)完成构造。） if (s &gt; 0) &#123; // 🔹 若数组未初始化：根据m中元素数量和负载因数计算新Map的临界值。 if (table == null) &#123; // pre-size // m的临界值 = 元素数量 / 负载因数（🔸+1.0F：对小数做向上取整以尽可能保证更大容量） float ft = ((float)s / loadFactor) + 1.0F; // 将m临界值的数据类型转为整型，并限定在默认容量上限内 int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ? (int)ft : MAXIMUM_CAPACITY); // 若计算出m的临界值 &gt; 新Map临界值，调用tableSizeFor方法，将新Map临界值设置为：该值最接近容量的2次幂数。 if (t &gt; threshold) threshold = tableSizeFor(t); &#125; // 🔹 若数组已初始化、且Map中的元素数量超过了其临界值：扩容。 else if (s &gt; threshold) resize(); // 🔴 二、赋值：遍历m的entry，逐个赋值到新Map上。 for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123; K key = e.getKey(); V value = e.getValue(); // 🔹 调用putVal()为每个节点赋值（此时新Map才真正初始化完成） putVal(hash(key), key, value, false, evict); &#125; &#125;&#125; ((float)s / loadFactor) + 1.0F + 1.0F：为了让浮点数进行除法计算后向上取整，以尽可能保证足够容量。 - putVal() 赋值方法 /** * Implements Map.put and related methods. * 实现了Map赋值以及相关方法。 * * @param hash key的hash值 * @param key key值 * @param value 需要赋的值 * @param onlyIfAbsent 是否保留原值（默认为false：会替换原值） * @param evict false:表处于创建状态 * @return 返回前值，如果没有则为空 */final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; // Node数组 Node&lt;K,V&gt; p; // Node int n, i; // n：数组长度， i：数组索引 // 🔴 一、若空数组：初始化 // 当数组为空、长度为0时：扩容，并获得Node数组长度n（容量） if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 🔴 二、若空索引：直接存 // 若传入的key计算出的索引位置无元素，则使用键值对在该位置上创建Node，putVal()完成。 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); // 🔴 三、若索引非空：根据情况存值 // 可能有hash冲突，判断该Node是否为链表或红黑树进行存值。 else &#123; Node&lt;K,V&gt; e; // node K k; // key // 🔹 若p刚好在当前索引位置的第一个节点上（未涉及到链表或红黑树），将该Node赋值给e以备存值（当前Node的key值和传入的key值相等） if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // 🔹 TreeNode类型：通过putTreeVal()方法在红黑树上插入键值对，赋值给e以备存值。 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 🔹 链表类型：循环直到将元素插入链表尾部，赋值给e以备存值。 else &#123; for (int binCount = 0; ; ++binCount) &#123; // 🔸 若已遍历到链表尾部：在尾部再添加一个新节点并存值。 if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); // * 若添加节点后链表的长度超过树化阈值： // 通过treeifyBin()将链表转化为红黑树，跳出循环，putVal()完成。 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; // 🔸 若还未遍历到尾部、且该节点的key值与传入key值相等： // 则跳出循环，执行下方替换原值的判断。 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; // 🔸 继续循环遍历链表 p = e; &#125; &#125; // 🔻 替换并输出原值 if (e != null) &#123; // existing mapping for key V oldValue = e.value; // 若设置了替换原值、或原值为空时：存值 if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); // 访问后回调（❓ return oldValue; &#125; &#125; ++modCount; // 记录修改次数（方便在迭代中检测结构性变化） // 若存值后数组长度大于扩容阈值，则扩容。 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); // 插入后回调（❓ return null;&#125; 比较时先比较hash值，hash相同的时候，再使用equals方法进行比较： if(e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) 因为hash是整数，比较的性能一般要比equals()高很多，使用短路与：hash不同，就没有必要调用equals方法了，这样整体上可以提高比较性能。 3. 实现方法（1）Get()- get() 通过key获取value/** * Returns the value to which the specified key is mapped, * or null if this map contains no mapping for the key. * 返回指定key所映射的value值。若找不到对应value时返回null。 * * 但返回null不一定代表不存在该key映射的值，有可能是该key保存的value值正是&quot;null&quot;。 * 可以使用containsKey()来识别。 */public V get(Object key) &#123; // Node Node&lt;K,V&gt; e; // 🔻 使用key和其hash值调用getNode()方法，返回Node的value值。 return (e = getNode(hash(key), key)) == null ? null : e.value;&#125; null ? null : e.value：若该值为null，返回null；若该值不为null，返回e.value - getNode() 获取Node/** * Implements Map.get and related methods. * 实现了Map.get()和相关方法 * * @param hash key的hash值 * @param key key * @return 返回该key对应的Node，若无返回null */final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; // Node数组 Node&lt;K,V&gt; first, e; // Node int n; // 数组长度 K k; // key // 🔻 判断该数组非空 // 并根据传入key的hash值计算出该hash值对应的Node的下标，将该数组下标对应的值赋值给first-Node（意为hash冲突时第一个节点） if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; // 🔹 先判断若first刚好是我们要找的Node时：直接返回first if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; // 🔹 当first尾部还有元素（即有hash冲突）时，根据Node的结构取值。 if ((e = first.next) != null) &#123; // 🔸 红黑树：将Node转为TreeNode类型，并调用getTreeNode()取值。 if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); // 🔸 链表：遍历取值。 do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; // 🔻 数组为空，返回null return null;&#125; （2）Delete()- delete() 删除元素 /** * Removes the mapping for the specified key from this map if present. * 根据指定key删除映射。 * * @param key 要从map中删除映射的键 * @return 返回与键关联的前值，若前值为空返回null */public V remove(Object key) &#123; Node&lt;K,V&gt; e; // 🔻 调用removeNode()删除该键映射，若前值为空返回null，若前值非空返回前值。 return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value;&#125; - removeNode() 删除Node /** * Implements Map.remove and related methods. * 实现删除map和相关方法。 * * @param hash key的hash值 * @param key key * @param value 若有值时匹配该值 * @param matchValue 若为真：仅值相等时删除 * @param movable 为false:删除时不移动其他值 * @return 返回Node，无时返回null */final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) &#123; Node&lt;K,V&gt; node = null, e; K k; V v; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) node = p; else if ((e = p.next) != null) &#123; if (p instanceof TreeNode) node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key); else &#123; do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; node = e; break; &#125; p = e; &#125; while ((e = e.next) != null); &#125; &#125; if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) &#123; if (node instanceof TreeNode) ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable); else if (node == p) tab[index] = node.next; else p.next = node.next; ++modCount; --size; afterNodeRemoval(node); return node; &#125; &#125; return null;&#125; （3）put() 添加元素 （4）resize() 扩容 4. 内部类（2）TreeNode+ 内部类TreeNode TreeNode继承自LinkedHashMap.Entry类。 红黑树结构的属性和构造方法：static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123; // 父节点 TreeNode&lt;K,V&gt; parent; // red-black tree links // 左节点 TreeNode&lt;K,V&gt; left; // 右节点 TreeNode&lt;K,V&gt; right; // 前节点：删除时需要取消链接&quot;next&quot; TreeNode&lt;K,V&gt; prev; // needed to unlink next upon deletion // 颜色：true红色；false黑色 boolean red; // 构造方法，参数：hash值、key、value、下一个Node节点 TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) &#123; super(hash, key, val, next); &#125; // ...&#125; - getTreeNode() 获取红黑树节点 /** * Calls find for root node. * 调用查找根节点 */final TreeNode&lt;K,V&gt; getTreeNode(int h, Object k) &#123; // 🔻 调用find()查找节点 return ((parent != null) ? root() : this).find(h, k, null); // 若根节点不为空，调用root节点查找；若根节点为空，使用this查找。&#125; - find() 获取红黑树 /** * Finds the node starting at root p with the given hash and key. The kc argument caches comparableClassFor(key) upon first use comparing keys. * 使用给定的key和hash值查找从根p开始的节点。 */final TreeNode&lt;K,V&gt; find(int h, Object k, Class&lt;?&gt; kc) &#123; TreeNode&lt;K,V&gt; p = this; // 当前树形Node：p // 遍历整树： do &#123; int ph, dir; K pk; TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q; // 当前Node左节点、右节点、 // 若当前节点hash值较大：p取其左节点 if ((ph = p.hash) &gt; h) p = pl; // 若当前节点hash值较小：p取其右节点 else if (ph &lt; h) p = pr; // 若当前节点key值等于给定key值，返回当前节点 else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk))) return p; // 若左节点为空，p取其右节点 else if (pl == null) p = pr; // 若右节点为空，p取其左节点 else if (pr == null) p = pl; // 根据compareTo比较 else if ((kc != null || (kc = comparableClassFor(k)) != null) &amp;&amp; (dir = compareComparables(kc, k, pk)) != 0) p = (dir &lt; 0) ? pl : pr; // 根据compareTo的结果，若右节点能找到：返回右节点 else if ((q = pr.find(h, k, kc)) != null) return q; // 若compareTo的结果在左节点上：继续查找 else p = pl; &#125; while (p != null); return null;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://equnee.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://equnee.github.io/tags/Java/"},{"name":"HashMap","slug":"HashMap","permalink":"https://equnee.github.io/tags/HashMap/"},{"name":"TreeNode","slug":"TreeNode","permalink":"https://equnee.github.io/tags/TreeNode/"}]},{"title":"🌷 设计模式 - 责任链","slug":"note/Design-pattern/design-pattern_Chain","date":"2023-03-08T15:14:10.467Z","updated":"2023-03-08T15:18:36.714Z","comments":true,"path":"note/Design-pattern/design-pattern_Chain/","link":"","permalink":"https://equnee.github.io/note/Design-pattern/design-pattern_Chain/","excerpt":"","text":"来自《秒懂设计模式》","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://equnee.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://equnee.github.io/tags/Java/"},{"name":"Chain","slug":"Chain","permalink":"https://equnee.github.io/tags/Chain/"}]},{"title":"🌷 设计模式 - 单例","slug":"note/Design-pattern/design-pattern_Singleton","date":"2023-03-07T17:32:40.177Z","updated":"2023-03-08T15:26:08.159Z","comments":true,"path":"note/Design-pattern/design-pattern_Singleton/","link":"","permalink":"https://equnee.github.io/note/Design-pattern/design-pattern_Singleton/","excerpt":"","text":"来自《秒懂设计模式》 一. 孤独的太阳我们可以把太阳系看作一个庞大的系统，其中有各种各样的对象存在，丰富多彩的实例造就了系统的美好。这个系统里的某些实例是唯一的，如我们赖以生存的恒星太阳。 与其他行星或卫星不同的是，太阳是太阳系内唯一的恒星实例。但倘若天上有9个太阳，那么将会带来一场灾难。太阳不多不少仅此一例。 二. 饿汉造日%%{ init: { 'themeVariables': { 'fontSize': '22px', 'fontFamily': 'Noto Serif SC' } } }%% graph LR T((\"饿汉造日\")):::b T --> A([\"1. 开始\"]):::p T --> B([\"2. 构造方法私有化\"]):::p T --> C([\"3. 自有永有\"]):::p T --> D([\"4. 公开访问\"]):::p T --> E([\"5. 总结\"]):::b A --> a(\"既然太阳系里只有一个太阳，就需要严格把控太阳实例化的过程。\"):::lp a -.-> at([\"Public class Sun {} // 一个最简单的Sun类\"]):::lg B --> b(\"太阳只有一个，不能随意创建实例。但由于Java会自动生成一个无参构造器，因此必须禁止外部调用构造器*。\"):::lp b -.-> bt([\"private Sun(){}\"]):::lg C --> c(\"让它在类加载时就自己创建自己，并使其自有永有\"):::lp c -.-> ct([\"private static final Sun sun = new Sun();\"]):::lg D --> d(\"使用静态方法*getInstance()来获取太阳的单例对象并将其设置为“public”以暴露给外部使用\"):::lp d -.- dt([\"public static Sun getInstance(){ return sun; }\"]):::lg d -.- d2t[\"*如同程序入口的静态方法main(), 不需要任何对象引用就能被访问\"]:::info T -..-> e(\"（还可以添加其他功能方法，如发光和发热等）\"):::info d --> et(\"最后，不管谁得到或得到几次，得到的都是同一个太阳实例，这样就确保了整个太阳系中恒星太阳的唯一合法性，他人无法伪造。\"):::lb E --> e2t(\"这就是“饿汉模式”(eager initialization)：即在初始阶段(static)就主动进行实例化，并时刻保持一种渴求的状态(public)，无论此单例是否有人使用。\"):::lb classDef p fill:#ddaebd classDef b fill:#aab7d2 classDef lp fill:#f4e4e9 classDef lb fill:#d9dfeb classDef lg fill:#cde2da classDef info fill:#f6f6f7,color:#5a5a5f,stroke-dasharray: 3 3, stroke-width: 2px 1. 开始 public class Sun &#123;&#125; 2. 构造方法私有化 接下来我们得确保任何人都不能创建太阳的实例，否则一旦程序员调用代码“new Sun()”，天空就会出现多个太阳，便又需要“后羿”去解决了。 实例化工作完全归属于内部事务，任何外部类都无权干预 public class Sun &#123; private Sun()&#123; // 构造方法私有化 &#125; &#125; 3. 自有永有 public class Sun &#123; private static final Sun sun = new Sun(); // 自有永有的太阳单例 private Sun()&#123; // 构造方法私有化 &#125; &#125; 关键字 说明 private 确保太阳实例的私有性、不可见性和不可访问性； static 确保太阳的静态性，将太阳放入内存里的静态区，在类加载的时候就初始化了，它与类同在，也就是说它是与类同时期且早于内存堆中的对象实例化的，该实例在内存中永生，内存垃圾收集器(Garbage Collector, GC)也不会对其进行回收； final 确保这个太阳是常量、恒量，它是一颗终极的恒星，引用一旦被赋值就不能再修改； new 初始化太阳类的静态实例，并赋予静态常量sun。 4. 公开访问 单例的太阳对象写好了，可一切皆是私有的，外部如何访问？—— 使用静态方法getInstance()来获取太阳的单例对象。 public class Sun &#123; private static final Sun sun = new Sun(); // 自有永有的太阳单例 private Sun()&#123; // 构造方法私有化 &#125; public static Sun getInstance()&#123; // 阳光普照，方法公开化 return sun; &#125; &#125; 三. 懒汉的队伍%%{ init: { 'themeVariables': { 'fontFamily': 'Noto Serif SC' } } }%% graph LR T((懒汉的队伍)):::b T --> A([\"1. 用时才创建\"]):::p T --> B([\"2. 排队（同步锁）\"]):::p T --> C([\"3. 需要时再排队（双检锁）\"]):::p A --> a(\"若无请求就不实例化，节省内存空间\"):::lp a -.-> at([\"去掉 finalif(sun == null)\"]):::lg B --> b(\"由于多线程时的缺陷：请求方法加上同步锁synchronized\"):::lp b -.- bt2([\"public static synchronized Sun getInstance() \"]):::lg b -.-> bt3(\"加锁后某线程调用前必须获取同步锁，调用完会释放锁给其他线程用，也就是给请求排队。\"):::info C --> c(\"为了解决线程阻塞：使用2个嵌套的判空逻辑\"):::lp c -.- ct([\"private volatile static Sun sun;if(sun = null){ synchronized(){if(sun == null){sun = new Sun();}\"]):::lg c -.- ct2[\"1. 外层放宽入口，保证线程并发的高效性2. 内层加锁同步，保证实例化的单次运行\"]:::info classDef p fill:#ddaebd classDef b fill:#aab7d2 classDef lp fill:#f4e4e9 classDef lb fill:#d9dfeb classDef lg fill:#cde2da classDef info fill:#f6f6f7,color:#433f40,stroke-dasharray: 3 3, stroke-width: 2px 1. 用时才创建 单例的“饿汉模式”，让太阳一开始就准备就绪，随时供应免费日光。 然而，如果始终没人获取日光，那就白造了太阳，白白浪费一块内存区域。类似于商家货品滞销的情况，货架上堆放着商品却没人买，白白浪费空间。因此，商家为了降低风险，规定有些商品必须提前预订，这就是“懒汉模式”(lazy initialization)。 public class Sun &#123; private static Sun sun; // 这里不进行实例化 private Sun()&#123; // 构造方法私有化 &#125; public static Sun getInstance() &#123; if(sun == null) &#123; // 如果无日才造日 sun = new Sun(); &#125; return sun; &#125;&#125; 关键字 说明 去掉 final 一开始并没有造太阳，所以去掉了关键字final。 用时才实例化 仅在某线程第一次调用第9行的getInstance()方法时才会运行对太阳进行实例化的逻辑代码，之后再请求就直接返回此实例了。❗️缺点：初次请求时速度较之前的饿汉初始化模式慢，因为要消耗CPU资源去临时造这个太阳。 2. 排队 因为上述程序在多线程模式下有缺陷：并发请求时判空逻辑会同时成立，导致多次实例化太阳、多次赋值，违背单例理念。 public class Sun &#123; private static Sun sun; // 这里不进行实例化 private Sun()&#123; // 构造方法私有化 &#125; public static synchronized Sun getInstance() &#123; // 此处加入同步锁 if(sun == null) &#123; // 如果无日才造日 sun = new Sun(); &#125; return sun; &#125;&#125; 关键字 说明 synchronized 将太阳类Sun中第9行的getInstance()改成了同步方法，如此可避免多线程陷阱。 3. 需要时再排队 如果仅为了实例化一个单例对象，直接加锁排队,使用synchronized让所有请求排队等候：会造成线程阻塞，资源与时间被白白浪费。 public class Sun &#123; private volatile static Sun sun; private Sun() &#123; // 构造方法私有化 &#125; public static Sun getInstance() &#123; // 华山入口 if(sun = null)&#123; synchronized(Sun.class)&#123; // 观日者进行排队 if(sun == null)&#123; sun = new Sun(); // 只有排头兵造了太阳，旭日东升 &#125; &#125; &#125; return sun; // ……阳光普照，其余人不必再造日 &#125;&#125; 关键字 说明 去掉 final 第3行对sun变量的定义不再使用final关键字，说明它不再是常量，而是需要后续赋值的变量； volatile 关键字volatile对静态变量的修饰则能保证sun变量值在各线程访问时的同步性、唯一性。 去掉入口的同步锁 对于第9行的getInstance()方法，去掉方法上的关键字synchronized，使大家都能同时进入方法并对其进行开发。 判空逻辑1 有些人（线程）起早就是为了观看日出，那么这些人会通过第10行的判空逻辑进入观日台。 判空逻辑2 在第12行我们又进行一次判空逻辑，这就意味着只有队伍中的第一个人造了太阳，有幸看到了日出的第一缕阳光，而后面的人则统统离开，直到第17行得到已经造好的太阳。 最后：太阳高高升起，实例化操作完毕，起晚的人们都无须再进入观日台，直接获取太阳实例即可，温暖阳光普照大地。 四. 大道至简相比“懒汉模式”，其实更常用“饿汉模式”，因为这个单例迟早是要被实例化占用内存的，延迟懒加载的意义并不大，加锁解锁反而是一种资源浪费，同步更是会降低CPU的利用率，使用不当的话反而会带来不必要的风险。越简单的包容性越强，而越复杂的反而越容易出错。 单例模式的类结构： classDiagram class Singleton{ - instance : singleton - Sigleton() + getInstance() Singleton } Singleton --> Singleton Singleton（单例）：包含一个自己的类实例的属性，并把构造方法用privat关键字隐藏起来，对外只提getInstance()方法以获得这个单例对象。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://equnee.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://equnee.github.io/tags/Java/"},{"name":"singleton","slug":"singleton","permalink":"https://equnee.github.io/tags/singleton/"}]},{"title":"Mac远程连接Windows（Microsoft Remote Desktop）","slug":"guide/mac_mrd_windows","date":"2021-03-25T07:49:07.000Z","updated":"2023-03-07T18:09:04.157Z","comments":true,"path":"guide/mac_mrd_windows/","link":"","permalink":"https://equnee.github.io/guide/mac_mrd_windows/","excerpt":"","text":"摘要: 同时带两台电脑出门很麻烦，于是选择在Mac上使用 Microsoft Remote Desktop 远程连接使用不带出门的 Windows，从此只需要把Windows放在家里连接电源和wifi一直放着就行！顺便整理了一些别人遇到的错误和解决方法。 日期: 2021/3/25 环境 : MacOS 11.2.2 + Windows10 一. 软件下载下载 Microsoft Remote Desktop，根据情况下载对应版本的app： 使用 Windows 控制 windows：&gt;&gt; 官网下载 使用 Mac 控制 windows： App Store 下载，仅国外的应用商店提供下载，因此只能使用国外的 AppleID，可参考&gt; &gt; 国外AppleID申请方法。 其他渠道下载（俺也没试过 二. 创建连接2.1 Windows 配置 首先确保将被控制的 Windows 开启了远程桌面连接配置： （1）系统属性 设置了系统属性为允许远程桌面连接 若选项都是灰色无法允许远程连接，&gt; 参考这里。 运行 gpedit.msc 回车打开本地组策略编辑器,在左侧的列表中依次展开：计算机配置&gt;管理模板&gt;Windows组件&gt;远程桌面会话主机&gt;连接 双击打开右侧的”允许用户通过使用远程桌面服务进行远程连接“,看一下之前是否有配置,如果有的话改成”未配置”,如果之前就是未配置,那可以改成已启用,然后您再看一下系统属性&gt;远程桌面中的相关设置区域是否恢复正常. （2）防火墙 设置了防火墙允许远程桌面通过防火墙通信 （3）端口 开启了用于远程桌面连接的服务端口： 在cmd中输入netstat -aon|findstr 3389，查看默认端口号3389是否开启。 若端口号未开启：打开任务管理器，开启下面两项服务。（UmRdpServise可播放声音) 若修改过或无法查询到3389端口，&gt; 参考这里。 （4）本地策略 设置本地策略非来宾。在运行中输入：gpedit.msc （5）关闭 Windows hello 确保关闭了设置内 仅允许 Windows hello 登录 (未设置可忽略。) Windows Hello：使您可以使用脸部，虹膜，指纹或PIN登录设备，应用程序，在线服务和网络。 （6）AAD 确保不是通过 Microsoft Authenticator ，而是通过手动输入密码进行验证登录的： 因为 Microsoft Authenticator 登录使用的认证方式与其他域不互通，就不能直接开启连接啦。 2.2 添加计算机 配置Windows允许远程桌面连接后，使用Mac准备开始连接，在Microsoft Remote Desktop中添加PC，输入主机名 + 用户账号信息。 PC name：IP地址。 查看方法：在 Windows 的命令提示符(win+R 键打开的运行窗口输入cmd) 输入命令 ipconfig，可查看ipv4地址。 User account：登录该PC的账号密码。建议选择 Ask when required，先不输入账号密码，在连接时输入，确保能连接成功后再添加记录，防止这里保存的账号密码有误，后面怎么都连不上。 2.3 填写账户信息（1） 本地用户 使用本地用户名登录： 本地用户名(cmd输入 whoami 查看) + 本地解锁密码。 （2） 微软账户 使用微软账户登录： 本地创建的英文账户若关联了微软账号，可使用该微软账号邮箱进行远程登录，用户名为邮箱格式的微软账号(username@outlook.com) + 对应的微软账号密码。 （3） 空密码 或使用空密码进行远程桌面连接：在 windows 中设置 打开运行，输入gpedit.msc，打开本地组策略编辑器 2.4 报错解决（1） The User Account Did Not work 🔒 提示：The User Account Did Not Work.The user account used to connect to xx.xx.xx.xx (remote PC) did not work. Try again.（–&gt; 你输的这个账户信息连不上。） 🔑 解决方法：需要输入正确的账号密码。 微软账号登录：邮箱格式的微软账号(username@outlook.com) + 对应的微软账号密码 本地用户登录：本地主机名或本地账户名 + 本地账户解锁密码 以前可以，现在突然连不上了：检查上面两个密码是不是改过了，如果改过记得同步修改。 （2） 0x204 🔒 连接时提示：We couldn’t connect to the remote PC.Make sure the PC is turned on and connected to the network, and thar remote access is enabled. Error code:0x204（–&gt; 我们无法连接到远程电脑，确保电脑已打开并连接到网络，并且已启用远程访问。） 🔑 解决方法： 开电脑。检查是否打开windows电源，确保非关机或睡眠状态，开启电源解锁屏幕就可以啦。 连Wi-Fi。 开服务。确保已开启 Windows 的远程桌面连接配置。 （3） 0x207 🔒 提示： 🔑：确保windows的本地组策略不是 仅来宾 状态。 三. Mac配置3.1 创建目录 在mac电脑上，根据需要创建用于文件传输的目录。 3.2 编辑配置 开启Microsoft Remote Desktop 软件，点击编辑。 如图所示，添加重定向刚创建的文件夹对应的路径 3.3 完成 可查看windows上的文件夹映射，没出现的话重新连接试试。 四. 结尾第一次完成mac和windows之间远程桌面的配置，回头看感觉写得有些复杂，因为多记录了一些自己也没遇到过的问题和情况。如果各位还遇到了文中没提到的情况，欢迎评论留言，我会继续补充～","categories":[],"tags":[{"name":"windows","slug":"windows","permalink":"https://equnee.github.io/tags/windows/"},{"name":"Mac","slug":"Mac","permalink":"https://equnee.github.io/tags/Mac/"}]},{"title":"超棒的文档神器搭档！Markdown+ Mermaid","slug":"tool/markdown+mermaid","date":"2020-04-01T16:37:51.048Z","updated":"2023-03-08T21:00:28.270Z","comments":true,"path":"tool/markdown+mermaid/","link":"","permalink":"https://equnee.github.io/tool/markdown+mermaid/","excerpt":"","text":"用了就会爱上 一. Markdown1. 为什么用 MarkdownTypora 2. Markdown 用法 二. Mermaid 在线体验：https://mermaid.live/ 1. 为什么用 Mermaid 我喜欢把一段较复杂的文字加工成一张直观的图像，我认为画图是一种理解知识、并将其转化和吸收的过程。而在配合 Markdown 写笔记时，最让我觉得头疼的就是如何以最省时省力的方式配图。我做过很多尝试：如，手绘、使用Xmind导图软件、ProcessOn之类的在线绘图工具等。但它们都有最显著的缺点：最终以图像形式导入文档，因此修改和导出非常繁琐。 而 Mermaid 对我来说是一个说近乎完美的方案！ 高效易用 它直接在 Markdown 中以代码段的形式创建和修改图表，并实时渲染为 Svg 视图，可以高效制作简易的流程图。并且随时修改、立即可见。 它和 Markdown 一样都是纯文本格式存储的语言，易于保存和分享。 Web友好 它不受制于特定编辑器，大部分支持 Markdown 的编辑器都支持 Mermaid。 它基于 Javascript，可集成嵌入前端框架，如 Vue、Hexo等。 2. Mermaid 用法Mermaid 可绘制流程图、时序图、Git图、类图、饼图、甘特图等图表，详细可查阅 官方文档。下面是我常用的两个流程图模版（配色）示例： 基础（使用基本样式） graph LR T((\"Title\")):::p T ==> A([\"Pink\"]):::p T --> B([\"Green\"]):::g T --> C([\"Blue\"]):::b A -.-> a(\"light Pink\"):::lp B -.-> b(\"light Green\"):::lg C -.-> c(\"light Blue\"):::lb a -.- info[\"Info\"]:::info classDef p fill:#ddaebd classDef b fill:#aab7d2 classDef g fill:#9ac5bb classDef lp fill:#f4e4e9 classDef lb fill:#d9dfeb classDef lg fill:#ddebe6 classDef info fill:#f6f6f7,color:#737379,stroke-dasharray: 3 3, stroke-width: 2px graph LR T((&quot;Title&quot;)):::p T ==&gt; A([&quot;Pink&quot;]):::p T --&gt; B([&quot;Green&quot;]):::g T --&gt; C([&quot;Blue&quot;]):::b A -.-&gt; a(&quot;light Pink&quot;):::lp B -.-&gt; b(&quot;light Green&quot;):::lg C -.-&gt; c(&quot;light Blue&quot;):::lb a -.- info[&quot;Info&quot;]:::info%% 样式： style T color:#fff classDef p fill:#ddaebd classDef b fill:#aab7d2 classDef g fill:#9ac5bb classDef lp fill:#f4e4e9 classDef lb fill:#d9dfeb classDef lg fill:#ddebe6 classDef info fill:#f6f6f7,color:#737379,stroke-dasharray: 3 3, stroke-width: 2px 进阶（使用预加载样式） %%{ init: { 'themeVariables': { 'fontFamily': 'Noto Serif SC', 'mainBkg': '#f4e4e9', 'edgeLabelBackground': '#ddebe6' } } }%% graph TD T((\"Title\")):::pink T --> A A -.-> |\"text2\"| B subgraph \"subgraph\" A --> |\"text3\"|C:::lb end classDef pink fill:#ddaebd style B fill:#d9dfeb, stroke:#657eae,stroke-width:3px,stroke-dasharray: 5 3 %%&#123; init: &#123; &#x27;themeVariables&#x27;: &#123; &#x27;fontFamily&#x27;: &#x27;Noto Serif SC&#x27;, &#x27;mainBkg&#x27;: &#x27;#f4e4e9&#x27;, &#x27;edgeLabelBackground&#x27;: &#x27;#ddebe6&#x27; &#125; &#125;&#125;%%graph TDT((&quot;Title&quot;)):::pinkT --&gt; AA -.-&gt; |&quot;text2&quot;| Bsubgraph &quot;subgraph&quot;A --&gt; |&quot;text3&quot;|C:::lbendclassDef pink fill:#ddaebdstyle B fill:#d9dfeb, stroke:#657eae,stroke-width:3px,stroke-dasharray: 5 3 3. Hexo + Mermaid 插件 代码仓库: https://github.com/webappdevelp/hexo-filter-mermaid-diagrams （1）安装插件$ yarn add hexo-filter-mermaid-diagrams 或 $ npm install hexo-filter-mermaid-diagrams （2）编辑配置安装完成后，编辑hexo配置文件：config.yml # mermaid chartmermaid: enable: true version: &quot;7.1.2&quot; options: （3）添加脚本修改完配置文件后，编辑博客页面组件的footer部分。这是为了将 mermaid.js 以 script 形式插入到 html 尾部，使其能正常渲染。 footer文件如，footer.pug， after_footer.pug , after-footer.ejs 或 swig，该文件通常存放在主题目录下的layout目录中。 若博客使用pug模版引擎渲染，在 after_footer.pug文件中添加如下代码: if theme.mermaid.enable == true script(type=&#x27;text/javascript&#x27;, id=&#x27;maid-script&#x27; mermaidoptioins=theme.mermaid.options src=&#x27;https://unpkg.com/mermaid@&#x27;+ theme.mermaid.version + &#x27;/dist/mermaid.min.js&#x27; + &#x27;?v=&#x27; + theme.version) script. if (window.mermaid) &#123; var options = JSON.parse(document.getElementById(&#x27;maid-script&#x27;).getAttribute(&#x27;mermaidoptioins&#x27;)); mermaid.initialize(options); &#125; 若使用ejs引擎渲染，则在after-footer.ejs文件中添加如下代码： &lt;% if (theme.mermaid.enable) &#123; %&gt; &lt;script src=&#x27;https://unpkg.com/mermaid@&lt;%= theme.mermaid.version %&gt;/dist/mermaid.min.js&#x27;&gt;&lt;/script&gt; &lt;script&gt; if (window.mermaid) &#123; mermaid.initialize(&#123;theme: &#x27;neutral&#x27;&#125;); &#125; &lt;/script&gt;&lt;% &#125; %&gt; swig模版引擎： &#123;% if theme.mermaid.enable %&#125; &lt;script src=&#x27;https://unpkg.com/mermaid@&#123;&#123; theme.mermaid.version &#125;&#125;/dist/mermaid.min.js&#x27;&gt;&lt;/script&gt; &lt;script&gt; if (window.mermaid) &#123; mermaid.initialize(&#123;&#123; JSON.stringify(theme.mermaid.options) &#125;&#125;); &#125; &lt;/script&gt;&#123;% endif %&#125; （4）踩坑以上为官方文档中的配置方法，而我在初次配置的过程中，还遇到以下问题可供参考： html页面中，mermaid段落仅显示为代码块，开发者工具中该段落为普通源代码。 这是因为插件没有生效，应确保正确完成上面两个步骤（安装插件、打开配置）。 html页面中，mermaid段落显示为空白图片，开发者工具中查看该段落为svg文件，控制台报错： Uncaught TypeError: Cannot read properties of null (reading’mermaid’)。 此时插件已经生效，而js代码文件引入有误，无法成功渲染。 继续查看html代码发现，文件底部的&lt;sctipt&gt;标签中，显示我引入mermaid的url为： &lt;script type=&quot;text/javascript&quot; id=&quot;maid-script&quot; src=&quot;https://unpkg.com/mermaid@10.0.2/dist/mermaid.min.js?v=undefined&quot;&gt;&lt;/script&gt; 这段代码是由官方提供的脚本、在footer文件中根据用户的配置组合成的： script(type=&#x27;text/javascript&#x27;, id=&#x27;maid-script&#x27; mermaidoptioins=theme.mermaid.options src=&#x27;https://unpkg.com/mermaid@&#x27;+ theme.mermaid.version + &#x27;/dist/mermaid.min.js&#x27; + &#x27;?v=&#x27; + theme.version) 如果配置有误则会生成错误的url，看起来是version的问题，于是我将url改为直接引入jsdelivr上的资源，遂能正常渲染： src=&#x27;https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js&#x27;)","categories":[{"name":"工具","slug":"工具","permalink":"https://equnee.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Mermaid","slug":"Mermaid","permalink":"https://equnee.github.io/tags/Mermaid/"},{"name":"Markdown","slug":"Markdown","permalink":"https://equnee.github.io/tags/Markdown/"}]}],"categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://equnee.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"设计模式","slug":"设计模式","permalink":"https://equnee.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"工具","slug":"工具","permalink":"https://equnee.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://equnee.github.io/tags/Java/"},{"name":"HashMap","slug":"HashMap","permalink":"https://equnee.github.io/tags/HashMap/"},{"name":"TreeNode","slug":"TreeNode","permalink":"https://equnee.github.io/tags/TreeNode/"},{"name":"Chain","slug":"Chain","permalink":"https://equnee.github.io/tags/Chain/"},{"name":"singleton","slug":"singleton","permalink":"https://equnee.github.io/tags/singleton/"},{"name":"windows","slug":"windows","permalink":"https://equnee.github.io/tags/windows/"},{"name":"Mac","slug":"Mac","permalink":"https://equnee.github.io/tags/Mac/"},{"name":"Mermaid","slug":"Mermaid","permalink":"https://equnee.github.io/tags/Mermaid/"},{"name":"Markdown","slug":"Markdown","permalink":"https://equnee.github.io/tags/Markdown/"}]}