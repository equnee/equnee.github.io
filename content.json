{"meta":{"title":"PEACH","subtitle":"蜜桃","description":"equne","author":"equne","url":"https://equnee.github.io","root":"/"},"pages":[{"title":"One","date":"2021-07-25T09:07:39.345Z","updated":"2020-07-11T17:32:48.000Z","comments":true,"path":"wp-java/one.html","permalink":"https://equnee.github.io/wp-java/one","excerpt":"","text":"testLink hey"},{"title":"面向对象 - 方法重载","date":"2021-07-25T09:07:39.351Z","updated":"2020-07-12T17:27:31.000Z","comments":true,"path":"wp-java/zero/12_Object_oriented-Override.html","permalink":"https://equnee.github.io/wp-java/zero/12_Object_oriented-Override","excerpt":"","text":"Override 方法重载123456789// (一) 正常调用带参数方法：必须传入参数 / 参数类型必须一致// (二) ↓ 可传可不传 / 传入类型可不同 （10种可选）System.out.println(); System.out.println(&quot;peach&quot;); System.out.println(&quot;1&quot;); System.out.println(&#x27;a&#x27;); System.out.println(true); System.out.println(to); //TestOverload@34e45f ——&gt; hashCode码 //当前元素的数据类型 @ 地址（int形式/十六进制） println(); ——&gt; 方法，属于out对象 为什么参数可以传也可以不传？ 不是一个方法：是1个方法，名字一致，参数都不一样 定义 定义：一个类中的一组方法 相同的方法名字，不同的参数列表，这样的一组方法构成了方法重载。 参数列表的不同体现在哪里？参数的个数 / 参数的类型 / 参数的顺序 1boolean int / int boolean //参数顺序不同 作用：为了让使用者便于记忆与调用，只需要记录一个名字，执行不同的操作 可自己设计方法重载 调用方法的时候，首先通过方法名字定位方法 方法名字一致，通过参数的数据类型定位方法 若没有与传递参数类型一致的方法 —— 可以找一个参数类型，进行自动类型转换 方法的返回值和修饰符与方法重载没什么关系 例子1234567891011121314151617181920212223242526272829303132package function_Overload;public class testOverload &#123; public void test() &#123; System.out.println(&quot;执行了test方法不带参数：&quot;); &#125; public void test(boolean flag) &#123; System.out.println(&quot;执行了test方法带boolean的参数：&quot;+flag); &#125; public void test(int i ) &#123; System.out.println(&quot;执行了test方法带int的参数：&quot;+i); &#125; public void test(String s ) &#123; System.out.println(&quot;执行了test方法带String的参数：&quot;+s); &#125;// public void test(char c ) &#123;// System.out.println(&quot;执行了test方法带char的参数：&quot;+c);// &#125; public static void main(String[] args) &#123; //1. 创建对象 testOverload to = new testOverload(); //2. 无重载方法：通过对象调用方法 —— 可以直接通过方法名字定位方法 // 重载方法：如果方法名字一致 —— 通过方法的参数列表类型 来定位方法 to.test(); //可传入多种参数 to.test(&#x27;a&#x27;); //方法参数传递 类型之间的转化问题 —— char转int：自动类型转换 to.test((char)97); //类型转化：可强制类型转换 &#125;&#125; 新写法：动态参数列表 jdk1.5+ 动态参数列表 参数类型固定 参数个数动态（ 0个 - n个） 底层本质——数组，有length属性，有[index] 动态参数列表的方法 不能与相同意义的数组类型方法构成方法重载 —— 本质是一样的 与数组区别：动态参数列表的方法，可以不传参数，相当于0个。数组类型的方法必须传参数。 动态参数列表在方法的参数中只能存在一份，且必须放置在方法参数的末尾👇 123456789101112131415161718192021222324252627282930package function_Overload;public class testOverride_dynamicParameter &#123; public void test(int...x)&#123;//本质——数组 int[] x = &#123;1，2，3，4，5，6&#125; System.out.println(&quot;执行了test方法携带动态列表&quot;+x); for(int i=0;i&lt;x.length;i++) &#123; System.out.println(x[i]); &#125; &#125; public void test() &#123; System.out.println(&quot;执行了test方法不带参数：&quot;); &#125; //------------------------------------------------------------ // public void test(int[] array) &#123; &#125; //不可以 //报错：&quot;类型 testOverride_dynamicParameter 中存在重复的方法 test（int[]）&quot; public void test(int[][] array) &#123; &#125;//二维的可以 //------------------------------------------------------------ // public void test(int a,int...x)&#123;&#125; //默认第一个参数属于int a （👈一份 且末尾 //public void test(int...x，int a)&#123;&#125; //不可以 public static void main(String[] args) &#123; testOverride_dynamicParameter o = new testOverride_dynamicParameter(); o.test(1,2,3,4,5,6); o.test(); //默认执行的是无参的重载方法 &#125;&#125;"},{"title":"Java开篇","date":"2021-07-25T09:07:39.352Z","updated":"2020-07-13T04:53:20.000Z","comments":true,"path":"wp-java/zero/1_Opening.html","permalink":"https://equnee.github.io/wp-java/zero/1_Opening","excerpt":"","text":"1. 搭建环境安装JDK（JRE JVM） 2. 配置环境变量 path：为了让工具可以在任何位置都可以用 classPath：为了管理最终生成的字节码文件的存储路径 自己写了一个源代码文件 Test.java。 利用工具进行编译 -&gt; 字节码文件 Demo.class 新的文件都统一存储在配置的目录下 JAVA_HOME ：为了让路径的写法变得简单（相对路径的写法） 12JAVA_HOME C://program files/java/jdkpath %JAVA_HOME%/bin 3. 编写java 源代码是存储在电脑硬盘中的一个文件 文件是以后缀名.java形式存在 文件中的内容是我们编写的源代码（遵循一些规律） 12345class 名字 &#123; public static void main(String[] args)&#123; System.out.println(&quot;Hello World&quot;); &#125;&#125; 名字的规则和规约 【规则】名字只能含有字母(区分大小写)、数字(不能开头)、英文符号(_$)、中文(不推荐） 【规约】类名字首字母大写，多个单词每一个首字母大写（驼峰式） 属性/方法/变量 —— 与类名一致，大小写字母开头 包 —— 全部字母小写（区分关键字） 静态常量—— 全部字母大写（可以利用_分割） 名字最好见名知义 4. 编译和执行编译1javac Tset.java 执行1java Test 一个小问题： public修饰符与类名的写法 错误写法：源文件和生成的字节码文件不一致：Test.java Demo.class 无public，类名不同 ： 可执行，不报错 123456//Test.javaclass Demo &#123; public static void main(String[] args)&#123; &#125;&#125; 有public，类名不同：报错：错误：类Demo是公共的，应在名为Demo.java的文件中声明 123456//Test.javapublic class Demo &#123; public static void main(String[] args)&#123; &#125;&#125; 标准写法：加上public修饰符，且类名与文件名一致。 123456//Test.javapublic class Test &#123; public static void main(String[] args)&#123; &#125;&#125; 5. 补充：注释123//单行注释 /*多行注释*//**文档注释*/"},{"title":"基本数据类型 （未完）","date":"2021-07-25T09:07:39.352Z","updated":"2020-07-13T04:51:51.000Z","comments":true,"path":"wp-java/zero/2_Basic_data_types.html","permalink":"https://equnee.github.io/wp-java/zero/2_Basic_data_types","excerpt":"","text":"基本数据类型 8个12字节(byte)：用来计量存储容量的一种计量单位；指字的长度。位(bit) ：计算机内部数据储存的最小单位。（0/1） 整型 4byte 字节型 1byte == 8bit 00000000（256种组合） 0 000000 （ 用第一个bit位置来记录符号 0正数 1负数） 数值的范围：（ -2^7^ ~ 2^-7^-1）-128 ~ 127 （以下其他整数类型 依次乘2） short 短整型 2byte == 16bit （65526种组合） 0 000000000000000 数值范围：-32768 ~ 32767 int 整型 4字节 == 32bit 0 0000000000000000000000000000000 数值范围：-2147483648 ~ 2147483647 long 长整型 8字节 == 64bit 0 000000000000000000000000000000000000000000000000000000000000000 数值范围：-9223372036854774808~9223372036854774807 浮点型 2float 单精度 4字节 == 32位 0 000000000 0000000000000000000000（1个表示正负，9个表示整数部分，剩下小数部分） 数值范围：3.402823e+38 ~ 1.401298e-45 double 双精度 8字节 == 64位 0 000000000000000000000000000000000000000000000000000000000000000 数值范围：1.797693e+308~ 4.9000000e-324 字符型 1char 字符中数字和整数的数字冲突，为了区分，每一个字符的前后各加单引号 英文和符号数字是一个字节，中文两个字节 ASCII编码：美国信息交换标准代码 12A —— 00000000 —— 97字母(26)、数字(10)、符号(100+) —— 1字节256种组合够用 Unicode编码：中文才够用 1数值范围：0 ~ 65535 布尔型 1boolean 1bit true / false java内 1 和 true 无法相互转换 课外补充JAVA 变量的默认初始化 类型 默认初始化值 boolean false int 0 short 0 float 0.0 double 0.0 char \\ long 0 byte 0 object null 引用数据类型 ∞ 没有个数，因为可自定义 数组 []类class（抽象类 abstract class）接口interface枚举类型enum注解@interface"},{"title":"异常和错误","date":"2021-07-25T09:07:39.351Z","updated":"2020-07-13T05:43:40.000Z","comments":true,"path":"wp-java/zero/0_Exception_errors.html","permalink":"https://equnee.github.io/wp-java/zero/0_Exception_errors","excerpt":"","text":"Exception 异常——人为规定的一种不正常现象 编译时异常 运行时异常 Error 错误 —— 计算机根本处理不了了，内存溢出 常见运行时异常1. InputMisMatchException 输入类型不匹配 1input.nextInt(); //输入一个整数 a 2. ArrayIndexOutOfBoudsException 数组越界 静态初始化 12int[] array = &#123;10, 20&#125;;array[2]; //索引超出边界 动态初始化 1234int[][] array = new int[3][2]; //&#123;&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;&#125;array[2][5] = 10; ^//ArrayIndexOutOfBoudsException: 5 （数组越界且索引值为5 3. NegativeArraySizeException 数组长度不合法：负数 1int[] arrar = new int[-2]; //动态初始化 4. NullPointException 空指针异常 / 空指向异常 引用为null可以，还拿来使用就不行了 1234int[][] array = new int[3][]; //&#123;&#123;&#125;,&#123;&#125;,&#123;&#125;&#125;array[2][0] = 10;//空元素再拿来用//修改：array[0] = new int[2] (↓null-&gt; int □□) 5. NumberFormatException 转化问题：如输入String:abc无法转化成Int:数字 1int value = Integer.parseInt(&quot;abc&quot;); //Integer:将字符串转化为整数的包装类 6. StackOverflowError 栈溢出错误 —— 方法间来回调用 12345678public class Person&#123; public void sleep()&#123; eat(); &#125; public void eat()&#123; sleep(); &#125;&#125; 堆内存溢出错误 OutMemoryError 7. ArithmeticException 数字异常 整数/0 创建对象时未设置参数，方法内有除以参数的计算，而参数未赋值时默认为0 graph LR A --> B"},{"title":"面向对象 - 方法设计","date":"2021-07-25T09:07:39.351Z","updated":"2020-07-12T17:19:43.000Z","comments":true,"path":"wp-java/zero/10_Object_oriented-method_design.html","permalink":"https://equnee.github.io/wp-java/zero/10_Object_oriented-method_design","excerpt":"","text":"类中的方法 类中的方法 —— 做一件事情 结构123权限修饰符 [特征修饰符] 返回值类型 方法名字 (参数名字) [抛出异常] [&#123; 方法体&#125;] //←方法体也不是必须的：抽象方法——只有方法的结构 必要结构： 123权限修饰符 返回值类型 方法名字 (参数列表)&#123;&#125; 根据返回值和参数内容有无分类 无参数无返回值 无参数有返回值 有参数无返回值 有参数有返回值 属性和方法 人类有名字 有年龄 有性别 —— 属性 人类能吃饭 能说话 能学习 —— 方法 方法 —— 做了一件事 返回值 —— 这件事做完了 留下一个结果 参数 —— 做事情前必须提供的条件 代码 创建一个对象 通过对象调用方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class test&#123; public static void main(String args)&#123; //1.创建一个对象——人类的对象 Person p = new Person(); p.chiFanFan(2， &quot;面条&quot;);//传入参数，更灵活 String drinkName = p.buyDrink(10); System.out.println(&quot;买到了一瓶：&quot;+drinkName); String myName = p.telName(); System.out.println(&quot;接收到了tellName方法的返回值：&quot; + myName); //2.通过对象.调用方法 让方法按照描述的过程执行一遍 p.name = &quot;蜜桃&quot;; //属性紫颜色，没有小括号，用来赋值取值 p.eat(); &#125; //方法 —— 描述可以做什么事情(动作) //设计一个方法 用来描述人类可以做吃饭这件事情 public void eat()&#123; System.out.println(&quot;吃了一碗大米饭&quot;); &#125; //设计一个方法 用来告诉别人我的名字 &quot;蜜桃&quot; //若方法的设计规定了返回值类型 方法内必须通过return关键字返回一个值 public String telName()&#123; System.out.println(&quot;你们问我叫什么呀？勉强告诉你们一下&quot;); return &quot;蜜桃&quot;; &#125; //设计一个新的吃饭方法 //描述人类可以做吃饭这件事情 public void chiFanFan(int count,String something)&#123;//括号内：参数列表 //String something; System.out.println(&quot;吃了&quot;+count+&quot;碗&quot;+something); &#125; //设计一个方法 买饮料 1.需不需要提供条件 2.需不需要给别人留下什么结果 // 需要提供条件 ：钱 // 需要返回值 ：买到的饮料 名字 public void buyDrink(int money)&#123; if(money&gt;5)&#123; return &quot;蜜桃汁&quot;; &#125;else&#123; return &quot;养乐多&quot;; &#125; &#125; /* public class Person&#123; public String name; public int age; public char sex; &#125; */ &#125; 例子1. 画4x4五角星 需求：设计一个方法 用来画星星(控制台输出) 只输出4行 每一行4颗星星 分析：做事情之前是否需要提供条件 不需要； ​ 做事情之后是否需要留下结果 不需要 123456789101112131415161718public class test1&#123; public static void main(String args)&#123; Person p = new Person(); p.drawStar(); &#125; //设计一个方法 用来画星星 4x4 public void drawStar()&#123; for(int i =1;i&lt;=4; i++)&#123; for(int j =1;j&lt;=4;j++)&#123; System.out.print(&quot;*&quot;); &#125; System.out.println(); &#125; &#125; &#125; 2. 画直角三角形星星 需求：设计一个方法 用来画星星 只输出4行 直角三角形 第一行一颗 第二行两颗 第三行三颗 分析：做事情之前是否需要提供条件 不需要； ​ 做事情之后是否需要留下结果 不需要 1234567891011121314151617public class test2&#123; public static void main(String args)&#123; Person p = new Person(); p.drawStar(); &#125; //设计一个方法 用来画星星 4x4 public void drawStar()&#123; for(int i =1;i&lt;=4; i++)&#123; for(int j =1;j&lt;=i;j++)&#123; System.out.print(&quot;*&quot;); &#125; System.out.println(); &#125; &#125;&#125; 3. 画星星 直角三角形 不一定画几行 需求：直角三角形 不一定画几行 分析：是否需要提供条件 — int line； ​ 是否需要留下结果 — 不需要 1234567891011121314151617public class test3&#123; public static void main(String args)&#123; Person p = new Person(); p.drawStar(7); &#125; //设计一个方法 用来画星星 4x4 public void drawStar(int line)&#123; for(int i =1;i&lt;=line; i++)&#123; for(int j =1;j&lt;=i;j++)&#123; System.out.print(&quot;*&quot;); &#125; System.out.println(); &#125; &#125;&#125; 4. 画星星 直角三角形(反向) 不一定画几行 需求：设计一个方法 画星星 直角三角形(反向) 不一定画几行 分析：是否需要提供条件 int line； ​ 是否需要留下结果 不需要 1234567891011121314151617181920public class test4&#123; public static void main(String args)&#123; Person p = new Person(); p.drawStar(6); &#125; //设计一个方法 用来画星星 4x4 public void drawStar(int line)&#123; for(int i =1;i&lt;=line-i; i++)&#123; for(int j =1;j&lt;=i;j++)&#123; System.out.print(&quot; &quot;); &#125; for(int j=1; j&lt;=i; j++)&#123; System.out.print(&quot;*&quot;); &#125; System.out.println(); &#125; &#125;&#125; 5. 画星星 行数不确定 直角三角形方向不确定 需求： 画星星 行数不确定 直角三角形方向不确定 分析：是否需要提供条件 int line boolean f； 是否需要留下结果 不需要 1234567891011121314151617181920212223public class test5&#123; public static void main(String args)&#123; Person p = new Person(); p.drawStar(4,true);//4行偏左 &#125; //设计一个方法 用来画星星 4x4 //f —— 方向 f==true 偏左 无空格； f==false偏右 有空格 public void drawStar(int line, boolean f)&#123; for(int i =1;i&lt;=line; i++)&#123; if(!f)&#123;//f==false 偏右带空格 for(int j =1; j&lt;=line-i; j++)&#123; System.out.print(&quot; &quot;); &#125; &#125; for(int j=1; j&lt;=i; j++)&#123; System.out.print(&quot;*&quot;); &#125; System.out.println(); &#125; &#125;&#125;"},{"title":"常量与变量","date":"2021-07-25T09:07:39.353Z","updated":"2020-07-13T04:52:40.000Z","comments":true,"path":"wp-java/zero/3_Constants_variables.html","permalink":"https://equnee.github.io/wp-java/zero/3_Constants_variables","excerpt":"","text":"常量常量代表是程序运行过程中，不能再次改变的 值或内容 作用 固定的值，代表计算过程中经常用到的值 作用：便于程序计算 圆周率 3.1415926… 用来代表一个含义 UP =&gt; 1 2 3 4 分别代表 上下左右四个方向 定义 固定不变的值 11 3.14 ‘a&#x27; true 可以认为所有基本类型的值 固定不变 是常量 特殊的常量 1“abc&quot;—— String String是一个引用数据类型，它的值很特殊，可以简单的视为常量 自己创建的空间来存储一个值，让其固定，不能改变 1final int UP = 1; 修饰符 final 常量存储在常量缓冲区(常量池)中，有且只有一份 常量池中的值默认空间大小 32bit—int 64bit—double 变量 变量指的是程序执行过程中可以改变的 变量是一个内存空间（小容器） 变量空间在创建(声明)的时候，必须指定数据类型 变量空间的名字 变量空间内只能存储一个内容（值 引用） 变量空间内的内容可以改变 创建(声明)变量命名 命名规则 字母(大小写敏感) 数字(0-9 不允许开头) 符号(英文符号 _ $) 中文(不推荐) 命名规约 类名 首字母大写，两个单词以上，所有的首字母都大写 变量名 首字母小写，两个单词以上，之后的首字母大写（驼峰式） 所有名字都需要见名知义：增强程序的可读性 声明数据类型 变量名字； 12int a;String b; 【注意】 变量是一个空间，可以只创建空间，不存放内容。 变量空间创建后没有默认内容：空的。空的变量空间不能拿来使用。（编译错误） 变量空间内容有且只有一个，（只能存一份：值 引用） 空间内内容的类型与定义时一致，内容可以改变 例子： 12byte x; //声明一个变量空间 空间的名字x 空间内要求存储的类型是byte整数x = 1; //将一个1赋值到x空间进行存储 1byte x = 1 //同上 内存结构与执行过程 x是什么？ 变量空间 存在哪儿？——栈内存 1是什么？1是常量 存在哪儿？——常量缓冲区 =是什么？=是赋值 做了什么？ 12内存：空间小，按照地址寻找。【本质区别：临时存储】硬盘：空间大，按照扇区扫描【永久保存】 简要过程： 硬盘上创建了一个文件 Test.java 文件中的内容是我们编写的源代码（向计算机发送指令） 123456public class Test&#123; public static void main(String[] args)&#123; byte x; x = 1; &#125;&#125; （JVM虚拟机）将Test.java源文件 —^编译^—&gt; Test.class (翻译出的字节码，内容我们看不懂，留给计算机识别) 执行 ——&gt; 内存中执行 将硬盘上的 Test.class内容加载到内存里 按照我们写好的指令，执行 内存的空间创建 赋值 变化…… 详细图解： 源码执行编译内存空间原理： 1. 编译1javac Test.java （虚拟机）将源文件 —^编译^—&gt;字节码文件 编译的原理：I/O Input/Output 输入输出流 【读和写的过程】 虚拟机帮我们翻译并且开辟一个内存空间 （栈内存 | 堆内存 | 存储区） 存储区内元素只有一份，且不能改变。 2. 加载1java Test ↑ 虚拟机开辟的内存储区的方法区(类模板) 里有一个映射空间，目的：用于存储描述的字节码信息。 （硬盘内的）字节码内容 —^加载^—&gt; 到内存里。（类映射） 默认的执行过程：有一个类加载器(小人)，类加载器（ClassLoader） 将硬盘中的字节码文件信息搬运到内存里。 3. 执行123456public class Test&#123; public static void main(String[] args)&#123; byte x; x = 1; &#125;&#125; 堆内存 / 存储区 ：仓库(存东西) 栈内存：所有内容执行的区域 执行的是加载到内存方法区里的类模型的信息。 先将主方法压到栈内存 在栈内存里再开辟申请一个变量空间 ( 数据类型byte 变量名字 x ) 1 存在 常量缓冲区 内，将其复制一份（等号的作用），存在变量空间 (x) 内。"},{"title":"类型转换","date":"2021-07-25T09:07:39.353Z","updated":"2020-07-13T04:53:44.000Z","comments":true,"path":"wp-java/zero/4_Type_conversion.html","permalink":"https://equnee.github.io/wp-java/zero/4_Type_conversion","excerpt":"","text":"1. 同种数据类型间可以直接进行赋值操作 四种基本数据类型： 整型：byte int short long 浮点型：float double 字符型：char 布尔型：boolean 12float x = 3.4;float y = x; 12byte a = 1; //8bit -128~127 int b = a; //32bit 把小份量的米饭放到更大的碗里：完全装得下√ 2. 不同数据类型的空间之间的赋值——转换问题 两种大数据类型： 基本数据类型 引用数据类型 ① 同种大数据类型之间才能发生转换12基本数据类型 —— 基本数据类型 ：可以直接转换（ 自动 / 强制 ）引用数据类型 —— 引用数据类型 ：可以直接转换（ 自动 / 强制 / 上转型 / 下转型 ） ② 不同大数据类型之间需要包装类12引用数据类型 —— 引用数据类型 ：不可以直接转换 （ 需要间接：包装类 / 封装类 ） 8个包装类对应8个基本数据类型 ③ 保证大数据类型一致的前提下基本类型之间1. 小数据类型相同 （都是浮点 / 都是整型）：比较空间大小 小空间存大空间：直接转换 12byte a = 1; // 1两米饭：2两碗——&gt; 4两碗 （1两米饭+3两空气） int b = a; 大空间存到小空间：强制类型转换 12 float x = 3.4F; double y = x; //自动直接转化double x = 3.4; float y =(float)x; //强制转换 ① 数值较小 12int a = 1; // 1两米饭：4两碗——&gt; 2两碗 （1两米饭+1两空气）byte b = (byte)a; // 强制砍掉一部分空气 a：1【00000000 00000000 00000000 00000001】 b：【00000000】 ② 若强制转换之前数值较大：强制转换这件事可以，执行后，b存放的值一定发生变化 12int a = 1000; // 1:【00000001】 1000:【00000000 00000011 11101000】byte b = (byte)a ; //只有8个bit位 a：1000:【00000000 00000011 11101000】 b：【00000000】（ 第一位用于存放正负 —— 最终结果会变成 -24 ） 2. 小数据类型不同 整型——浮点 比较精确程度：浮点型精确程度更高，可以直接存放整数 反之需要强制转换（强行将小数点之后部分去掉，只保留整数） 任何一个浮点型可以直接存放一个整型 1int a =1; float b = a; //自动直接转换 1float a = 1.0F; int b = (int)a; //强制类型转换 整型——字符型 每一个字符都对应一个Unicode码：a—97 1char x = &#x27;a&#x27;; int y = x; //自动转换 y——97 1int x = 97; char y = (char)x; //强制转换 布尔型很特殊，不能与其他类型发生转换 引用类型之间（后续…..）"},{"title":"运算符","date":"2021-07-25T09:07:39.353Z","updated":"2020-07-13T04:54:13.000Z","comments":true,"path":"wp-java/zero/5_operator.html","permalink":"https://equnee.github.io/wp-java/zero/5_operator","excerpt":"","text":"用来指明对于操作数的运算方式。 按操作数的数目来分类单目 a++双目 a + b三目 (a&gt;b) ? x : y按照运算符功能来分类 优先级别：算术 &gt; 赋值 1. 算术运算 ( 优先级别更高 )+ - * / % ++ -- 例1： 1234int x = 1;x = x + 1; //x空间内的值 自己增加了一个x++; //x空间内的值 自增一个++x; //对于x的空间内的值来讲 结果一致。最终的结果都自增了一个 例2： 12int x = 1;int y = x++; 12345678public class Operational_symbol &#123; public static void main(String[] args) &#123; int x = 1; int y = x++; System.out.println(x); //2 System.out.println(y); //1 &#125;&#125; x++; 即 x=x+1; —&gt; 将x变量空间内的内容先取出，常量区取出1，进行计算，再次存回x空间 x在想要做值交换的时候，会产生一个临时的副本空间(备份) ++在变量的前面:先自增后备份 / ++在变量后面,先备份后自增 会将副本空间内的值赋给别人 最后备份空间无用：销毁 例3： 123int x = 1;int y = ++ x;// x == ? y == ? ( 2 , 2 ) 例4： 12int a = 1;a = a++; 12345678910public class Operational_symbol &#123; public static void main(String[] args) &#123; int a = 1; for(int i=1;i&lt;100;i++) &#123; a=a++; &#125; System.out.println(a);//1 &#125;&#125; 不断把副本a里的1值赋给a —&gt; 永远是1 一个笔试题： 1234int m = 1;int n =2;int sum = m+++++n-n-----m+n-----m;//sum == ? n == ? m == ? ( 0, 1, 2) 2. 赋值运算 = += -= *= /= %= = 赋值符号，将=右边的内容(值 引用) 存入左边的变量空间内 例1： 12int x = 1;x+=10; //x=x+10 例2： 12unt x = 1;x+=2; //3 12byte x = 1;x=x+2; //编译出错 类型从int转化成byte可能有损失 x变量空间的值取出 从常量区取过来2 加法运算 结果重新存回x变量空间内 x空间 —&gt;1 8bit 常量区 —&gt;2 32bit 无法计算（位数对不齐） —&gt; 补成都是32位对齐 计算后 —&gt; 无法存入8位的byte空间内 12345678public class Operational_symbol &#123; public static void main(String[] args) &#123; byte x = 1; x = (byte)(x+2); //x+=2; System.out.println(x); &#125;&#125; 3. 关系运算(比较)1&gt; &gt;= &lt; &lt;= != == (对象 instanceof )//比较对象类型 区分 = 和 == = 赋值符号：将=后面的结果(值 引用)存入=左边的变量空间内 ==比较符号:比较 == 前面和 ==后面的元素(值 引用)是否一致 比较运算符的最终结果是 boolean ( true / false) (3&gt;2) ture (3&gt;=4) false 4. 逻辑运算 &amp; 逻辑与 | 逻辑或 ^ 逻辑异或 !逻辑非 (单目) &amp;&amp;短路与 ||短路或 123456(3&gt;2)&amp;(3&gt;4) 和,并 //true&amp;false false(3&gt;4)|(3&gt;5) 或 //false|false false(3&gt;2)^(3&gt;4) 异(不同的) //true^false true!(3&gt;2) 非 //!(true) flase(3&gt;4)&amp;&amp;(3&gt;2) 与 //false&amp;&amp; 发生短路 直接false(3&gt;2)||(3&gt;4) //true|| 发生短路 直接true 逻辑运算符前后连接的应该是两个boolean结果 逻辑运算最终结果还是boolean值 &amp;逻辑与 【”和” “并且”】 &amp;前后两个条件必须同时满足,最终才为true |逻辑或 【”或” 】 |前后两个条件只要有一个条件满足,最终就为true ^逻辑异或 ^前后两个结果不一致,最终才为true !逻辑非 【”不”】 将原来结果取反 &amp;&amp;短路与 【与】 两个条件同时满足，如果第一个已为false，最终肯定是false ||短路或 【】 两个条件同时满足，如果第一个已为true，最终肯定是true 一些笔试要点： 什么情况下发生短路？——当前面的值为false时会发生短路 短路的是什么？ ——短路的是&amp;&amp;之后所有计算的过程 如果发生了短路情况，性能比&amp;稍微好一点 &amp;逻辑与 和 &amp;&amp;短路与 从执行的最终结果来看没有任何区别 短路与不一定提高了性能，只有当前面为false的时候才会发生短路，才会提高性能 5. 位bit运算 &amp;按位与 |按位或 ^按位异或 ~按位取反 &lt;&lt;按位左位移 &gt;&gt;按位右位移 &gt;&gt;&gt;按位右位移(无符号) 补充1：进制转换问题1234十进制 0123456789二进制 01八进制 01234567十六进制 0123456789ABCDEF 十进制转换为二进制 60 —&gt;32个0或1来表示60 ： 60除以2取余数，将余数倒序排列，即为有效位 00000000 00000000 00000000 00111100 二进制转换为十进制 从右至左开始计算，每一个元素乘以2的位置(0开始)次幂 最终求和 八进制 每三个bit记录为一个小组 —&gt;小组长名字(3个bit计算成十进制) 将3个二进制合并为一个，计算成十进制表示，八进制表示形式以0开头 00000 000 000 000 000 000 000 000 111 100 ​ 0 7 4 = 074 十进制 每四个bit记录为一个小组 —&gt;小组长名字(4个bit计算成十进制) 十六进制以0x开头 0000 0000 0000 0000 0000 0000 0011 1100 ​ 0X 3 12 = 0X3C 3 &amp; 5 = ? 将3和5转化为二进制表示形式 竖着按照对应位置进行 &amp;|^计算（1-true 0-false） 将计算后的二进制结果转化为十进制 00000011 00000101 00000001 —&gt; 1 ~ 5 = ?补充2：源码 反码 补码 ​ 【 6 】 【 -6 】 原码： 00000000 00000000 00000000 00000110 00000000 00000000 00000000 00000110 反码： 00000000 00000000 00000000 00000110 11111111 11111111 11111111 11111001（符号不动，其余取反） 补码： 00000000 00000000 00000000 00000110 11111111 11111111 11111111 11111010 （反码 +1 ） 计算机中不管是正数还是负数，存储形式都是以补码形式来存储 反码是一种表示形式，取反是一个计算过程（每一个位置都取反） 配对：0 和 -1 1 和 -2 2 和 -3 3 和 -4 ….. 6 和 -7 6 &lt;&lt; 1=? ​ 00000000 00000000 00000000 00000110 6&lt;&lt;1：00000000 00000000 00000000 00001100 = 12 ( = 62^1^ ) *( 向右位移一位 )** 6&lt;&lt;2：00000000 00000000 00000000 00011000 = 24 ( = 6*2^2^ ) 相当于乘以2的位移次幂 6 &gt;&gt; 1=? ​ 00000000 00000000 00000000 00000110 6&lt;&lt;1：00000000 00000000 00000000 00000011 = 3 ( = 6 / 2^1^ ) ( 向右位移一位 ) 6&lt;&lt;2：00000000 00000000 00000000 00000001 = 1 ( = 6 / 2^2^ ) 相当于除以2的位移次幂 -6 &gt;&gt; 1 ​ 11111111 11111111 11111111 11111010 -6&gt;&gt;1：?11111111 11111111 11111111 1111101 = 3 ( = 6 / 2^1^ ) ( 向左位移一位,符号改为1 ) &gt;&gt; 保留符号位置1 填 1 &gt;&gt;&gt; 不保留符号 不管是什么都填 0 笔试题0. 考察++ – += ==类似符号 运算符号优先级别。。。 1. &amp;和&amp;&amp;的区别 &amp;可以视为逻辑运算，可以视为位运算，&amp;&amp;只能当作逻辑运算来用 如果两个符号都当作逻辑运算来使用的时候，有以下区别： &amp;前后两个条件都是true，最终结果就是true &amp;&amp;短路与 正常情况下&amp;执行结果是一致 当前面条件为false的是时候，发生短路，最终结果false 2. 最有效率的方式计算2*8的结果12&lt;&lt;3 ​ 位移运算：相当于2乘以2的三次幂 (必须是2的次幂) 3. 两个变量 int a = 1; int b = 2; 如何将两个变量的值进行互换 等号 赋值符号 方法一 12345int a = 1; int b = 2; int c = a;a = b;b = c; 易理解，值也不会出现问题 / 但产生一个新的内存空间 方法二： 123a = a + b; //a空间存储的是两元素之和，a==3 b没有变化 b==2b = a - b; //用和减b 剩下的是原来的a b==1 a==3a = a - b; //用和减原来的a 剩下是原来的b 赋值给a a==2 b==1 不浪费空间 / 但相对来讲不易理解 ， 且会在 + 产生越界问题 方式三： 123a = a^b; // 1^2 ==&gt; 001 010 = 011 ==3 b = a^b; // 3^2 ==&gt; 011 010 = 001 ==1 a = a^b; 用一个数字异或同一个数字两次，值不会改变 少用，不易产生越界问题"},{"title":"多维数组","date":"2021-07-25T09:07:39.354Z","updated":"2020-07-13T03:58:50.000Z","comments":true,"path":"wp-java/zero/8_Multidimensional_array.html","permalink":"https://equnee.github.io/wp-java/zero/8_Multidimensional_array","excerpt":"","text":"数组 用来存储一组相同数据类型的数据的容器 数组本身是一个引用数据类型 数组内部存储的元素——基本数据类型/引用数据类型 学过的引用数据类型 String Math Scanner 数组本身[] —— 数组内存数组 二维数组 定义/声明里面存储的类型 [] 数组名字； int[] [] array; 初始化 静态 1int[][] array = &#123;&#123;1,2&#125;,&#123;3,4,5,6&#125;,&#123;7,8,9&#125;&#125;; //有元素，有长度 动态 1int[][] array = new int[]; //无元素，有长度 12int[][] array = new int[3][2] (树形)array ——&gt; &#123;&#123;x, x&#125;, &#123;x, x&#125;, &#123;x, x&#125;&#125; ——&gt; 默认值0 元素访问通过元素在数组中的位置 —— index array[i][j] i控制大数组中 小数组位置 j控制小数组中 元素位置 遍历轮询嵌套： 正常 增强for循环 例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class test&#123; public static void main(String[] args)&#123; //声明 _ 初始化（静态） int[][] array = new int[][]&#123;&#123;1,2&#125;,&#123;3,4,5,6&#125;,&#123;7,8,9&#125;&#125;; //访问数组内元素——index //int v = array[0][0]; //System.out.println(v); //array[1][2] 5 //array[2][2] 9 //遍历 for(int i =0 ; i&lt;array.length;i++)&#123; int[] arr = array[i]; for(int j =0; j&lt;arr.length;j++)&#123; int v = arr[j]; System.out.print(v + &quot;\\t&quot;); &#125; System.out.println(); &#125; //遍历2 —— 节省一个数组 for(int i =0;i&lt;array.length;i++)&#123; for(int j = 0;j&lt;array[i].length;j++)&#123; int v = array[i][j]; System.out.print(v + &quot;\\t&quot;); &#125; System.out.println(); &#125; //增强for循环 for(int[] arr:array)&#123; for(int v:arr)&#123; System.out.print(v + &quot;\\t&quot;); &#125; System.out.println(); &#125; &#125;&#125; 🔺引用类型在内存中的存储结构二维数组在内存中的存储 int[][] array = new int[3][2]; 3表示有3个小数组 int[] 2表示每一个小数组内由2个元素 例子1234567891011121314public class test&#123; public static void main(String[] args)&#123; int[][] array = new int[3][2]; //1. //&#123;&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;&#125; array[0][0] = 10; //2. array[0][1] = 20; array[1] = array[0]; //3. array[0] = new int [4]; //4. array[1][0] =100; //5. System.out.println(array[0][0]); //array[1][0] ——&gt; 10 &#125;&#125; 最终结果：0 垃圾。小数组空间没有任何指向他，将被GC回收 (Garbage Collection) 多维数组-练习1. 模拟班级同学每周换组12345678910111213141516171819202122232425262728import java.util.Scanner;public class test&#123; public static void main(String[] args)&#123; //创建一个二维数组，表示班级里每一列同学 int[][] array = &#123;&#123;1, 2, 3, 4&#125;, &#123;5, 6, 7, 8&#125;, &#123;9, 10, 11, 12&#125;, &#123;13, 14, 15, 16&#125;&#125;; //设计每周交换一次 几周？ Scanner input = new Scanner(System.in); System.out.println(&quot;请输入周数，看看交换结果&quot;); int week = input.nextInt(); for(int i=0;i&lt;=week%4;i++)&#123; int[] x = array[0]; array[0] = array[1]; array[1] = array[2]; array[2] = array[3]; array[3] = x; &#125; //简单看一看 for(int[] arr:array)&#123; for(int value:arr)&#123; System.out.print(value + &quot;\\t&quot;); &#125; System.out.println(); &#125; &#125;&#125; 2. 利用二维数组 实现用户登录 两个数组 String[] String[] 账号、密码 （索引对应 二维数组 String[] 1&#123;&#123;“蜜桃”, &quot;123&quot;,&#125;, &#123;“peach”, &quot;666&quot;&#125;, &#123;“equne”, &quot;888&quot;&#125;&#125; 补充：修饰符12public static void main(String[] args)&#123;&#125; public 访问权限修饰符，共有的 static 特征修饰符 静态的 有且只有一份 void 方法执行完没有返回值 关键字 main 方法名字 主要的 主方法中的args参数：可否传递？ 主方法不是我们调用的，JVM启动的时候，虚拟机调用的 主方法里面有args参数 是一个String[]类型 我们是可以传递参数进去，给JVM args例子 1234567891011public class test&#123; public static void main(String[] args)&#123; System.out.println(args.length); //长度 for(String value:args)&#123; System.out.println(value); &#125; //运行时输入n参数，运行后输出n、所有参数 //java test one tow three &#125;&#125;"},{"title":"面向对象 - 属性","date":"2021-07-25T09:07:39.354Z","updated":"2020-07-12T17:17:12.000Z","comments":true,"path":"wp-java/zero/9_Object_oriented-properties.html","permalink":"https://equnee.github.io/wp-java/zero/9_Object_oriented-properties","excerpt":"","text":"[TOC] 面向对象编程思想面向过程编程思想 解决问题的时候按照一定的过程 以过程为本—复用—增加了很多冗余 大象装冰箱： 1.开门 2.大象装里面 3.关门 大段地过程，拆分成小段 — 到底是哪一个实体来做的 面向对象编程思想 解决问题的时候按照现实生活中的规律和本质 考虑在这个问题过程中，有几个实体参与进来 理解为 实体动作的支配者，没有实体动作就发生不了 分别分析每一类个体有什么特点，做了哪些事情 大象装冰箱： 大象 特点：大，体重很重 冰箱 特点：有门，容积 人 特点：能做事情 。做了哪些事情？开冰箱门，装大象，关门 类和对象类——人类 抽象笼统的概念，描述一类事物，肯定是具有相同特征行为 人类有名字，有年龄，有性别； ——&gt; 静态描述特征(特征)——属性 人类能吃饭，能说话，能学习； ——&gt; 动态动作行为(做事)——方法 对象——具体的人 人类中的一个具体的人——游蜜桃 游蜜桃这个具体的人：有名字，有年龄，有性别 ； 能吃饭，能说话，能学习 在现实生活中，对象是先有的，总结出来的概念(类)后产生的。 在计算机中利用面向对象的思想来做事 需要先定义(描述)一个类(型) 想要做事情，需要在描述的类中创建一个具体的个体(对象)出来 个体(对象)来做事 如何在计算机中创建一个类 先创建一个类 利用属性或方法去描述这个类 创建一个当前类的对象，让对象调用属性/方法做事 对象的创建在哪里都可以 代码 Person.java 123456789101112public class Person&#123; //这个文件是在计算机内 画的一张图纸 描述计算机的人类长成什么样子的 //属性 —— 静态描述特点 / 有默认值 String=null int=0 public String name;//全局变量 public int age; public char sex; //方法 —— 描述可以做什么事情(动作) //main &#125; Test.java12345678910111213141516171819202122232425262728293031public class Test&#123; //这个类没有什么现实意义 只是为了将主方法写在这里 public static void main(String)&#123; //想要在这里使用一个人 来执行操作 //创建一个人类的对象 找一个空间来存储 //int X = 10; //基本数据类型 //String Y = &quot;abc&quot;; //Person p = ?; //我们自己创造的类型clas —— 引用类型 Person p = new Person();//p的小人，也有自己的名字 年龄 性别 有没有值？？ //通过对象，去调用属性，存值/取值 p.name = &quot;游蜜桃&quot;; p.age = 18; p.sex = &#x27;女&#x27;&#x27;; //拿图纸再创建一个 Person p1 = new Person();//p1另外的一个小人 也有自己的名字 年龄 性别 //Person p1 = p; 得出两个同样的黄空白 p1.name = &quot;黄空白&quot;; p1.age = 17; p1.sex = &#x27;男&#x27; System.out.println(p.name+&quot;今年&quot;+p.age+&quot;岁，性别是&quot;+p.sex); System.out.println(p1.name+&quot;今年&quot;+p1.age+&quot;岁，性别是&quot;+p1.sex); &#125;&#125; 属性必要组成部分 修饰符 （public：同包和本类 数据类型 属性名字 [ = 值 ] 图解 Person p1 = new Person(); 图解 Person p1 = p;"},{"title":"面向对象 - 参数 / 返回值","date":"2021-07-25T09:07:39.351Z","updated":"2020-07-12T17:23:07.000Z","comments":true,"path":"wp-java/zero/11_Object_oriented-parameter_return_value.html","permalink":"https://equnee.github.io/wp-java/zero/11_Object_oriented-parameter_return_value","excerpt":"","text":"方法 —— 动态描述类的行为 123权限修饰符 [特征修饰符] 返回值类型 方法名字(参数列表) [抛出异常][&#123; 方法执行体&#125;] 方法中最主要的两个结构：方法的参数列表，方法的返回值类型 参数列表：可以理解为方法做事情之前需要提供的条件（可以多个） 返回值：可以理解方法做事情之后得到的一个结果（只有一个） 类描述好了以后是不可以直接做事情。需要创建当前类的对象 通过new的方式 Person p = new Person(); 通过p.调用 调用属性(存值/取值) 调用方法(执行一次) 例子Test 1 123456789101112131415161718public class Test &#123; public int changeNum(int x) &#123; System.out.println(&quot;方法执行开始&quot;+x);//⑷ 1 x = 10;//⑸ 修改传递进来的值 System.out.println(&quot;方法执行最终&quot;+x);//10 return x;//⑹ 返回值 ——&gt; 将x临时的变量空间内的值(值 引用)返回出来 &#125; public static void main(String[] args) &#123; // 创建一个对象 // 0.方法区中加载类模板的过程 Test t = new Test(); //⑴ 堆内存中开辟空间 int a = 1; //⑵ //t.changeNum(a); //⑶ ↓ a = t.changeNum(a); //⑷-⑹ + ⑺a= 10 System.out.println(&quot;方法执行完毕，main方法中a的值&quot;+a);//1 &#125;&#125; t.changeNum(a); 调用方法 让方法执行一遍 1.方法存在哪里？—对内存的对象空间内 2.方法在哪里执行的？—栈内存中开辟一块临时空间的方法执行空间 Test 2 12345678910111213141516public class Test &#123; public void changeArray(int[] x) &#123; System.out.println(&quot;方法执行开始&quot;+x[0]);//⑷ x[0] = 10;//修改传递进来的值 ⑸ System.out.println(&quot;方法执行最终&quot;+x[0]);// &#125;&#125;public static void main(String[] args) &#123; //0. 加载类模板 Test t = new Test(); //⑴ int[] a = new int[] &#123;1,2,3&#125;; //⑵ t.changeArray(a);//⑶ //方法存在堆内存内的对象空间里 方法执行在栈内存中的临时空间 //调用方法时将a的值传递给了x int[] x = a; 传递过来的就是一个 引用 System.out.println(&quot;方法执行完毕，main方法中a数组的第一个值：&quot;+a[0]);//10&#125; 形参和实参 形参可以理解为是方法执行时的临时变量空间 x 实参可以理解为时方法调用时传递进去的参数 a 方法调用会将实参的内容传递给形参 如果内容是基本类型 传递的是值，形参改变 实参不变 如果内容是引用类型 传递的是引用，形参改变 实参跟着改变 命名规约和规约 规则：字母 数字 符号 中文 字母 区分大小写 数字 不能开头 符号 _$ 中文 不推荐使用 规约： 类名字 —— 首字母大写，两个单词以上，每个首字母都大写 1Test TestOne TestOneTwo 属性/方法/变量 —— 驼峰式命名规约，首字母小写。两个单词以上：第二个以后每一个首字母大写 1test testOne testOneTwo 构造方法 —— 与类名一致，类中唯一的大写字母开头的方法 静态方法 —— 全部大写字母，通过_做具体说明 BOOKSTORE_ADMIN 包名 —— 全部字母小写，Java关键字都是小写 注意与关键字不用冲突 所有的名字最好——见名知义（增强可读性：层次关系缩进/见名知义/注释） 小练习 1. 用来交换两个数组元素 a{1,2,3,4} b{5,6,7,8} Demo1.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/* 【交换两个数组的元素】 方法本身是否需要参数和返回值？ ——需要参数：两个数组 / 返回值：不用*/public class Demo1 &#123; public void changeTwoArray(int[] a,int[]b) &#123; //方式一：交换数组内的元素值 /* for(int i = 0;i &lt; a.length; i++) &#123; int x = a[i]; a[i] = b[i]; b[i] = x; &#125;*/ //方式二：交换数组引用 int[] temp = a; a = b; b = temp; &#125; public static void main(String []args) &#123; //创建一个Demo对象 Demo1 d = new Demo1(); //用来交换的两个数组元素 a&#123;1,2,3,4&#125; b&#123;5,6,7,8&#125; //1. 先有两个数组 int[] a = &#123;1,2,3,4&#125;; int[] b = &#123;5,6,7,8,9&#125;; //① 方式一：不使用方法 //2. 交换数组中对应位置的 /*for(int i=0; i&lt;a.length; i++) &#123; int x = a[i]; a[i] = b[i]; b[i] = x; &#125;*/ //② 方法二：使用方法 //2. 调用demo中的changeTwoArray方法 d.changeTwoArray(a,b); //3. 验证 for(int v:a) &#123; System.out.println(v); &#125; System.out.println(&quot;————————&quot;); for(int v:b) &#123; System.out.println(v); &#125; &#125;&#125; 方式一的设计问题 用循环的方式挨个交换数组内的元素，性能比较慢 交换的适合需要保证两个数组的长度是一致的 2. 交换一个数组内部头尾位置对应互换 Demo2.java 1234567891011121314151617181920212223242526package Parameters_ReturnValues;/* * 【数组内部元素头尾对应互换】 */public class Demo2 &#123; public static void main(String [] args) &#123; // 隐藏的过程：加载类模板 //0. 创建一个对象 TestFunctions t = new TestFunctions(); //⑴ //1. 有一个数组 int [] x = new int[] &#123;1,2,3,4,5,6,7&#125;; //⑵ //2. 数组内部元素头尾对应互换// for(int i=0;i&lt;array.length/2; i++) &#123;// int temp = array[i];// array[i] = array[array.length-1-i];// array[array.length-1-i] = temp;// &#125; //2. 利用tf对象调用方法执行操作 int[] result = t.changeArrayElements(x); //⑶- ⑹ //3. 验证看一看结果 for(int v:result) &#123; System.out.println(v); &#125; &#125;&#125; TestFunctions.java 1234567891011121314151617package Parameters_ReturnValues;/* * 【交换数组内部头尾元素】 * 是否需要参数及返回值—— 参数：一个数组 / 返回组：需要 */public class TestFunctions &#123; public int[] changeArrayElements(int[] array) &#123; //2. 数组内部头尾元素互换 for(int i=0; i&lt;array.length/2;i++) &#123; int temp = array[i]; array[i] = array[array.length-1-i]; array[array.length-1-i] = temp; &#125; return array; &#125;&#125; 3. 寻找数组中的最大值、最小值 Demo3.java 123456789101112131415161718192021package Parameters_ReturnValues;/* * 【③.寻找数组中的极值（最大值 最小值）】 */public class Demo3 &#123; public static void main(String[]args) &#123; // 隐藏过程 加载类 //0.创建一个对象 TestFunctions tf = new TestFunctions(); //1.有一个数组 int[] array =new int[] &#123; 1,3,4,5,9,0,8,6,4,2&#125;; //2. 调用方法 findMaxOrMinNum int resultMax = tf.findMaxOrMinNum(array, true); int resultMin = tf.findMaxOrMinNum(array, false); //3验证一下 System.out.println(&quot;数组中的最大值为&quot;+resultMax); System.out.println(&quot;数组中的最小值为&quot;+resultMin); &#125; &#125; TestFunctions.java() 1234567891011121314151617181920212223 /* ③【寻找数组中极值】 * 是否需要参数及返回值 —— 参数：一个数组 / 返回值：肯定需要一个值 */public class TestFunctions &#123; //③. 寻找极值 public int findMaxOrMinNum(int[] array, boolean flag) &#123; //flage==true最大值 flag==false最小值 //2.找一个变量 int temp= array[0]; //3.利用遍历数组的方式挨个与max比较 for(int i=0; i&lt;array.length;i++) &#123; if(flag &amp;&amp; array[i]&gt;temp) &#123; temp = array[i]; &#125; else if(!flag &amp;&amp; array[i]&lt;temp) &#123; temp = array[i]; &#125; &#125; return temp; &#125;&#125; 4. 寻找给定元素是否在数组内存在（Scanner输入) Demo4.java 1234567891011121314151617181920212223package Parameters_ReturnValues;/* * ④【设计一个方法，数组中是否存在给定元素】 * 需要参数:一个数组 / 需要返回值：String */import java.util.Scanner;public class Demo4 &#123; public static void main(String []args) &#123; //隐藏过程 加载类模板 //0. 创建对象 TestFunctions t = new TestFunctions(); //1.给定一个数组 int[] a = &#123;1,2,3,4,5,6,7,8,9,10&#125;; //2. 输入一个数 System.out.println(&quot;请输入一个整数，断数组中是否存在此数：&quot;); Scanner input = new Scanner(System.in); int element = input.nextInt(); //3.调用方法判断是否存在此数 String result2 = t.findElement(a,element); System.out.println(result2); &#125;&#125; TestFuctions.java 1234567891011121314public class TestFunctions &#123; //④ 寻找数组是否存在 public String findElement(int[] array, int num) &#123; String result = &quot;×：该元素不存在&quot;; for(int i=0;i&lt;array.length;i++) &#123; if(array[i]==num) &#123; result = &quot;√：该元素存在&quot;; break; &#125; &#125; return result; &#125;&#125; 设计了返回值类型：返回值必须有 if有可能没有 —— 会出错【编译检测的悲观性原则】 5. 合并两个数组 Demo5.java 123456789101112131415161718192021package Parameters_ReturnValues;/* * ⑤【合并数组】 * 参数：两个数组 / 返回值：新数组 */public class Demo5 &#123; public static void main(String []args) &#123; //加载类模板 //0.创建对象 TestFunctions t = new TestFunctions(); //1.给定两个数组 int [] a = &#123;1,2,3,4&#125;; int [] b = &#123;5,6,7,8&#125;; //2.调用方法合并数组 int[] array = t.mergeArray(a,b); //3. 测试 for(int v:array) &#123; System.out.println(v); &#125; &#125;&#125; TestFunctions.java 1234567891011121314public class TestFunctions &#123; //⑤合并数组 public int[] mergeArray(int[] a, int[]b) &#123; int[] newArray = new int[a.length+b.length]; for(int i = 0;i&lt;newArray.length;i++) &#123; if(i&lt;a.length) &#123; //0 1 2 3 newArray[i]=a[i]; &#125;else &#123;//4 5 6 7 newArray[i]=b[i-a.length]; &#125; &#125; return newArray; &#125;&#125; 6. 拆分一个数组：按最大值 Demo6.java 1234567891011121314151617181920212223package Parameters_ReturnValues;/* * ⑥ 【拆分数组：按最大值位置拆分】 * 参数：一个大的数组 / 返回值：一个二维数组（返回值只有一个 */public class Demo6 &#123; public static void main(String[] args) &#123; //*. 加载类模板 //0. 创建对象 TestFunctions t = new TestFunctions(); //1.给定一个数组 int[] array = &#123;1,2,3,4,9,6,7,8&#125;; //2.调用方法合并数组 int[][] newArray = t.splitArray(array); //3.查看 for(int[] arr:newArray) &#123; //遍历二维数组 for(int value:arr) &#123; System.out.print(value + &quot;\\t&quot;); &#125; System.out.println(); &#125; &#125;&#125; TestFunctions.java 1234567891011121314151617181920212223242526public class TestFunctions &#123; //⑥拆分数组 public int[][] splitArray(int[] a) &#123; int max = a[0]; //最大值 int index = 0; //最大值索引 int[][] b = new int[1][a.length]; //找出最大值索引位置 for(int i=0; i&lt;a.length; i++) &#123; if(a[i]&gt;max) &#123; max =a[i]; index = i; //2 &#125; &#125; //写入两个新数组 int[] newa = new int[index]; int[] newb = new int[a.length-index-1]; for(int i =0; i&lt;newa.length;i++) &#123; newa[i] = a[i]; &#125; for(int i =0; i&lt;newb.length;i++) &#123; newb[i] = a[index+i+1]; //跳过最大值，+1 &#125; //int[][] result = &#123;newa,newb&#125;; return new int[][] &#123;newa,newb&#125;; &#125;&#125; 7. 去掉数组中的0 Demo7.java 1234567891011121314151617181920package Parameters_ReturnValues;/* * ⑦【去掉数组中的0元素】 * 参数：一个数组 / 返回值：一个无零的数组 */public class Demo7 &#123; public static void main(String[] args) &#123; //*. 加载类模板 //0. 创建对象 TestFunctions t = new TestFunctions(); //1. 给定一个数组 int [] a = &#123;0,1,0,2,0,3,4,0&#125;; //2.调用去零方法 int[] reslut = t.removeZero(a); //3. 遍历查看 for(int v:reslut) &#123; System.out.println(v); &#125; &#125;&#125; TestFuntions.java 12345678910111213141516171819202122public class TestFunctions &#123; //⑦ 数组去零 public int[] removeZero(int[] a) &#123; //1.找零的个数 int count = 0; for(int i=0; i&lt;a.length; i++) &#123; if(a[i]!=0) &#123; count++; //记录非零元素个数 &#125; &#125; //2.创建指定长度数组 int[] newArr = new int[count]; //3. 将非零元素存入新数组 int index = 0; //控制新数组的索引变化 for(int i =0; i&lt;a.length; i++) &#123; if(a[i]!=0) &#123; newArr[index++] = a[i]; &#125; &#125; return newArr; &#125; 8. 创建一个数组存储2-100间的素数 Demo8.java 1234567891011121314151617181920212223242526272829package Parameters_ReturnValues;import java.util.Scanner;/* * ⑧ 【寻找2-100素数】 * 参数：素数的范围(begin-end) / 返回值：素数数组 */public class Demo8 &#123; public static void main(String[] args) &#123; //*. 加载类模板 //0. 创建对象 TestFunctions t = new TestFunctions(); //1.给定一个范围 Scanner input = new Scanner(System.in); System.out.println(&quot;给定一个范围，求出此范围内的所有素数：&quot;); System.out.print(&quot;起始：&quot;); int begin = input.nextInt(); System.out.print(&quot;结束：&quot;); int end = input.nextInt(); //2.调用素数方法 int[] result = t.findPrimeNum(begin,end); //3. 遍历输出 System.out.println(&quot;你给的范围：&quot;+begin +&quot;-&quot;+ end+&quot;内，素数有：&quot;); for(int v:result) &#123; System.out.println(v); &#125; &#125;&#125; TestFuntions.java 123456789101112131415161718192021222324252627282930313233343536public class TestFunctions &#123; //⑧ 找素数 // 非素数：n%i=0 public int[] findPrimeNum(int begin, int end) &#123; if(begin&lt;0||begin&gt;end) &#123; System.out.println(&quot;输入有误！&quot;); return null; &#125;else &#123; int[] arr = new int[(end-begin)/2]; int index = 0; for(int num=begin; num&lt;=end;num++) &#123; //让数字从begin到end来回变化 boolean b = false;//标记 for(int i = 2; i&lt;=num/2; i++) &#123; //每次变化：从2到这个数的一半查找 if(num%i==0) &#123; //是否整除 b=true; break; &#125; &#125; if(!b) &#123; arr[index++] =num; &#125; &#125; //将数组后面多余的0去掉 int[] primeNum = new int[index]; for(int i=0; i&lt;index; i++) &#123; primeNum[i]=arr[i]; &#125; arr = null; return primeNum; &#125; &#125; 9. 冒泡排序 Demo9.java 1234567891011121314151617181920package Parameters_ReturnValues;/* * ⑨【冒泡排序算法：升/降】 * 参数：数组 / 返回值：不需要。数组排序后索引值已改变，无需返回 */public class Demo9 &#123; public static void main(String[] args) &#123; //*. 加载类模板 //0. 创建对象 TestFunctions t = new TestFunctions(); //1. 给定一个数组 int[] a = &#123;2,3,1,5,4&#125;; //2.调用冒泡排序算法 t.bubbleSort(a,false); //3. 遍历查看 for(int v:a) &#123; System.out.println(v); &#125; &#125;&#125; TestFuntions.java 123456789101112131415public class TestFunctions &#123; //⑨ 冒泡排序 (从数组的底端 每一次冒出一个值） public void bubbleSort(int[] arr, boolean isAscend ) &#123; for(int i=1;i&lt;arr.length; i++) &#123; //控制执行的轮次 —— 数组的长度 for(int j=arr.length-1; j&gt;=i; j--) &#123; //控制比较次数 if( (isAscend==true &amp;&amp; arr[j]&lt;arr[j-1] ) || (isAscend==false &amp;&amp; arr[j]&gt;arr[j-1] ) ) &#123; int temp = arr[j]; arr[j] = arr[j-1]; arr[j-1] = temp; &#125; &#125; &#125;&#125; 12//可进行元素兑换的条件： (isAscend==true &amp;&amp; arr[j]&lt;arr[j-1] ) || (isAscend==false &amp;&amp; arr[j]&gt;arr[j-1] )) 10. 用户登录验证 Demo10.java 1234567891011121314151617181920212223package Parameters_ReturnValues;import java.util.Scanner;/* * ⑩【登录认证：二维数组做小数据库】 * 参数：用户名和密码 / 返回值：登陆结果 String */public class Demo10 &#123; public static void main(String[] args) &#123; //*. 加载类模板 //0. 创建对象 TestFunctions t = new TestFunctions(); //1. 用户给定用户名和密码 System.out.println(&quot;Please Enter your username:&quot;); Scanner input = new Scanner(System.in); String username = input.nextLine(); System.out.println(&quot;Please Enter your password:&quot;); String password = input.nextLine(); //2. 调用登录认证方法 String result = t.loginCheck(username, password); //3. 得出结果 System.out.println(result); &#125;&#125; TestFunctions.java 12345678910111213141516171819public class TestFunctions &#123; //⑩ 登录认证 private String[][] Userdata = &#123;&#123;&quot;peach&quot;,&quot;123&quot;&#125;, &#123;&quot;equne&quot;,&quot;520&quot;&#125;&#125;; //🔺 public String loginCheck(String name, String pass) &#123; //0. 已有的数据库 //String[][] Userdata = &#123;&#123;&quot;peach&quot;,&quot;123&quot;&#125;, &#123;&quot;equne&quot;,&quot;520&quot;&#125;&#125;; String result = &quot;用户名或密码错误&quot;; //1.验证用户名和密码同时满足 for(int i=0; i&lt;Userdata.length; i++) &#123; if(Userdata[i][0].equals(name) &amp;&amp; Userdata[i][1].equals(pass)) &#123; result = &quot;登录成功&quot;; &#125; break; &#125; return result; &#125;&#125;"},{"title":"面向对象 - 构造方法 \\ 块 \\ this","date":"2021-07-25T09:07:39.352Z","updated":"2020-07-12T17:28:17.000Z","comments":true,"path":"wp-java/zero/13_Object_oriented-Constructor_block_this.html","permalink":"https://equnee.github.io/wp-java/zero/13_Object_oriented-Constructor_block_this","excerpt":"","text":"[TOC] 利用类描述现实生活中的事情 利用对象去具体的执行操作 🔺一个类的描述 ② 属性 —— 静态描述类的特征（变量 存值） name ① 方法 —— 动态描述类的行为（做事情）eat ③ 构造方法 —— 用来创建当前类的对象 ④ 程序块(代码块) —— 理解为就是一个方法（非常特殊：无参数 无修饰符 无返回值 无名字） （ ⑤ this关键字的作用 —— 用来代替某一个对象 （⑥ 类的加载对象的创建（内存原理 机制） 类中四成员1. 属性 静态描述特征（存值） 值若不写，有默认值 1权限修饰符 [特征修饰符] 属性类型 属性名字 [=值]; 2. 方法 动态描述行为（做事情） 最主要的是 方法设计的参数和返回值问题 —— 传递 调用 执行 内存 方法重载overload (一个类中，一组方法：名字相同 参数列表不同(个数/类型/顺序)) 动态参数列表 1权限修饰符 [特征修饰符] 返回值类型 方法名字 ([参数列表]) [抛出异常] [&#123;方法体&#125;] 3. 构造方法 唯一作用——创建当前类对象（做事情） 结构和写法：无返回类型，有返回值 调用：通过new关键字 特点：每一个类都有默认无参数的构造方法，我们自定义了新的，默认的构造方法即被覆盖 1权限修饰符 与类名相同的方法名 ([参数列表]) [抛出异常] &#123;方法体&#125; 4. 程序块(代码块) 可以理解为一个特殊的方法 （没有修饰符，没有返回类型，没有名字，没有参数）只有一个方法的执行体 {} 程序块是每一次调用构造方法之前都会默认，自动执行（无需调用 构建对象前调用） 程序块没有重载，却可以存在多个，按照创建的顺序逐一执行 123&#123; //方法体&#125; this关键字的使用 指代词 —— 代替的是调用属性/方法时的当前对象 this既然是一个对象，可以调用一般的属性，可以调用一般的方法 放置在类成员的任何位置（四个成员都可以） 方法间来回调用？？—— 写法可以(可编译)，执行可能产生 栈溢出错误 1Exception in thread &quot;main&quot; java.lang.StackOverflowError Exception 异常——人为规定的一种不正常现象 编译时异常 运行时异常 Error 错误 —— 计算机根本处理不了了，内存溢出 this 也可以调用构造方法 this(xxx); 将这一行代码放在另一个构造方法内，需要在第一行 构造方法不能来回互相调用（等待继承讲解） Person.java 1234567891011121314151617181920212223242526package classDemo;public class Person &#123; public String name; public int age; public String sex; public Person() &#123; //构造方法 this(1); System.out.println(&quot;我是人类的构造方法&quot;); &#125; public Person(int a) &#123; //构造方法 //this(); 不可编译（继承 System.out.println(&quot;我是人类的构造方法&quot;); &#125; public void eat() &#123; this.sleep(); System.out.println(&quot;这是人类的吃饭方法&quot;); &#125; public void sleep() &#123; //this.eat(); 可编译，不可运行 System.out.println(&quot;这是人类的睡觉方法&quot;); &#125;&#125; Test.java 123456789package classDemo;public class Test &#123; public static void main(String[]args) &#123; Person p = new Person(); p.eat(); &#125;&#125; 构造方法1. 作用只有一个，构造(构建)当前类的对象 (在内存中开辟一个空间) 2. 写法 1234权限修饰符 与类名一致的方法名 (参数列表) [抛出异常]&#123; 一件事情 创建一个对象（当前类Person） 返回对象;//(返回值) 有返回值，固定为当前对象类型&#125; 3. 调用 1Person p = new Person(); 4. 特点 每个类中都有构造方法，若在类中没有定义，系统会默认提供一个无参数的构造方法 若在类中自己定义了构造方法，则系统默认的无参构造方法即被覆盖 构造方法是否存在方法重载？—— 存在构造方法重载 5. 为何使用？何使使用？ 在创建对象的同时，想要一并做一些事情，默认提供的构造方法是不会做的，此时我们可以自定义构造方法。（无参数的构造方法内做事，也可以定义带参数的） 代码 Person.java 12345678910111213141516171819202122package construction_Method;/* * 【写法】权限修饰符 与类名一致的方法名(参数列表)[异常]&#123;方法体&#125; 只有这一种特殊的方法 名字是大大写字母 【少了：】 特征修饰符(没有) / 返回值类型(结构没有) */public class Person &#123; public String name; public String sex; public int age; public Person(String n, String s, int a)&#123; //创建了一个对象（开辟空间） name = n; sex = s; age = a; //返回了创建的这个对象的引用 &#125;&#125; Test.java 1234567891011package construction_Method;public class Test &#123; public static void main(String[] args) &#123; //调用Person类中的构造方法 //建议：以后若自己定义带参数的构造方法， // 将系统提供的默认无参构造方法也一起写出来，构成方法重载 Person p = new Person(&quot;蜜桃&quot;, &quot;女&quot;, 22); //结构上没有返回值类型，实际上有返回值：对象类型 System.out.println(&quot;我的名字是&quot;+p.name+&quot;，性别&quot;+p.sex+&quot;，今年&quot;+p.age+&quot;岁&quot;); &#125;&#125; 类的关键字关键字构造方法中，属性与方法变量重名，必须需要一个替代词，替代对象 this关键字 是一个关键字(指代词) 代替的是某一个对象，当前调用方法时的那个对象。（参数和属性重名时） 表示当前对象的属性，建议都写 1234public Person(String name, String sex, int age)&#123; this.name = name; //对象 = 变量 &#125; 代替的是一个对象① 可以调用 属性 方法② 可以调用构造方法 构造方法可以重载 只能在一个构造方法内调用另一个构造方法。 只能在程序的第一行 （因为 构造方法早于一般方法 有顺序） ③ 不可以在一般方法内调用构造方法④ 调用的过程放在哪个位置？—— 调用属性或方法时 此代码可放置在类中的任何成员位置 程序块(代码块) { }1. 作用跟普通方法一样，做事情的 2. 写法可以认为程序块是一个没有修饰符 没有返回值 没有参数 没有名字 的特殊方法 123&#123; System.out.println(&quot;我是一个普通的程序块&quot;);&#125; 3. 用法块也需要调用才能执行，我们自己调用不到（因为没有名字） 每一次我们调用构造方法之前，系统会帮我们自动调用一次程序，让她执行一遍 4. 特点 无重载的概念（因为无名字 无参数） 但可以在类中定义 多个程序块 可以在里面写一些程序，在创建对象之前执行 练习补充：Scanner 导包 java.util 创建对象 Scanner = input = new Scanner(System.in); 做事情 int value = input.input.nextInt(); ​ String value = input.nextLine(); nextLine() 方法会以回车符为截止，读取回车符+之前的所有字符，将回车符扔掉，把之前所有字符组合成一个完整的字符串，交换给我们 【只有nextLine读取回车符】 nextInt() （nextFloat、nextDouble、nextByte） 方法会以回车符为截止，读取回车符之前所有字符，回车符留在队列中 【消息队列】 nextLine() -&gt; nextInt() 游 蜜 桃 回车 1 2 3 回车 nextInt() -&gt; nextLine() 1 2 3 回车 ① next() a b c 空格 1 2 3 空格 e q nextLine() a b c 空格 1 2 3 空格 e q e ① ①nextLine读取到了回车，保存结果为&quot;&quot;，不再等待下一步的用户输入 ① scannerTest.java ——==正常 √== 阻塞效果，等待输入 1234567891011121314151617181920import java.util.Scanner;//nextLine() -&gt; nextInt()public class TestScanner &#123; public static void main(String[]args) &#123; //利用数组实现用户登录 //1.小数组充当数据库 //2.利用Scanner让用户输入 Scanner input = new Scanner(System.in); System.out.println(&quot;请输入账号&quot;); String name = input.nextLine(); //阻塞效果：input这个小人在计算机中的消息队列内等着读取 System.out.println(&quot;请输入密码&quot;); int password = input.nextInt(); //3.比较 System.out.println(&quot;接收到了账号：&quot;+ name); System.out.println(&quot;接收到了密码：&quot;+ password); &#125;&#125; ② scannerTest.java —— ==不正常 ×== 未阻塞，还没输入就读取到东西了 1234567891011121314151617181920import java.util.Scanner;//nextInt() -&gt; nextLine()public class TestScanner &#123; public static void main(String[]args) &#123; //利用数组实现用户登录 //1.小数组充当数据库 //2.利用Scanner让用户输入 Scanner input = new Scanner(System.in); //input这个小人在计算机中的消息队列内等着读取 System.out.println(&quot;请输入密码&quot;); int password = input.nextInt();//阻塞效果 System.out.println(&quot;请输入账号&quot;); String name = input.nextLine(); //没有阻塞说明读取到东西了 //3.比较 System.out.println(&quot;接收到了账号：&quot;+ name); System.out.println(&quot;接收到了密码：&quot;+ password); &#125;&#125; ③ 解决方案 补充一行nextLine，将nextInt留下的回车符回收，让下一个nextLine正常读取 next()，从前面的回车之后才开始读取 统一使用 nextLine() 读取账号和密码 String –&gt; int 数据类型转化问题。前提：同种大数据类型一致（基本=基本/引用-引用） 【 基本 &lt;— 包装类 —&gt; 引用 】 int—Integer char—Character byte—Byte float—Float int –&gt; String 字符串拼接 1/*面试题*/ System.out.println( 5 + 5 + &quot;5&quot; + 5 + 5); //=&gt; &quot;10555&quot; 1234567891011121314151617181920212223242526import java.util.Scanner;public class TestScanner &#123; public static void main(String[]args) &#123; //利用数组实现用户登录 //1.小数组充当数据库 //2.利用Scanner让用户输入 Scanner input = new Scanner(System.in); //input这个小人在计算机中的消息队列内等着读取 System.out.println(&quot;请输入密码&quot;); String password = input.nextLine(); // ⑴ —— 补充一行nextLine，将nextInt留下的回车符回收，让下一个nextLine正常读取 //input.nextLine(); // ⑵ —— next()，从前面的回车之后才开始读取 // ⑶ —— 统一使用nextLine()读取账号和密码 //String --&gt; int 数据类型转化问题。前提：同种大数据类型一致（基本=基本/引用-引用） //【 基本 &lt;— 包装类 —&gt; 引用 】 int—Integer char—Character byte—Byte float—Float int value = Integer.parseInt(password); System.out.println(&quot;请输入账号&quot;); String name = input.nextLine(); //没有阻塞说明读取到东西了 //3.比较 System.out.println(&quot;接收到了账号：&quot;+ name); System.out.println(&quot;接收到了密码：&quot;+ value); &#125;&#125; 1. 模拟计算器 加减乘除 方法 计算方法 控制台输出： 请输入第一个数 1 请输入符号 + 请输入第二个数 2 3 请输入第二个数 2 1 TestCalculator.java 1234567891011package classDemo;public class TestCalculator &#123; public static void main(String[] args) &#123; Calculator c = new Calculator(); c.calculate(); &#125;&#125; Calculator.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package classDemo;import java.util.Scanner;import javax.jws.Oneway;public class Calculator &#123; //设计一个方法——加法计算 //参数——两个元素 / 返回值 —— 计算结果 public float add(float a,float b) &#123; return a + b; &#125; //减法 public float substract(float a, float b) &#123; return a - b; &#125; //乘法 public float multiply(float a, float b) &#123; return a * b; &#125; //除法 public float divide(float a, float b) &#123; return a / b; &#125; //控制流程 public void calculate() &#123; Scanner input = new Scanner(System.in); System.out.println(&quot;请输入第一个数：&quot;); //String num1 = input.nextLine(); //float one = Float.parseFloat(num1); float a = Float.parseFloat(input.nextLine()); while(true) &#123; //for(::)&#123;&#125; System.out.println(&quot;请输入符号：&quot;); String symbol = input.nextLine(); //退出死循环 if(symbol.equals(&quot;=&quot;)) &#123; System.out.println(&quot;执行完毕&quot;); break; &#125; //符号 if(!(symbol.equals(&quot;+&quot;)||symbol.equals(&quot;-&quot;)|| symbol.equals(&quot;*&quot;)||symbol.equals(&quot;/&quot;)))&#123; System.out.println(&quot;输入符号有误&quot;); continue; &#125; System.out.println(&quot;请输入第二个数：&quot;); float b = Float.parseFloat(input.nextLine());//可能会产生NumberFormatException //判断符号计算 switch (symbol) &#123; case &quot;+&quot;: a =this.add(a, b); System.out.println(a); break; case &quot;-&quot;: a =this.substract(a, b); System.out.println(a); break; case &quot;*&quot;: a =this.multiply(a, b); System.out.println(a); break; case &quot;/&quot;: a =this.divide(a, b); System.out.println(a); break; default: System.out.println(&quot;输入错误&quot;); break; &#125; &#125; &#125;&#125; 2. 替代数组 （数组是一个开发者创建好的类型）数组长度是固定的，存储一组元素。数组长度一旦固定，使用起来不太方便。 创建数组对象 1int[] array = new int[10]; 添加元素 1array[0]=10; 获取元素 1int value = array[0]; //通过异常说明获取不到 遍历元素 123for(int i=0; i&lt;array.legnth; i++)&#123; array[i];&#125; 设计一个类——充当小容器 ArrayBox (不用管长度的问题) 能添加元素，获取元素，删除元素，看看有几个 创建一个ArrayBox对象 1ArrayBox box = new ArrayBox(); 设计方法，添加元素 你们是使用者(用户) 想要存储椅子，我是ArrayBox类型的一个具体对象 从前 —— 直接找到数组那个人，存储时自己找位置，若数组存满了自己想办法 现在 —— 你们直接把椅子交给我box，我帮你们存起来，至于我把椅子存在哪，长度够不够都不用你们管 提供条件(参数) —— 一把椅子int / 返回结果(返回值) ——告知存储结果 boolean 1box.add(10); 设计方法，获取元素 1box.get(2); 设计方法，删除元素 1box.remove(2); Test.java 123456789101112131415161718192021222324252627282930313233343536373839package arrayBox;import javax.lang.model.element.Element;/* * 相当于用户（你们） * 想要存储元素 ——&gt; 第一个是数组[] 第二个是ArrayBox */public class Test &#123; public static void main(String[] args) &#123; //1. 创建一个box对象 ArrayBox&lt;Integer&gt; box = new ArrayBox();//存储后长度还能改变 //ArrayBox&lt;E&gt; —— 创建的同时规定类型 //2. 让box干活 —— 存储一个元素(int 小椅子) for(int i=1; i&lt;=6; i++) &#123; box.add( i * 10); &#125;//10 20 30 40 50 60 0 0 0 0 System.out.println(&quot;有效元素个数：&quot; + box.size()); //System.out.println(&quot;真实数组长度：&quot; + box.elementData.length);//elementData:不可视 Priavte //3. 获取第二个元素 //int value = box.get(11); //System.out.println(&quot;box内的第二个位置的元素：&quot; + value); //3. 获取全部元素 for (int i = 0; i &lt; box.size(); i++) &#123; int value = box.get(i); System.out.print(value + &quot; &quot;); //10 20 30 40 50 60 &#125; System.out.println(); //4. 删除2号索引位置的元素 int removeValue = box.remove(2); System.out.println(removeValue); //30 System.out.println(box.size());//5 for (int i = 0; i &lt; box.size(); i++) &#123; int value = box.get(i); System.out.print(value + &quot; &quot;); //10 20 30 40 50 &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129package arrayBox;public class ArrayBox&lt;E&gt; &#123; //arrayBox&lt;E&gt; 泛型——什么都能存，你规定什么存什么 //【属性】 private static final int DEFAULT_CAPACITY = 10; private Object[] elementData; //一间小教室 //Object类：最大的父类，什么都能存 private int size = 0; //记录教室中有效的元素个数 //【构造方法】（若用户不知道长度时调用） public ArrayBox() &#123; elementData = new Object[DEFAULT_CAPACITY]; //elementData = new [DEFAULT_CAPACITY]; &#125; //构造方法重载：（若用户知道长度时调用） public ArrayBox(int capacity) &#123; elementData = new Object[capacity]; &#125; //【方法】 //2.2 设计一个方法 帮忙判断给定index范围是否合法，小D同学 // 参数 —— 需要一个index private void rangeCheck(int index) &#123; if(index&lt;0 || index&gt;=size) &#123; //参考数组的操作 自定义一个异常（自己创建的类）来说明这个问题 throw new BoxIndexOutOfBoundException(&quot;Index&quot; + index + &quot;,Size:&quot; + size); &#125; &#125; //1.2. 设计一个方法 帮我做事的，小A同学 // 参数—— 老师需要的最小容量 // 返回值 —— 无 private void ensureCapacityInternal(int minCapacity) &#123; if(minCapacity - this.elementData.length &gt; 0) &#123; //证明老师需要的最小容量，必原来教室的容量还大，存不下啦 //扩容 —&gt; 小B同学 this.grow(minCapacity); &#125; &#125; //1.3. 设计一个方法 帮教室扩容（新教室），小B同学 — 数学很好但倔强的天才 // 参数—— 老师需要的最小容量 // 返回值—— private void grow(int minCapacity) &#123; //获取旧教室的长度 int oldCapacity = elementData.length; //小B同学 做了一个觉得很好的算法 —— 旧教室的1.5倍扩容 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //oldCapacity*1.5 //&gt;&gt;右位移：乘2的一次幂 | &lt;&lt;左位移，除2 //若按照这个很好的算法扩容后 还达不到要求，所需空间还不够 —— 直接利用minCapacity if(newCapacity - minCapacity &lt; 0) &#123; newCapacity = minCapacity; //将老师提供的值赋给newCapicity &#125; //经过一通计算，最终获取一个合理的长度 newCapicity //按照这个新长度创建一个新的教室，旧教室的椅子全部搬入到新教室中 elementData = this.copyOf(elementData, newCapacity); //小C同学做完事情后，得到一个新教室 &#125; //1.4. 设计一个方法 负责创建一个新数组，小C同学 // 将旧数组的元素全部移入新数组内，干体力活的 // 参数 —— 新数组的长度、需要提供旧数组 // 返回值 —— 告知新数组的位置：返回新数组 private Object[] copyOf(Object[] oldArray, int newCapavity) &#123; //创建一个新数组（新的小教室） Object[] newArray = new Object[newCapavity]; //将旧数组全部移入新数组 for(int i =0; i&lt;oldArray.length; i++) &#123; newArray[i] = oldArray[i]; &#125; //将新数组返回 return newArray; &#125; //===================================================== //1. [ 添加元素 ] // 参数——int // 返回值 —— boolean 结果 public boolean add(E element) &#123;//E：在创建box对象时规定的类型 //确保我自己的属性数组的内部容量 —— 再设计一个方法帮我数容量 小A同学 this.ensureCapacityInternal(size+1);//原来教室的椅子格式+1 //如果上面代码可执行完毕 ——&gt; elementData肯定有空间 //把element存入elementData里 有效元素多记录一个 elementData[size++] = element; //告知用户存储成功 return true; &#125; //====================================================== // 2. [ 获取元素 ] // 参数 —— 提供获取元素的位置 // 返回值—— 获取位置上的那个元素（int——小椅子） public E get(int index) &#123; //检测index范围是否合法 this.rangeCheck(index); //找到小D同学帮忙检测 //如果上一行代码可以走过去，证明index合法 return (E) elementData[index]; &#125; //====================================================== //3. [ 删除元素 ] // 参数 —— 元素的位置 // 返回值 —— 删除掉的那个元素 public E remove(int index) &#123; //检测index范围 this.rangeCheck(index); //如果上一行代码可以走过去，没有异常，证明index合法 E oldValue = (E)elementData[index]; // 10 20 30 40 50 60 0 0 0 0 ---&gt;有效元素 //要求删掉30 box.remove(2); // 10 20 30 50 60 0 0 0 0 0 ---&gt; size 5个 for(int i =index; i&lt;size-1; i++) &#123; //从index开始，至size-1为止，将后面元素依次前移，往前覆盖 elementData[i] = elementData[i+1]; &#125; //将旧值返回给元素//10 20 30 40 50 60 60 0 0 0 0 elementData[--size] = null;//(有效位-1 return oldValue; &#125; public int size() &#123; //公开的，用户可访问 return size; &#125; //【程序块】&#125;"},{"title":"数组","date":"2021-07-25T09:07:39.354Z","updated":"2020-07-12T17:12:20.000Z","comments":true,"path":"wp-java/zero/7_array.html","permalink":"https://equnee.github.io/wp-java/zero/7_array","excerpt":"","text":"[TOC] 数组数组是一组数据类型相同的数据的组合，将这些数据统一的管理起来 数组の特点 数组是存储在堆内存中的一串连续的地址，用来存储一组相同数据类型的数据的容器，将一组数据统一管理起来 本身是引用数据类型。数组内能存储 引用 / 基本 数据类型 数组初始化时必须指定 数组长度 new关键字：在堆内存中申请开辟一块新空间 （堆内存）数组长度一旦确定，不再改变 （栈内存）存储的是地址引用 栈内存 堆内存 存储区 H 100 x 空间内存储的是：地址引用：hashCode 基本类型变量空间存储的是值，传递的就是值。一个变量改变，另一个不会跟着改变。 引用类型变量空间存储的是地址(引用) 传递的就是引用。一个改变，另一个跟着改变。 数组定义(声明)数据类型[] 数组名字 int[] x; char[] y; boolean[] z; String[] m; 数组赋值(初始化)静态初始化int [] array = new int[] &#123;10,20,30,40,50&#125; int [] array = &#123;10,20,30,40,50&#125; 有长度，有元素内容 12List&lt;String&gt; List = new ArrayList&lt;String&gt;(); //ListIterator&lt;String&gt; it = lisy.iterator; //迭代器 动态初始化int [] array = new int[5] 有长度，没有元素（不是真没有：默认值） 数据类型 默认值 整数 0 浮点 0.0 char 0 boolean false 引用数据类型 null 12数组长度&lt; 0 异常：NegativeArraySizeException 运行时异常：创建数组长度时给了负数，数组长度不合法 数组元素访问 取得：int value = array[4]; 存入： array[3] =400; 通过元素在数组中的位置访问：index索引 [ 0 ~ 数组长度-1 ] 开始 结束 1超出范围异常：ArrayIndexOutofBoundsException 数组元素的遍历(轮询) 增强for循环 for （ 自定义变量名 : 遍历的数组集合array ）&#123; &#125; 不使用索引； 只能取，不能存，不能找到具体某值 123for (int value : array)&#123; //value 接收数组值 System.out.println(value); &#125; *普通循环 * √：使用索引，可存取，可方便找到某一个元素的位置； ×：每次输出时，容易因出错而终止输出 1234for (int index = 0; index &lt; 5; index++ )&#123; int value = array[index]; System.out.println(value);&#125; [ csdn传送门 ] 数组本身是一个引用数据类型 内存结构的问题 基本数据类型和引用数据类型的区别 数组练习 0. 存储1-100之间的偶数1234567891011121314public class test&#123; public static void main(String[] args)&#123; //1.创建一个数组 int [] array = new int[50]; //2.将1-100之间的 for(int i=0;i&lt;array.length;i++)&#123;//执行50次 array[i] = 2*i+2 &#125; //3.输出验证 for(int v:array)&#123; System.out.println(v); &#125; &#125; &#125; 【程序设计时出现的小问题】 创建数组 静态：元素个数较少 动态：元素个数多，有规律 存取值循环分开： 存放时直接看结构可能由于存放误操作（看时正确，之后发生变化 存放时不一定必须要查看。 1. 两个数组元素位置互换 对应元素位置互换 直接交换数组地址 1234567891011121314151617181920212223242526272829303132public class Test&#123; // ① 给定两个数组a&#123;1,2,3,4&#125; b&#123;5,6,7,8&#125; 将两个数组内元素对应位置互换 public static void main(String[] args)&#123; //1.创建两个数组 int[] a =&#123;1,2,3,4&#125;; int[] b =&#123;5,6,7,8&#125;; //2.元素对应位置互换，每次交换两个数字，换四次 //方式一：交换数组中对应元素（循环次数好多次，受长度限制） /*for(int i=0;i&lt;a.length;i++)&#123; //控制四次 int x = a[i]; a[i] = b[i]; b[i] =x ; &#125;*/ //方式二：直接交换变量a和b中的数组引用(地址)，没有循环 一次搞定 不受长度限制 int[] temp = a; //hashCode a = b; b = temp; //3.分别输出两个数组元素 for(int v:a)&#123; System.out.println(v); &#125; System.out.println(&quot;--------&quot;); for(int v:b)&#123; System.out.println(v); &#125; &#125;&#125; 2. 一个数组元素头尾位置互换12345678910111213141516171819public class Test&#123; // ② 给定一个数组a&#123;1,2,3,4,5,6&#125; 将这个数组内元素头尾对应位置互换 public static void main(String[] args)&#123; int[] array = &#123;1,2,3,4,5,6,7&#125;; for(int i=0; i&lt;array.length/2; i++)&#123; int x = array[i]; array[i]= array[(array.length-1)-i]; array[(array.length-1)-i] = x; &#125; for(int v:array)&#123; System.out.println(v); &#125; &#125;&#125; 4. 数组最值123456789101112131415161718192021222324public class Test&#123; // ④ 给定一个数组 a&#123;1,3,5,7,9,0,2,4,6,8&#125; 找寻数组的最大值和最小值(极值问题) public static void main(String[] args)&#123; int [] a = &#123;1,3,5,7,9,0,2,4,6,8&#125;; //1.创建一个变量 记录信息 int min=a[0]; int max=a[0]; //2.挨个寻找数组中的元素，与变量中的元素进行比较 for( int i=0; i&lt;a.length; i++)&#123; if(a[i]&lt;min)&#123; min = a[i]; &#125; if(a[i]&gt;max)&#123; max= a[i]; &#125; &#125; System.out.println(&quot;数组中最小值：&quot;+min); System.out.println(&quot;数组中最大值：&quot;+max); &#125;&#125; 5. 数组合并123456789101112131415161718192021222324252627282930313233 public class Test&#123; // ⑤ 合并两个数组 a&#123;1,2,3&#125; b&#123;4,5&#125; （创建一个新的数组5长度） public static void main(String[] args)&#123; //1.创建两个数组 int[] a = &#123;1,2,3&#125;; int[] b = &#123;4,5&#125;; //2.因为数组长度一旦确定 不能更改 需要创建一个新数组 int[] newArray = new int[a.length + b.length]; //只有长度 元素默认值0 //3.【思路二】想要将新数组填满（按照新数据循环） for(int i=0;i&lt;a.newArray.length;i++)&#123; if(i&lt;a.length)&#123; //a数组范围内 newArray[i] = a[i]; &#125;else&#123;//b数组范围内 newArray[i] = b[i-a.length]; &#125; //3.【思路一】分别将a和b数组中的元素存入新数组内（按照旧数组循环） for(int i=0;i&lt;a.length;i++)&#123;//将所有a数组元素存入新数组内 newArray[i] = a[i]; &#125; //newArray---&gt;&#123;1,2,3,0,0&#125; for(int i=0;i&lt;b.length;i++)&#123;//将b数组元素取出来 存入新数组后面位置 newArray[a.length+i] = b[i]; &#125; //newArray---&gt;&#123;1,2,3,4,5&#125; //4.验证 for(int v:newArray)&#123; System.out.println(v); &#125; &#125;&#125; 6. 数组拆分（按照最大值位置123456789101112131415161718192021222324252627282930313233343536373839public class Test&#123; // ⑥ 拆分给定数组 a&#123;1,2,3,9,4,5&#125; 按照数组中最大值位置，拆分成&#123;1,2,3&#125;&#123;4,5&#125; public static void main(String[] args)&#123; //1.需要一个数组 int[] oldArray = &#123;1,2,3,9,4,5&#125;; //2.找寻最大值的索引位置 -&gt; 为了通过这个位置 确定两个小数组的长度 int max = oldArray[0]; //数组的第一个元素值 int index = 0; //数组的第一个索引位置 for(int i=1;i&lt;oldArray.length;i++)&#123; if(oldArray[i]&gt;max)&#123; max = oldArray[i]; index = i; &#125; &#125; System.out.println(&quot;最大值&quot; + max); System.out.println(&quot;最大值位置&quot; + index); //3.需要两个小数组分别承载元素 int[] newa = new int[index]; int[] newb = new int[oldArray.length-index-1]; //4.分别将两个小数组填满 for(int i=0; i&lt;newa.length;i++)&#123; newa[i] = oldArray[i]; index = i; &#125; for(int i=0; i&lt;newb.length;i++)&#123; newb[i] = oldArray[(index+1)+i]; index = i; &#125; //5.验证 for(int v:newa)&#123; System.out.println(v); &#125; System.out.println(&quot;----&quot;); for(int v:newb)&#123; System.out.println(v); &#125; &#125;&#125; 扩展：多个最大值 - &gt; 新建数组保存数组位置 需要一个数组记录最大值的索引位置 7. 去掉数组中的0元素 12345678910111213141516171819202122232425262728293031public class Test&#123; //⑦ 给定一个数组a&#123;1,2,3,0,0,4,5,0,6,0,7&#125; 去掉元素中的0元素（创建一个新数组 短的 挑出非零元素） //1.需要一个数组 int[] oldArray = new int[]&#123;1,2,3,0,0,4,5,0,6,0,7&#125;; //2.找寻原数组中的非零元素个数 -&gt; 才能确定新数组长度 int count = 0; for(int i=0; i&lt;oldArray.length; i++)&#123; if(oldArray[i]!=0)&#123; count++; &#125; &#125; System.out.println(&quot;原数组中的非零元素个数:&quot; + count); //3.创建一个新数组 装载原数组中的非零元素 int[] newArray = new int[count]; //【思路二】-&gt; 创建一个足够长的数组 //4.将原数组中非零元素挑出 存入新数组 int index = 0; //🔺图↑：控制新数组的索引变化 for(int i=0; i&lt;oldArray.length; i++)&#123; if(oldArray[i]!=0)&#123; newArray[index++] = oldArray[i]; //index++; &#125; &#125; //5.旧数组我觉得没有用啦 删掉 oldArray = null; //5.验证 for(int v:newArray)&#123; System.out.println(v); &#125; &#125; &#125; 8. 存储2-100素数思路一1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class Test&#123; // ⑧ 创建一个数组 存储2-100间的素数（质数） public static void main(String[] args)&#123; //【思路一：时间长 执行效率低 空间占用率小】 //0.通过一个几千次循环找寻一个---count //1.创建一个数组 长度（刚好的 没有一个空间多余） //2.通过一个几千次循环找寻素数 将素数存入数组内 //0.找寻2-100之间素数的个数 -&gt; 确定数组长度 int count = 0; for(int num=2; num&lt;=100; num++)&#123; boolean b = false; //标识 用来记录最初的状态 for(int i=2;i&lt;=num/2;i++)&#123; //从2-8之间找寻还有没有其他可以整除的数字 if(num%i==0)&#123;//如果还有能整除的数字 证明num不是素数 //System.out.println(num + &quot;不是素数&quot;); b = true; //如果满足条件（找到整除 证明不是素数 改变标识 break; &#125; &#125; if(!b)&#123;//如果标识与最初的一致 证明循环内的if从来没有执行过 !b &lt;===&gt; b==false //System.out.println(num+&quot;是素数&quot;); count++; &#125; &#125; System.out.println(&quot;经过找寻，2-100之的素数个数为：&quot;+count); //1.创建一个数组 存素数 int[] primeNumberArray = new int[count]; //2.找寻2-100之间的素数 将找到的素数存入数组内 int index = 0; //创建一个新的变量 记录素数数组的索引变化 for(int num=2; num&lt;=100; num++)&#123; boolean b = false; //标识 用来记录最初的状态 for(int i=2;i&lt;=num/2;i++)&#123; //找寻还有没有其他可以整除的数字 if(num%i==0)&#123;//如果还有能整除的数字 证明num不是素数 //System.out.println(num + &quot;不是素数&quot;); b = true; //如果满足条件（找到整除 证明不是素数 改变标识 break; &#125; &#125; if(!b)&#123;//如果标识与最初的一致 证明循环内的if从来没有执行过 !b &lt;===&gt; b==false //System.out.println(num+&quot;是素数&quot;); primeNumberArray[index++] = num; &#125; &#125; //3.验证 for(int v:primeNumberArray)&#123; System.out.println(v); &#125; &#125;&#125; 思路二 √1234567891011121314151617181920212223242526272829303132333435public class Test&#123; // ⑧ 创建一个数组 存储2-100间的素数（质数） public static void main(String[] args)&#123; //【思路二：时间短 执行效率高 空间占用率长 √】 //0.创建一个足够长的数组 //1.通过几千次循环找素数 将素数存入数组 //2.将存入素数的数组 后面部分0元素去掉 int[] primeNumberArray = new int[50]; int index = 0; //记录素数数组的索引变化 同时记录素数个数 for(int num=2; num&lt;=100; num++)&#123; boolean b = false; //标识 用来记录最初的状态 for(int i=2;i&lt;=num/2;i++)&#123; //从2-8之间找寻还有没有其他可以整除的数字 if(num%i==0)&#123;//如果还有能整除的数字 证明num不是素数 //System.out.println(num + &quot;不是素数&quot;); b = true; //如果满足条件（找到整除 证明不是素数 改变标识 break; &#125; &#125; if(!b)&#123;//如果标识与最初的一致 证明循环内的if从来没有执行过 !b &lt;===&gt; b==false //System.out.println(num+&quot;是素数&quot;); primeNumberArray[index++] = num; &#125; &#125;//&#123;2,3,5,7,11,13.....0,0,0,0,0,0,0,0,0,0,&#125; int[] newArray = new int[index]; for(int i=0;i&lt;newArray.length;i++)&#123; newArray[i] = primeNumberArray[i]; &#125; primeNumberArray = null; for(int v:newArray)&#123; System.out.println(v); &#125; &#125;&#125; 9. 排序（冒泡） 排序本质：交换元素 （▲交换位置的条件 12345678910111213141516171819202122public class Test&#123; //&#123;5,2,3,1,4&#125;;//升序排列 —&gt; &#123;1,2,3,4,5&#125; public static void main(String[] args)&#123; int[] a = &#123;5,2,3,1,4&#125;; for(int i =1;i&lt;5;i++)&#123;//控制比较轮次，每一轮冒出来一个最小值 for(int j =4;j&gt;=i;j--)&#123;//从数组底端，一直必到顶端，4次 //最顶端最小，比过了 不用比了 if(a[j]&lt;a[j-1])&#123; int x = a[j]; a[j] = a[j-1]; a[j-1] = x; &#125; &#125; &#125; for(int v:a)&#123; System.out.println(v); &#125; &#125;&#125; 10. 用户登录认证（用数组当作小数据库 存值 用户验证） 需要一个存储真实账号密码的地方（小数组——充当数据库） 需要用户输入用户名和密码 比对 先比账号——账号是唯一存在的（主键primary key约束） 登录成功（都对啦） 密码错误 用户名不存在 1234567891011121314151617181920212223242526272829303132import java.util.Scanner;public class test&#123; public static void main(String[] args)&#123; //1.需要数组来存储，所有的账号密码（相当于小数据库） String[] userBox = &#123;&quot;蜜桃&quot;,&quot;peach&quot;,&quot;equne&quot;&#125;; int[] passwordBox = &#123;123,666,888&#125;; //2.需要用户输入 Scanner input = new Scanner(System.in); System.out.println(&quot;请输入账号：&quot;); String user = input.nextLine(); System.out.println(&quot;请输入密码：&quot;); int password = input.nextInt(); //3.比较 boolean b =false; //账号存在标记 for(int i =0;i&lt;userBox.length;i++)&#123; if(userBox[i].equals(user))&#123;//账号存在 if(passwordBox[i]==password)&#123; System.out.println(&quot;登录成功&quot;); &#125;else&#123; System.out.println(&quot;密码错误&quot;); &#125; b = true; break; //跳出循环，找到账号后断开 &#125; &#125; if(!b)&#123; System.out.println(&quot;用户名不存在&quot;); &#125; &#125;&#125; 简单优化： “用户名或密码错误” （更安全 1234567891011121314//3.比较 boolean b =false; //账号存在标记 for(int i =0;i&lt;userBox.length;i++)&#123; if(userBox[i].equals(user))&#123;//账号存在 if(passwordBox[i]==password)&#123; System.out.println(&quot;登录成功&quot;); b = true; &#125; break; //跳出循环，找到账号后断开 &#125; &#125; if(!b)&#123; System.out.println(&quot;用户名或密码错误&quot;); &#125;"},{"title":"语法结构","date":"2021-07-25T09:07:39.354Z","updated":"2020-07-12T17:11:11.000Z","comments":true,"path":"wp-java/zero/6_Grammatical_structure.html","permalink":"https://equnee.github.io/wp-java/zero/6_Grammatical_structure","excerpt":"","text":"[TOC] 1234567891011121. 可读性 1. 命名规范 2. 代码缩进 3. 多加注释2. 健壮性 1. 程序严谨3. 优化 1. 代码结构简单，减少冗余 2. 性能 内存空间问题 3. 提高效率（减少for循环次数） 4. 复用性 5. 可扩展性 语法结构(流程控制)顺序结构 按照顺序直接执行 分支结构单分支 if √ 可以写复杂逻辑 × 执行较慢 123if( /*值:boolean */ )&#123; 单行语句/多行语句;&#125; 单分支if-else结构 12345if( )&#123; &#125;else&#123; &#125; 嵌套 最初是嵌套在else内 123456789if( )&#123; &#125;else if( )&#123; &#125;else if( )&#123; ...&#125;else&#123; &#125; 多分支 switch × 只能做==比较（固定值） √ 判断固定值过程效率更高 12345678switch(值)&#123; //byte short int cahr 1.5+enum 1.7+String case 值1: //值1必须和值相等 代码1; case 值2: 代码1; default: 代码&#125; 从满足条件开始，下面都会按顺序执行。 break可中断 —— （使其成为单分支 continue 可继续执行 循环结构循环三要素：初始值 终点判定条件 变化量 for 允许将三要素写在括号里：也可以放在外面 123for( 初始值; 终点判定条件; 变化量)&#123; 代码;&#125; 12345//若初始化在for循环外，则变量能够找到for(【1】int i = 1; 【258】终点判定条件n; 【47】变化量) 【36】代码;&#125;System.out.println(&quot;n&quot;); //找不到变量了 变量的生命周期问题：循环结束后，栈内存空间内声明的变量空间清空，及时回收 若变化量放在循环内，可能会影响最终值 循环嵌套画星星： 12345678int count = 4;for(int i=1; i&lt;=4; i++)&#123; for(int j=1;j&lt;=count;j++)&#123; // 画三角形 ：for(int j=1; j&lt;=i; j++)&#123; System.out.println(&quot;*&quot;); &#125; System.out.println();&#125; i控制行数，j控制每个星星的个数 双层循环嵌套执行的次数是乘积关系 画占位符+星星 1234567891011121314public class Grammatical_structrue &#123; public static void main(String[] args) &#123; int count = 4; for(int i=1; i&lt;=4; i++)&#123; for(int j=1; j&lt;=4-i; j++)&#123; System.out.print(&quot;#&quot;); //&amp; &#125; for(int j=1; j&lt;=i; j++)&#123; System.out.print(&quot;*&quot;); //* &#125; System.out.println(); &#125; &#125;&#125; 关键字break在for内： 终止的是循环 123456for(int i=1; i&lt;=5; i++)&#123; if(i==3)&#123; break; //终止：当满足if条件的时候，终端循环 &#125; Syetem.out.println(i);&#125; 执行的结果是什么？ 12 执行完毕后，i的值应该是几？ 3 for嵌套内： 终止的当层的循环 普通的循环： 12345for(int i=1; i&lt;=5; i++)&#123; for(int i=1; j&lt;=5; j++)&#123; Syetem.out.println(&quot;peach&quot;); &#125;&#125; 循环执行了多少次？ 25 循环执行完毕，i和j分别是几？6 ， 6 加break的嵌套： 12345678for(int i=1; i&lt;=5; i++)&#123; for(int i=1; j&lt;=5; j++)&#123; if(j==3)&#123; break; //到内层时，j每次都是1 2 到3停住 &#125; Syetem.out.println(&quot;peach&quot;); &#125;&#125; 循环执行了多少次？ 10 循环执行完毕，i和j分别是几？6 ， 3 定义在外部的嵌套：12345678910int i = 1;int j = 1;for( ; i&lt;=5; i++)&#123; for( ; j&lt;=5; j++)&#123; if(j==3)&#123; break; //到内层时，j第一次1 2 到3之后一直停住。往后都是3 &#125; Syetem.out.println(&quot;peach&quot;); &#125;&#125; i == 2 ，j == ？ 3 循环执行了多少次？ 2 循环执行完毕，i和j分别是几？6 ， 3 continue 单层普通循环 123456for(int i=1; i&lt;=5; i++)&#123; if(i==3)&#123; continue; //终止本次循环 继续执行下一次循环 &#125; Syetem.out.println(i);&#125; 执行过程中i输出 1 2 4 5 执行循环完毕，最终i？6 嵌套循环12345678for(int i=1; i&lt;=5; i++)&#123; for(int i=1; j&lt;=5; j++)&#123; if(j==3)&#123; continue; //终止内层循环，j到3就停住，下一次j继续走到4 &#125; Syetem.out.println(&quot;peach&quot;); &#125; &#125; 循环输出多少次？20 执行完毕后，i和j？6, 6 定义在外部的嵌套 12345678910int i=1;int j=1;for(; i&lt;=5; i++)&#123; for(; j&lt;=5; j++)&#123; if(j==3)&#123; continue; //终止内层循环，j到3就停住，第一层走到6就停住，往后j都是6 &#125; Syetem.out.println(&quot;peach&quot;); &#125;//i==1 j==1245 ——&gt; i==2 j==6 ——&gt; i==345 j==6&#125; 循环输出多少次？4 (1 2 4 5) 执行完毕后，i和j？6, 6 循环标记12345678ok:for(int i=1; j&lt;=5; j++)&#123; ko:for(int j=1; j&lt;=5; j++)&#123; if(j==3)&#123; break ok; //终止外层ok循环，j到3就停住，外层也停住，i==1,j==3 &#125; Syetem.out.println(&quot;peach&quot;); &#125; &#125; 循环输出多少次？2 (1 2) 执行完毕后，i和j？1 3 while 就是for循环的变体，变量定义在循环外，生命周期长了，变化量放在循环内 括号只能放终点判定条件。（注意：上下的顺序可能对执行产生影响） 【与do while区别】先判断后执行，不满足就不执行了。 12345初始值;while(重点判定条件)&#123; ... 变化量;&#125; 例子 123456int i =1;while(i&lt;=5)&#123; System.out.println(&quot;执行中：&quot;+i); i++;&#125;System.out.println(&quot;执行完毕：&quot;+i); 执行输出？1 2 3 4 5执行完毕后i==6？ 上下顺序：若i++在执行上面：输出 2 3 4 5 6 i==6 do...while 【与 while区别】先执行后判断，条件不满足也至少执行一次 12345初始值;do&#123; ... 变化量;&#125;while(); 12345小总结：if(boolean值)&#123;&#125;switch(值)&#123;&#125;for(三要素)&#123;&#125;while()&#123;&#125; 代码if 1.判断月份对应季节我的写法： 12345678910111213141516171819202122import java.util.Scanner;public class Grammatical_structrue &#123; public static void main(String[] args) &#123; System.out.println(&quot;请输入一个喜欢的月份，看看是什么季节~&quot;); Scanner input = new Scanner(System.in); int month = input.nextInt(); if(month==3||month==4||month==5) &#123; //(month&gt;=3 &amp;&amp; month&lt;=5) System.out.println(&quot;是春天喔~🌼&quot;); &#125;else if(month==6||month==7||month==8) &#123; System.out.println(&quot;是夏天耶~🍨‍&quot;); &#125;else if(month==9||month==10||month==11) &#123; System.out.println(&quot;是秋天啦~🍂&quot;); &#125;else if(month==12||month==1||month==2) &#123; System.out.println(&quot;是冬天呢！❄&quot;); &#125;else &#123; System.out.println(&quot;再检查看看月份有没有输对喔_(:з)∠)_&quot;); &#125; &#125;&#125; 更优写法： 1234567891011121314151617181920212223import java.util.Scanner;public class Grammatical_structrue &#123; public static void main(String[] args) &#123; System.out.println(&quot;请输入一个喜欢的月份，看看是什么季节~&quot;); Scanner input = new Scanner(System.in); int month = input.nextInt(); if(month&lt;1||month&gt;12) &#123; System.out.println(&quot;再检查看看月份有没有输对喔_(:з)∠)_&quot;); &#125;else if(month&gt;=6&amp;&amp;month&lt;=8) &#123; System.out.println(&quot;是夏天耶~🍨‍&quot;); &#125;else if(month&gt;=9&amp;&amp;month&lt;=11) &#123; System.out.println(&quot;是秋天啦~🍂&quot;); &#125;else if(month&gt;=3&amp;&amp;month&lt;=5) &#123; System.out.println(&quot;是春天喔~🌼&quot;); &#125;else &#123; System.out.println(&quot;是冬天呢！❄&quot;); &#125; &#125;&#125; 2. 判断成绩区间1234567891011121314151617181920212223242526272829import java.util.Scanner;public class Grammatical_structrue &#123; public static void main(String[] args) &#123; for(int i=0;i&lt;=100;i++) &#123; System.out.println(&quot;🍑：请输入你的成绩，看看考得如何~&quot;); Scanner input = new Scanner(System.in); float point = input.nextFloat(); if(point&gt;=0&amp;point&lt;60) &#123; System.out.println(&quot;不及格啦，好好努力喔（；´д｀）ゞ&quot;); &#125;else if(point&gt;=60&amp;point&lt;70) &#123; System.out.println(&quot;及格啦，还要继续加油~(ง •_•)ง‍&quot;); &#125;else if(point&gt;=70&amp;point&lt;80) &#123; System.out.println(&quot;中！冲冲冲！(oﾟvﾟ)ノ&quot;); &#125;else if(point&gt;=80&amp;point&lt;90) &#123; System.out.println(&quot;良好，不错耶~♪(´▽｀)&quot;); &#125;else if(point&gt;=90&amp;point&lt;100) &#123; System.out.println(&quot;优秀！好棒！(´▽`ʃ♡ƪ)&quot;); &#125;else if(point==100)&#123; System.out.println(&quot;满分选手！太强啦！！(´▽`ʃ♡ƪ)&quot;); &#125;else&#123; System.out.println(&quot;再检查看看成绩有没有输对喔_(:з)∠)_&quot;); &#125; System.out.println(&quot;\\n------------------------------------&quot;); &#125; &#125;&#125; 2. 摇骰子我的写法： 12345678910111213141516171819202122232425262728293031323334353637import java.util.Scanner;public class Grammatical_structrue &#123; public static void main(String[] args) &#123; for(int i = 0;i&lt;100;i++) &#123; System.out.println(&quot;🎲来吧！猜大小！你的觉得会是大还是小呢：&quot;); Scanner input = new Scanner(System.in); String choice = input.nextLine().replaceAll(&quot;[\\\\pZ]&quot;, &quot;&quot;);//把空格省略 int number = (int)(Math.random()*6)+1; //生成随机数：math范围0-1 int result = 0; if(choice.equals(&quot;大&quot;)||choice.equals(&quot;小&quot;)) &#123; if (number==1||number==2||number==3) &#123; result = 0; System.out.println(&quot;骰子结果：&quot;+ number +&quot; ，是小耶！&quot;); &#125;else &#123; result = 1; System.out.println(&quot;骰子结果：&quot;+ number +&quot; ，是大耶！&quot;); &#125; if(choice.equals(&quot;大&quot;)&amp;result==0||choice.equals(&quot;小&quot;)&amp;result==1) &#123; System.out.println(&quot;【×】 啊哦，猜错啦~再试试吧！（；´д｀）ゞ&quot;); &#125;else &#123; System.out.println(&quot;【√】 哇，猜对啦！运气真好~ヽ(✿ﾟ▽ﾟ)ノ&quot;); &#125;&#125;else &#123; System.out.println(&quot;只能输入大或小喔，好好再输入一次吧~&quot;); &#125; System.out.println(&quot;——————————————————————&quot;); &#125; &#125;&#125; 更优写法： 1234567891011121314151617181920212223242526272829303132import java.util.Scanner;public class Grammatical_structrue &#123; public static void main(String[] args) &#123; for(int i = 0;i&lt;100;i++) &#123; System.out.println(&quot;🎲来吧！猜大小！你的觉得会是大还是小呢：&quot;); Scanner input = new Scanner(System.in); String choice = input.nextLine().replaceAll(&quot;[\\\\pZ]&quot;, &quot;&quot;);//把空格省略 int number = (int)(Math.random()*6)+1; //生成随机数：math范围0-1 if(choice.equals(&quot;大&quot;)||choice.equals(&quot;小&quot;)) &#123; //主要是这里：----------------------------- if(choice.equals(&quot;大&quot;)&amp;number&lt;=3||choice.equals(&quot;小&quot;)&amp;number&gt;=3) &#123; System.out.println(&quot;骰子结果：&quot;+ number +&quot; ，是小耶！&quot;+ &quot;【×】 啊哦，猜错啦~再试试吧！（；´д｀）ゞ&quot;); &#125;else&#123; System.out.println(&quot;骰子结果：&quot;+ number +&quot; ，是大耶！&quot;+ &quot;【√】 哇，猜对啦！运气真好~ヽ(✿ﾟ▽ﾟ)ノ&quot;); &#125; //---------------------------------------- &#125;else &#123; System.out.println(&quot;只能输入大或小喔，好好再输入一次吧~&quot;); &#125; System.out.println(&quot;——————————————————————&quot;); &#125; &#125;&#125; switch判断成绩区间我的写法： 12345678910111213141516171819202122232425262728293031323334353637383940import java.util.Scanner;public class Grammatical_structrue &#123; public static void main(String[] args) &#123; for(int i = 0; i&lt;100;i++) &#123; System.out.println(&quot;------------------------------------------\\n&quot; + &quot;🍑：请输入你的成绩，看看考得如何~&quot;); Scanner input = new Scanner(System.in); int score = (int)input.nextFloat();//可输入小数点分数 System.out.println(point); if(score&lt;0||score&gt;100) &#123; System.out.println(&quot;输入有误&quot;); &#125;else &#123; switch(score/10) &#123; case 6 : System.out.println(&quot;及格&quot;); break; case 7: System.out.println(&quot;中&quot;); break; case 8: System.out.println(&quot;良好&quot;); break; case 9: System.out.println(&quot;优秀&quot;); break; case 10: System.out.println(&quot;满分&quot;); break; default: System.out.println(&quot;不及格&quot;); &#125; &#125; //循环结束 &#125;&#125;&#125; 根据周几安排学习计划12345678910111213141516171819202122232425262728293031public class Grammatical_structrue &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); for(int i = 0;i&lt;100;i++) &#123; System.out.println(&quot;--------------------------------------\\n&quot; + &quot;来制定学习计划吧！想安排周几呢?&quot;); int day = input.nextInt(); if(day&lt;=0||day&gt;7) &#123; System.out.println(&quot;格式错误&quot;); &#125;else &#123; switch(day) &#123; case 7: System.out.println(&quot;今天好好休息吧~♪(´▽｀)&quot;); break; case 1: case 3: case 5: System.out.println(&quot;今天学习语文(╹ڡ╹ )&quot;); break; default: System.out.println(&quot;今天学习数学(╹ڡ╹ )&quot;); &#125; &#125; // &#125; &#125;&#125; for求甲乙丙丁加工零件数 甲乙丙丁四个人加工零件 加工的总零件数为370个 如果甲加工的零件数多10 如果乙加工的零件数少20 如果丙加工的零件数乘以2 如果丁加工的零件数除以2 则四个人加工的零件数就相等啦 求四个人加工的零件数分别是多少 12345678910111213141516import java.util.Scanner;public class Grammatical_structrue &#123; public static void main(String[] args) &#123; for(int x=0;x&lt;370;x++) &#123; //优化：(int x=45; x&lt;95; x++) if((x-10)+(x+20)+(2*x)+(x/2)==370) &#123; System.out.println(&quot;甲加工的零件数为：&quot;+(x-10)); System.out.println(&quot;乙加工的零件数为：&quot;+(x+20)); System.out.println(&quot;丙加工的零件数为：&quot;+(x/2)); System.out.println(&quot;丁加工的零件数为：&quot;+(x*2)); &#125; &#125; &#125;&#125; 鸡兔同笼 小鸡小兔共50只，脚总数160只。求小鸡小兔各多少只。 123456789101112import java.util.Scanner;public class Grammatical_structrue &#123; public static void main(String[] args) &#123; for(int x =0; x&lt;50;x++) &#123; if(2*x+(50-x)*4==160) &#123; System.out.println(&quot;兔子：&quot;+x); System.out.println(&quot;小鸡：&quot;+(50-x)); &#125; &#125; &#125;&#125; 水仙花数 1 5 3 1+123+27=153 寻找三位数字的水仙花数（100-999之间挨个尝试） 123456789101112131415161718import java.util.Scanner;public class Grammatical_structrue &#123; public static void main(String[] args) &#123; for(int num=100;num&lt;1000;num++) &#123; int a = num/100; int b = num/10%10; int c = num %10; if(a*a*a+b*b*b+c*c*c==num) &#123; //(Math.pow(a,3)+Math.pow(b,3)+Math.pow(a,3)) //(Math.pow(num/100,3)+Math.pow(num/10%10,3)+Math.pow(num %10,3)) System.out.println(num+&quot;是水仙花数&quot;); &#125; &#125; &#125;&#125; for嵌套画*#1234**********#*****###***#####* 123456789101112131415161718192021public class test &#123; public static void main(String[] args) &#123; for(int i=1; i&lt;=4; i++)&#123; if(i==1)&#123; System.out.print(&quot;*******&quot;); &#125;else&#123; for(int j=1; j&lt;=5-i; j++)&#123; System.out.print(&quot;*&quot;); //* &#125; for(int j=1; j&lt;=2*i-3; j++)&#123; System.out.print(&quot;#&quot;); //# &#125; for(int j=1; j&lt;=5-i; j++)&#123; System.out.print(&quot;*&quot;); //* &#125; &#125; System.out.println(); &#125; &#125;&#125; 自定义输入控制行数： 123456789101112131415161718192021222324252627282930import java.util.Scanner;public class test &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); System.out.println(&quot;input your lines:&quot;); int line = input.nextInt(); for(int i=1; i&lt;=line; i++)&#123; if(i==1)&#123; for(int j=1;j&lt;=2*line-1;j++)&#123; System.out.print(&quot;*&quot;); &#125; &#125;else&#123; for(int j=1; j&lt;=(line+1)-i; j++)&#123; System.out.print(&quot;*&quot;); //* &#125; for(int j=1; j&lt;=2*i-3; j++)&#123; System.out.print(&quot;#&quot;); //# &#125; for(int j=1; j&lt;=(line+1)-i; j++)&#123; System.out.print(&quot;*&quot;); //* &#125; &#125; System.out.println(); &#125; &#125;&#125; 画数字1234 1 12 1 123 211234 321 123456789101112131415161718192021public class test &#123; public static void main(String[] args) &#123; for(int i=1;i&lt;=4;i++)&#123; //空格占位 for(int j=1;j&lt;=4-i;j++)&#123; System.out.print(&quot; &quot;); &#125; //左边数字：利用变量 利用循环里层的变量j来控制 for(int j=1;j&lt;=i;j++)&#123; System.out.print(j); &#125; //右边数字： 利用j变量 j-- for(int j=i-1;j&gt;=1;j--)&#123; System.out.print(j); &#125; System.out.println(&quot; &quot;); &#125; &#125;&#125; 九九乘法表123456789101112public class test &#123; public static void main(String[] args) &#123; for(int i =1;i&lt;=9;i++)&#123; for(int j = 1;j&lt;=i;j++)&#123; System.out.print(j+&quot;*&quot;+i+&quot;=&quot;+i*j+&quot;\\t&quot;); &#125; System.out.println(); &#125; &#125;&#125; 找寻2-100之间的素数 质数：只能被1和本身整除的数：2，3，5，7，11… 1234567891011121314151617181920public class test &#123; public static void main(String[] args) &#123; for(int num =2;num&lt;= 100;num++)&#123; boolean x = false; for(int i=2;i&lt;=num-1;i++)&#123; if(num%i==0)&#123; System.out.println(num+&quot;不是素数&quot;); x=true; break; &#125; &#125; if(x==false)&#123; System.out.println(num+&quot;是素数&quot;); &#125; &#125; &#125;&#125; while水池排水 有一个水池，已经盛满了120立方米水。有一个进水管，每小时进水18立方米。有一个排水管，每小时排水30立方米。经过多少小时，水池的水排放干净？ 【结果已知，循环次数未知】 12345678910111213public class day12&#123; public static void main(String []args)&#123; int sum=120; int hour = 0; while(sum&gt;0)&#123; sum+=18; sum-=30; hour++; System.out.println(&quot;本次循环完毕:&quot; + sum); &#125; System.out.println( hour+&quot;小时后排水完毕&quot;); &#125;&#125; 画星星1234 * i==1 3 1 *** i==2 2 3 ***** i==3 1 5******* i==4 0 7 1234567891011121314151617181920212223public class day12&#123; public static void main(String []args)&#123; int i=1; while(i&lt;=4)&#123; //画空格占位 int j= 1; while(j&lt;=4-i)&#123; System.out.print(&quot; &quot;); j++; &#125; //画星星 int k= 1; while(k&lt;=2*i-1)&#123; System.out.print(&quot;*&quot;); k++; &#125; //换行 System.out.println(&quot;&quot;); i++; &#125; &#125;&#125; 两点相遇时间 小明从A点以7km/h速度向B出发。哥哥从B点以18km/h速度向A点出发。两人距离1000km。求解经过多少个小时才能相遇。 12345678910111213public class day12&#123; public static void main(String []args)&#123; int hour=0; int sum; do&#123; hour++; sum = (7*hour+18*hour); &#125; while(sum&lt;=1000); System.out.println(hour); &#125;&#125; 多久卖完西瓜 瓜农卖瓜，一车西瓜共1020个。每天卖掉总数的一半，多两个。求解瓜农几天才能把所有西瓜卖完？ 123456789101112public class day12&#123; public static void main(String []args)&#123; int day=0; int sum = 0; do&#123; day++; sum =(sum+2)*2; System.out.println(sum); &#125;while(sum&lt;1020); System.out.println(day); &#125;&#125;"}],"posts":[{"title":"在Mac上使用 Microsoft Remote Desktop 连接到windows计算机","slug":"Test/test","date":"2022-04-12T12:17:11.590Z","updated":"2022-04-12T13:02:46.418Z","comments":true,"path":"教程/Test/test/","link":"","permalink":"https://equnee.github.io/%E6%95%99%E7%A8%8B/Test/test/","excerpt":"","text":"摘要: 同时带两台电脑出门很麻烦，于是选择在Mac上使用 Microsoft Remote Desktop 远程连接使用不带出门的 Windows，从此只需要把Windows连接电源和wifi一直放着就行！顺便整理了一些别人遇到的错误和解决方法。 参考: 参考1 、参考2 *日期 *: 2021/3/25 环境 : MacOS 11.2.2 + Windows10 （ 本文介绍 mac 控制 windows, 其他系统同理**） 一、下载和安装1. 下载 下载 Microsoft Remote Desktop，根据情况下载对应版本的app： 使用 Windows 控制 windows：&gt;&gt; 官网下载 使用 Mac 控制 windows： App Store 下载，仅国外的应用商店提供下载，因此只能使用国外的 AppleID，可参考&gt; &gt; 国外AppleID申请方法。 其他渠道下载（俺也没试过 2. 安装过程略。 二、连接1. Windows 配置 首先确保将被控制的 Windows 开启了远程桌面连接配置： 1.1 设置了系统属性为允许远程桌面连接若选项都是灰色无法允许远程连接，参考这里。 1.2 设置了防火墙允许远程桌面通过防火墙通信1.3 开启了用于远程桌面连接的服务端口 查看默认端口号3389是否开启：cmd中输入 netstat -aon|findstr 3389 若端口号未开启，则打开服务，开启下面两项服务。（第三个可播放声音) ​ （若修改过或无法查询到3389端口，参考这里。） 设置本地策略非来宾 *gpedit.msc* 关闭了设置内 仅允许 Windows hello 登录 (未设置可忽略。) Windows Hello：使您可以使用脸部，虹膜，指纹或PIN登录设备，应用程序，在线服务和网络。 确保不是通过 Microsoft Authenticator ，而是通过手动输入密码进行验证登录的 因为 Microsoft Authenticator 登录使用的认证方式与其他域不互通，就不能直接开启连接啦。 2. 添加计算机 配置Windows允许远程桌面连接后，使用Mac准备开始连接，在Microsoft Remote Desktop中添加PC，输入主机名 + 用户账号信息。 PC name：IP地址。 查看方法：在 Windows 的命令提示符(win+R 键打开的运行窗口输入cmd) 输入命令 ipconfig，可查看ipv4地址。 User account：登录该PC的账号密码。建议选择 Ask when required，先不输入账号密码，在连接时输入，确保能连接成功后再添加记录，防止这里保存的账号密码有误，后面怎么都连不上。","categories":[{"name":"教程","slug":"教程","permalink":"https://equnee.github.io/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"windows","slug":"windows","permalink":"https://equnee.github.io/tags/windows/"},{"name":"Mac","slug":"Mac","permalink":"https://equnee.github.io/tags/Mac/"}]},{"title":"Java_Notebook","slug":"Java/Java_Notebook","date":"2020-07-11T17:08:34.265Z","updated":"2020-07-13T04:50:15.000Z","comments":true,"path":"wp/Java/Java_Notebook/","link":"","permalink":"https://equnee.github.io/wp/Java/Java_Notebook/","excerpt":"","text":"this is one 零. 基础知识( 上 ) 常见异常 Java开篇 基本数据类型 常量与变量 类型转化 运算符号 语法结构 数组 多维数组 面向对象 - 属性 面向对象 - 方法设计 面向对象 - 参数返回值 面向对象 - 方法重载 面向对象 - 构造方法 \\ 块 \\ this ( 中 ) 类的关系 - 继承 \\ 包含 \\ 依赖 修饰符 类的加载顺序 + 抽象类 + 接口_1 LinkedBox封装 缺省适配器模式 + 多态 ( 下 ) 一. MySQL 数据库初识 + SQL语言 MySQL数据库环境搭建(安装卸载) 数据类型 + 表格创建和修改 DML语句 (CRUD基本+字符集设置) 条件筛选 + 排序 函数的使用 分组 + 嵌套 几个关键字 (any some all union) 知识总结 + 练习 列的约束 (主键 + 唯一 + 非空) 列的约束 (外键) 表格之间的关系 联合查询 联合查询练习 行列互换 + 分页查询 + DCL 设计范式 WorkBench 安装与使用 事物及隔离级别 二. JDBC + 封装 JDBC初始 + Update操作 JDBC - Query操作 + 加载驱动类 + 事务操作 银行系统练习 (JDBC + MySQL + MVC分层思想) 银行系统练习2 (JDBC + MySQL + MVC分层思想) SQL注入及PreparedStatement使用 模糊查询处理 分页查询 + 多表联合查询 联合查询练习 银行系统 (登录窗口) 银行系统 (注册 + 操作窗口) 完整银行项目 (登录 + 查询 + 注册功能) 完整银行项目 (存款 + 取款 + 转账 + 销户功能) 三. 协议 + 前端四. JavaEE五. web框架封装六. 算法精讲七. 拓展八. 综合项目","categories":[{"name":"wp","slug":"wp","permalink":"https://equnee.github.io/categories/wp/"}],"tags":[{"name":"java","slug":"java","permalink":"https://equnee.github.io/tags/java/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-04-01T16:37:51.048Z","updated":"2020-07-13T05:29:02.000Z","comments":true,"path":"uncategorized/hello-world/","link":"","permalink":"https://equnee.github.io/uncategorized/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. 1. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 2. Hexo + mermaid插件 from: https://github.com/webappdevelp/hexo-filter-mermaid-diagrams Step1 Install Package1$ yarn add hexo-filter-mermaid-diagrams Step2 Edit ConfigAfter installed, you should edit hexo config file: _config.yml: 123456# mermaid chartmermaid: ## mermaid url https://github.com/knsv/mermaid enable: true # default true version: &quot;7.1.2&quot; # default v7.1.2 options: # find more api options from https://github.com/knsv/mermaid/blob/master/src/mermaidAPI.js #startOnload: true // default true Notice: if you want to use ‘Class diagram’, please edit your ‘_config.yml’ file, set external_link: false. - hexo bug. Step3 include mermaid.js in pug or ejsAfter edited _config.yml, you shou edit your blog page component like after_footer.pug , after-footer.ejs or swig. Where is it? Open your theme folder, you can see the layout folder, open it and then you could see it. Okey! if your blog is used pug, you can copy the below codes in after_footer.pug: 1234567if theme.mermaid.enable == true script(type=&#x27;text/javascript&#x27;, id=&#x27;maid-script&#x27; mermaidoptioins=theme.mermaid.options src=&#x27;https://unpkg.com/mermaid@&#x27;+ theme.mermaid.version + &#x27;/dist/mermaid.min.js&#x27; + &#x27;?v=&#x27; + theme.version) script. if (window.mermaid) &#123; var options = JSON.parse(document.getElementById(&#x27;maid-script&#x27;).getAttribute(&#x27;mermaidoptioins&#x27;)); mermaid.initialize(options); &#125; after-footer.ejs should copy below codes: 12345678&lt;% if (theme.mermaid.enable) &#123; %&gt; &lt;script src=&#x27;https://unpkg.com/mermaid@&lt;%= theme.mermaid.version %&gt;/dist/mermaid.min.js&#x27;&gt;&lt;/script&gt; &lt;script&gt; if (window.mermaid) &#123; mermaid.initialize(&#123;theme: &#x27;forest&#x27;&#125;); &#125; &lt;/script&gt;&lt;% &#125; %&gt; swig template engine: 12345678&#123;% if theme.mermaid.enable %&#125; &lt;script src=&#x27;https://unpkg.com/mermaid@&#123;&#123; theme.mermaid.version &#125;&#125;/dist/mermaid.min.js&#x27;&gt;&lt;/script&gt; &lt;script&gt; if (window.mermaid) &#123; mermaid.initialize(&#123;&#123; JSON.stringify(theme.mermaid.options) &#125;&#125;); &#125; &lt;/script&gt;&#123;% endif %&#125;","categories":[],"tags":[]}],"categories":[{"name":"教程","slug":"教程","permalink":"https://equnee.github.io/categories/%E6%95%99%E7%A8%8B/"},{"name":"wp","slug":"wp","permalink":"https://equnee.github.io/categories/wp/"}],"tags":[{"name":"windows","slug":"windows","permalink":"https://equnee.github.io/tags/windows/"},{"name":"Mac","slug":"Mac","permalink":"https://equnee.github.io/tags/Mac/"},{"name":"java","slug":"java","permalink":"https://equnee.github.io/tags/java/"}]}