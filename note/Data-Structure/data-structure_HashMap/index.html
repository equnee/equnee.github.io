<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=0"><meta name="description" content="🦋 HashMap 原理及源码分析 [ 🍧 Peach ] "><meta name="theme-color"><title>🦋 HashMap 原理及源码分析 [ 🍧 Peach ] </title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/css/mermaid.css"><script src="https://cdn.bootcss.com/highlight.js/9.6.0/highlight.min.js" defer></script><script src="/js/paper.js" defer></script><script src="https://www.googletagmanager.com/gtag/js?id=G-5GZQ6P3RMX" async></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-5GZQ6P3RMX');</script><script src="https://www.unpkg.com/valine/dist/Valine.min.js" defer></script><script>window.addEventListener('DOMContentLoaded', () => {
  new Valine({
    el: '#comments',
    appId: 'MJAdR7lH7cWVJLyn1Tgnw5Sj-gzGzoHsz',
    appKey: 'de2VP0VpE5bWgR2aA8wkwxn2',
    notify: false,
    verify: false,
    avatar: 'mp',
    placeholder: 'say something',
  })
})</script><script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js" defer></script><script>window.addEventListener('DOMContentLoaded', () => {
  tocbot.init({
    // Where to render the table of contents.
    tocSelector: '.toc__content',
    // Where to grab the headings to build the table of contents.
    contentSelector: '.article__content',
    // Which headings to grab inside of the contentSelector element.
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    // For headings inside relative or absolute positioned containers within content.
    hasInnerContainers: true,
    orderedList: false,
    collapseDepth: 2,
  });
})</script><link rel="preload" href="https://cdn.bootcss.com/highlight.js/9.6.0/styles/github.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.6.0/styles/github.min.css"><link rel="preload" href="https://fonts.googleapis.com/css?family=Abril+Fatface&amp;display=swap" as="style" onload="this.onload=null;this.rel='stylesheet'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface&amp;display=swap"><link rel="preload" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@300;400;500;600;700&amp;display=swap" as="style" onload="this.onload=null;this.rel='stylesheet'"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@300;400;500;600;700&amp;display=swap"><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css"><meta name="generator" content="Hexo 5.4.2"></head><body><div class="mask-border"></div><div class="head"><div class="head__inner"><h1><a href="/">🍧 Peach</a></h1><p>蜜桃学代码</p></div></div><div class="paper-container"><div class="main"><div class="location-bar"><div class="line-1"><div class="horizontal-line" style="height: 3px"></div></div><div class="line-2"><div class="horizontal-line" style="height: 1px"></div></div><p class="text">🦋 HashMap 原理及源码分析</p><div class="switch-button"><input class="container_toggle" type="checkbox" id="switch" name="mode"><label for="switch">Toggle</label></div><div class="line-3"><div class="horizontal-line" style="height: 1px"></div></div></div><div class="main__2-col"><article class="post-view__article"><div class="article__infomation"><div class="posts-item"><h2 class="posts-item__title"><a href="">🦋 HashMap 原理及源码分析</a></h2><span class="post__date">2023-03-09</span><a href="/tags/Java/"><span class="post__tags">#Java</span></a><a href="/tags/HashMap/"><span class="post__tags">#HashMap</span></a></div></div><div class="article__content"><p>（本文编辑中）</p>
<blockquote>
<p>注：本文制作的流程图仅为个人理解，仅供参考。</p>
</blockquote>
<hr>
<h1 id="一、HashMap介绍"><a href="#一、HashMap介绍" class="headerlink" title="一、HashMap介绍"></a>一、HashMap介绍</h1><h2 id="1-原理"><a href="#1-原理" class="headerlink" title="1. 原理"></a>1. 原理</h2><h3 id="（1）HashMap怎么存取"><a href="#（1）HashMap怎么存取" class="headerlink" title="（1）HashMap怎么存取"></a>（1）HashMap怎么存取</h3><pre class="mermaid">%%{
    init: {
        'themeVariables': {
            'fontSize': '13px'
        }
    }
}%%
graph TD

T(("<b>HashMap<br>怎么存取值</b>")):::p
T --> |"<i><b>数据以键值对形式存储</b></i>"| A["<i>key — value</i>"]
A --> |"<i><b>包装为Node数组对象</b></i>"| B["<i>Node { key, value }</i>"]
B --> |"<i><b>通过node数组下标保存对应数据</b></i>"| C["<i>node[0] = new Node { key, value }<br>node[1] = new Node { key, value }<br>node[2] = new Node { key, value }<br> ...</i>"]
C -.-> |"[ <b>保存</b> ] <br>遍历数组，对应key和value"| D["<i>for (Node node : nodes)</i>"]
C --> |"<b>[ 获取 ] <br>通过<u> 数组索引 </u>获取<i>（key的hash值）</i></b>"|E["<i><b>node[ <u>hash(key)</u> ] = value</b></i>"]:::lb

classDef p fill:#ddaebd
style E fill:#d9dfeb, stroke:#657eae,stroke-width:2px,stroke-dasharray: 3 3</pre>
<ul>
<li>使用Node数组保存、通过Node数组索引获取。</li>
</ul>
<h3 id="（2）Hash算法怎么写"><a href="#（2）Hash算法怎么写" class="headerlink" title="（2）Hash算法怎么写"></a>（2）Hash算法怎么写</h3><pre class="mermaid">%%{
    init: {
        'themeVariables': {
        'fontSize': '13px',
        'clusterBorder': 'none',
        'clusterBkg': '#f0f2f7'
    }
}
}%%
graph TD
T(("<b>Hash算法<br>怎么写？</b>")):::p
T --> |"<i><b>如何计算出数组索引？hash(key)</b></i>"| A["* 因为Node数组有固定的初始化默认长度（length）<br>* 索引值需限定在数组长度范围内（0～length-1）<br>* 索引值还要尽可能平衡、分布均匀"]
A --> B(["取模运算：<i>hash % length</i>"])
B ==> |"<b>（更好的方案</b>：<br>使用位运算效率更高）"| C(["<b>位运算：<i>hash & (length - 1)</i></b>"])
C -.- c("<b><i>length必须是2的n次幂</i></b>"):::b
subgraph "前置条件"
c -.- c2["<i>假如 key = 20, length = 16, hash & (length-1):</i><br>0001 0100  // 20  <br>0000 1111 // 15<br >0000 0100 // =4"]:::c2
end
classDef p fill:#ddaebd
classDef b fill:#d2d9e7, stroke-width: 0px

style c2 color: #86868b, fill:#ebedf3, stroke-dasharray: 3 3
%% 取模运算
style B fill: #f4e4e9
%% "位运算"
style C fill:#b8c3d9, stroke:#657eae,stroke-width:2px</pre>

<ul>
<li><p><strong>为了解决取模的效率问题，采用了位运算的方法：<code>index = hash值 &amp; (length -1)</code></strong><br>此时需要一个前置条件：<strong><em>length的长度必须是2的n次幂</em></strong>。<br>当length的长度是<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>2</mn><mi mathvariant="normal">n</mi></msup></math>时，有以下公式成立： <b><i>num%<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>2</mn><mi mathvariant="normal">n</mi></msup></math> = num&amp;(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>2</mn><mi mathvariant="normal">n</mi></msup></math>-1) </i>。</b></p>
<blockquote>
<p>🦋 因为就像十进制取余数一样，若除以10或10的整次幂数，余数刚好是取低位上的数字。同理，二进制取余数只要除以2的n次幂数，低位上的数字就是我们需要的余数。而(<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>2</mn><mi mathvariant="normal">n</mi></msup></math> - 1)的二进制有效位都是1，和n位的1作与运算相当于取低n位的值。</p>
</blockquote>
</li>
<li><p><strong>length的长度刚好是2的n次幂，扩容也是按原来的2倍容量进行扩容，可以加快hash计算、减少hash冲突。</strong></p>
<blockquote>
<p>🦋 <strong>加快hash计算</strong>：</p>
<ol>
<li>两倍扩容机制使容量一直保持在2的n次幂数，就可以使用<u>位运算代替取模运算</u>，提升hash计算效率。</li>
<li>当容量保持为2的n次幂时，每次扩容时位运算计算得出的余数不变，数据存放的<u>索引位置也保持不变</u>。而使用%计算时，结果会因为容量的变化而改变（模运算会产生小数点），每次扩容时数据在数组中存放的位置会发生改变（数据漂移），影响性能。</li>
</ol>
</blockquote>
<blockquote>
<p>🦋 <strong>减少hash冲突</strong>：</p>
<ul>
<li>将容量保持为偶数进行hash计算时，经过(length-1)后，计算出的索引值为奇数和偶数的概率相同（取决于随机生成的hash值）；</li>
<li>而使用<u>奇数容量</u>进行hash计算时，经过(length-1)后，最终结果均为偶数，这样任何 hash 值都只会被散列到数组的<u>偶数下标位置</u>上，这浪费了近一半的空间。</li>
<li>因此2的n次幂容量、双倍扩容机制可以使容量保持在偶数值，可以使添加的元素在HashMap的数组中均匀分布，减少hash碰撞。</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="（3）Hash冲突怎么办"><a href="#（3）Hash冲突怎么办" class="headerlink" title="（3）Hash冲突怎么办"></a>（3）Hash冲突怎么办</h3><pre class="mermaid">%%{
    init: {
    'themeVariables': {
        'fontSize': '13px',
        'edgeLabelBackground': '#ddebe6'
    }
}
}%%
graph TD

T(("1. <b>Hash冲突<br>怎么优化</b>")):::p
--> T1("hash表里可以存储元素的位置<br>被称为“<b>桶（bucket）</b>”")
T1 --> |"<b>通常情况</b>"| A("单个“桶”里存储一个元素，<br>此时性能最佳"):::g
A -.-> |"<i><b>O(1)</b></i>"| a["hash算法可以根据hashCode值<br>计算出“桶”的存储位置，<br>接着从“桶”中取出元素。"]
T1 --> |"<b>哈希冲突的情况</b>"| B("单个桶会存储多个元素<i>（hash值相同）</i>"):::g
B -.-> |"<b><i>O(n)</b></i>"|b(["多个元素以 <b><i>链表</i></b> 形式存储<br>"]):::B
b --> 2T(("2.<b> Hash冲突<br>很大怎么优化</b>")):::p
subgraph "<i>（链表必须按顺序搜索，存取性能差）</i>"
2T --> C(["将链表结构转为<b><i>红黑树</i></b>"]):::B
C -.- |"<i><b>O(logn)</b></i>"|c["以树的高度为最差查询性能，永远不会出现O(n)的情况。"]:::info
end

classDef p fill:#ddaebd
classDef g fill:#f4e4e9
classDef B fill:#d9dfeb, stroke:#657eae,stroke-width:2px
classDef info fill:#f6f6f7,color:#737379, stroke-width: 2px, stroke-dasharray: 3 3</pre>
<ul>
<li><p><strong>Hash冲突示意图</strong></p>
  <pre class="mermaid">    %%{
      init: {
          'themeVariables': {
              'clusterBorder': 'none',
              'clusterBkg': '#ececee'
          }
      }
  }%%
  %% 链表超过8时树化成红黑树
  graph TD

  subgraph "Node[]"
  Entry0["Node0<br><i><b>Node＜K,V></b></i>"] -.- Node1 -.- Node2 -.- Node3 -.- Node4 -.- Node5 -.- Node6
  end

  subgraph 链表
  Node1 --> A[Node] --> B[Node] --> C[Node] --> D[Node] --> E[Node] --> F[Node]  
  end

  subgraph 红黑树
  Node4 --> a[Node]
  a[Node] --> b[Node]
  b --> b1[Node]
  b --> b2[Node]
  a --> c[Node]
  c --> c1[Node]
  c --> c2[Node]
  b1 --> d[Node]
  b1 --> d2[Node]
  end

  style 链表 fill:#ddebe6
  style 红黑树 fill:#f4e4e9</pre>

</li>
</ul>
<h3 id="（4）内存结构示意图"><a href="#（4）内存结构示意图" class="headerlink" title="（4）内存结构示意图"></a>（4）内存结构示意图</h3><ul>
<li><p><strong>创建对象</strong>，内存结构示意图：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Map&lt;String, Integer&gt; countMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>countMap.put(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">1</span>);<br>countMap.put(<span class="hljs-string">&quot;world&quot;</span>, <span class="hljs-number">3</span>);<br>countMap.put(<span class="hljs-string">&quot;position&quot;</span>, <span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure>

  <img src="https://equne.oss-cn-hangzhou.aliyuncs.com/typora/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%9B%BE1.jpg" alt="内存结构图1" style="zoom: 25%;" />
</li>
<li><p><strong>保存键值对</strong></p>
<p>  “hello”的hash值为96207088，模16的结果为0，所以插入table[0]指向的链表头部，内存结构变为：</p>
  <img src="https://equne.oss-cn-hangzhou.aliyuncs.com/typora/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%9B%BE2.jpg" alt="内存结构图2" style="zoom: 25%;" />

<p>  “world”的hash值为111207038，模16结果为14，所以保存完“world”后，内存结构：</p>
  <img src="https://equne.oss-cn-hangzhou.aliyuncs.com/typora/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%9B%BE3.jpg" alt="内存结构图3" style="zoom:25%;" />

<p>  “position”的hash值为771782464，模16结果也为0, table[0]已经有节点了，新节点会插到链表头部，内存结构变为如图：</p>
  <img src="https://equne.oss-cn-hangzhou.aliyuncs.com/typora/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%9B%BE4.jpg" alt="内存结构图4" style="zoom:25%;" /> 


</li>
</ul>
<h2 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h2><h3 id="（1）基本使用"><a href="#（1）基本使用" class="headerlink" title="（1）基本使用"></a>（1）基本使用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"><br>Printer.printHashMapStructures(map); // 打印树结构<br>getMapFromStringParam();<br></code></pre></td></tr></table></figure>

<h3 id="（2）如何遍历"><a href="#（2）如何遍历" class="headerlink" title="（2）如何遍历"></a>（2）如何遍历</h3><pre class="mermaid">graph LR
T(("<b>遍历HashMap<br>的5种方法</b>")):::p
T --> A(["<b>entrySet</b>"]):::lp
T --> B(["<b>keySet</b>"]):::lp
T --> C(["<b>forEach</b>"]):::lp
T --> |"流操作"|D(["<b>StreamApi.forEach</b>"]):::lp
T -.-> E(["<b>values</b>"])

A -.-> a("<i>（1）entrySet</i>")
A -.-> a2("<i>（2）entrySet + 迭代器</i>")
B -.-> |"（效率低）"| b("<i>（3）keySet + get()</i>")
C -.-> c("<i>（4）forEach + Lambda</i>")
D -.-> d("<i>（5）Stream().forEach（单线程）</i>")
D -.-> d2("<i>（6）Stream().forEach（多线程）</i>")
E -.-> e("<i>（7）仅遍历value</i>")

classDef p fill:#ddaebd
classDef lp fill:#f4e4e9
classDef B fill:#d9dfeb, stroke:#657eae,stroke-width:2px</pre>
<ul>
<li><p><strong>遍历HashMap代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.equne;<br><br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Iterator;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><br>    <span class="hljs-comment">/** （1）entrySet */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">traverse1</span><span class="hljs-params">(Map&lt;String, String&gt; map)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet())&#123;<br>            System.out.println(entry.getKey() + <span class="hljs-string">&quot;, &quot;</span> + entry.getValue());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/** （2）迭代器（entrySet） */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">traverse2</span><span class="hljs-params">(Map&lt;String, String&gt; map)</span> </span>&#123;<br>        Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = map.entrySet().iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext())&#123;<br>            Map.Entry&lt;String, String&gt; entry = iterator.next();<br>            System.out.println(entry.getKey() + <span class="hljs-string">&quot;, &quot;</span> + entry.getValue());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/** （3）keySet + get() */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">traverse3</span><span class="hljs-params">(Map&lt;String, String&gt; map)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (String key : map.keySet())&#123;<br>            System.out.println(key + <span class="hljs-string">&quot;, &quot;</span> + map.get(key));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/** （4）forEach + Lambda */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">traverse4</span><span class="hljs-params">(Map&lt;String, String&gt; map)</span> </span>&#123;<br>        map.forEach((key, value) -&gt; &#123;<br>            System.out.println(key + <span class="hljs-string">&quot;, &quot;</span> + value);<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-comment">/** （5）StreamApi（单线程） */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">traverse5</span><span class="hljs-params">(Map&lt;String, String&gt; map)</span> </span>&#123;<br>        map.entrySet().stream().forEach((entry) -&gt; &#123;<br>            System.out.println(entry.getKey() + <span class="hljs-string">&quot;, &quot;</span> +entry.getValue());<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-comment">/** （6）StreamApi（多线程） */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">traverse6</span><span class="hljs-params">(Map&lt;String, String&gt; map)</span> </span>&#123;<br>        map.entrySet().stream().parallel().forEach((entry) -&gt; &#123;<br>            System.out.println(entry.getKey() + <span class="hljs-string">&quot;, &quot;</span> +entry.getValue());<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-comment">/** （7）仅遍历value */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">traverse7</span><span class="hljs-params">(Map&lt;String, String&gt; map)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (String v : map.values())&#123;<br>            System.out.println(v);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;key2&quot;</span>, <span class="hljs-string">&quot;value2&quot;</span>);<br>        traverse1(map);<br>        traverse2(map);<br>        traverse3(map);<br>        traverse4(map);<br>        traverse5(map);<br>        traverse6(map);<br>        traverse7(map);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>entrySet 和 keySet</strong></p>
<blockquote>
<ul>
<li>Map.entrySet 迭代器会生成 EntryIterator，其返回的实例是一个包含 <strong>key/value 键值对</strong>的对象。</li>
<li>而 keySet 中迭代器返回的只是 key 对象，还需要到 map 中二次取值（多一个get方法的调用）。故 entrySet 要比 keySet 快一倍左右。（keySet适合仅需要操作key时使用）<br>🔗 <em>摘自：<a href="https://book.douban.com/subject/35187133/">《Java修炼指南：高频源码解析》</a></em></li>
</ul>
</blockquote>
</li>
<li><p><strong>foreach + Lambda 表达式</strong>（Java8 的新特性）</p>
<blockquote>
<ul>
<li>forEach()：用于遍历动态数组中每一个元素并执行特定操作。</li>
<li>Lambda 表达式：箭头符号 <code>-&gt;</code>，其两边连接着<strong>输入参数</strong>和<strong>函数体</strong>。</li>
</ul>
</blockquote>
</li>
<li><p><strong>Stream()</strong></p>
<blockquote>
<ul>
<li>其实用Iterable本身的forEach方法即可，没有必要用流式操作。StreamApi适合在对集合进行其他<strong>流式操作</strong>之后使用。</li>
<li>补充：用流获取映射值的极端案例：<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Optional&lt;String&gt; value = map<br>    .entrySet()<br>    .stream()<br>    .filter(entry -&gt; entry.getKey().equals(key))<br>    .map(Entry::getValue) <span class="hljs-comment">// 双冒号：引用方法</span><br>    .findFirst();<br></code></pre></td></tr></table></figure>
🔗 <em>摘自：<a href="https://book.douban.com/subject/36142061/">《好代码，坏代码》</a></em></li>
</ul>
</blockquote>
</li>
</ul>
<p>.</p>
<hr>
<h1 id="二、HashMap源码"><a href="#二、HashMap源码" class="headerlink" title="二、HashMap源码"></a>二、HashMap源码</h1><blockquote>
<p>注：本文源码版本均为：JDK 8 </p>
</blockquote>
<h2 id="1-属性"><a href="#1-属性" class="headerlink" title="1. 属性"></a>1. 属性</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 🔹 常量</span><br><span class="hljs-comment">// 默认的初始容量值（16）- 必须是2的n次幂</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>;<br><br><span class="hljs-comment">// 最大容量上限（2的30次方）</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAXIMUM_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<br><br><span class="hljs-comment">// 默认的负载因数（0.75）</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="hljs-number">0.75f</span>;<br><br><span class="hljs-comment">// 树化阈值：当一个桶中的元素个数大于等于8时进行树化</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TREEIFY_THRESHOLD = <span class="hljs-number">8</span>;<br><br><span class="hljs-comment">// 树降级为链表的仓位计数阈值，当一个桶中的元素个数小于等于6时把树转化为链表。</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> UNTREEIFY_THRESHOLD = <span class="hljs-number">6</span>;<br><br><span class="hljs-comment">// 将table树化的最小容量值（64）：当桶的个数达到64的时候才进行树化（至少应为4*TREEIFY_THRESHOLD，以避免调整大小和树化阈值之间的冲突。）</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="hljs-number">64</span>;<br><br><span class="hljs-comment">// 🔹 变量</span><br><span class="hljs-comment">// Node数组，又叫作桶（bucket）</span><br><span class="hljs-keyword">transient</span> Node&lt;K,V&gt;[] table;<br><br><span class="hljs-comment">// 作为entrySet()的缓存</span><br><span class="hljs-keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;<br><br><span class="hljs-comment">// 元素的数量</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> size;<br><br><span class="hljs-comment">// 记录hashMap的修改次数（每次扩容和更改 map 结构的计数器）</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> modCount;<br><br><span class="hljs-comment">// 扩容阈值 = table.length * loadFactor（当size大于阈值时扩容）</span><br><span class="hljs-keyword">int</span> threshold;<br><br><span class="hljs-comment">// 负载因数：表示整体上table被占用的程度</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> loadFactor;<br><br></code></pre></td></tr></table></figure>

<h2 id="2-构造方法"><a href="#2-构造方法" class="headerlink" title="2. 构造方法"></a>2. 构造方法</h2><pre class="mermaid">graph LR

T(("<b>HashMap<br>构造方法</b>")):::p
T --> A(["<i>HashMap map1 = new HashMap();</i>"]):::lp
T --> B(["<i>HashMap map2 = new HashMap(30);</i>"]):::lp
T --> C(["<i>HashMap map3 = new HashMap(30, 0.5f);</i>"]):::lp
T --> D(["<i>HashMap map4 = new HashMap(map);</i>"]):::lp

A --- |"无参构造方法"|a("不指定容量，默认:16")
B --- |"<i>initialCapacoty</i>"| b("指定初始化容量：30")
C --- |"<i>initialCapacoty<br>loadFactor</i>"| c("指定初始化容量、负载因数")
D --- |"<i>Map map</i>"| d("以指定map构造新map</i>")

D -.- ci("* 注意：<br>与上述仅创建空HashMap不同，<br>此方法内部调用了put()存值<br>table才真正进行了初始化。"):::info

classDef p fill:#ddaebd
classDef lp fill: #f4e4e9
classDef info fill:#f6f6f7,color:#737379,stroke-dasharray: 3 3, stroke-width: 2px</pre>

<h3 id="（1）HashMap"><a href="#（1）HashMap" class="headerlink" title="（1）HashMap()"></a>（1）HashMap()</h3><ul>
<li>无参数的构造方法<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Constructs an empty HashMap with the default initial capacity(16) and the default load factor (0.75).</span><br><span class="hljs-comment"> * 以默认初始容量(16)和默认负载因数(0.75)，构造一个空的HashMap。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 🔻 将负载因数赋为默认值。</span><br>    <span class="hljs-keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="hljs-comment">// all other fields defaulted</span><br>&#125;<br></code></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="（2）HashMap-20"><a href="#（2）HashMap-20" class="headerlink" title="（2）HashMap(20)"></a>（2）HashMap(20)</h3><ul>
<li>带初始容量的构造方法：<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Constructs an empty HashMap with the specified initial capacity and the default load factor (0.75).</span><br><span class="hljs-comment"> * 以特定的初始容量和默认的负载因数(0.75)，构造一个空的HashMap</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>  initialCapacity 初始容量</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IllegalArgumentException 初始容量为负值时抛出非法数据异常。</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;<br>    <span class="hljs-comment">// 🔻 调用了带初始容量、负载因数的构造方法（详见下文(3)）</span><br>    <span class="hljs-keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);<br> &#125;<br></code></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="（3）HashMap-20-0-5f"><a href="#（3）HashMap-20-0-5f" class="headerlink" title="（3）HashMap(20, 0.5f)"></a>（3）HashMap(20, 0.5f)</h3><ul>
<li>带初始容量、负载因数的构造方法<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Constructs an empty HashMap with the specified initial capacity and load factor.</span><br><span class="hljs-comment"> * 以特定的初始容量和负载因数构造一个空的HashMap。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>  initialCapacity 初始化容量</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>  loadFactor      负载因数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span><br><span class="hljs-comment"> *         or the load factor is nonpositive</span><br><span class="hljs-comment"> *         当初始容量为负值、或负载因数为非正时抛出非法数据异常。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity, <span class="hljs-keyword">float</span> loadFactor)</span> </span>&#123;<br>    <span class="hljs-comment">// 🔴 一、判断传入参数的合法性</span><br>    <span class="hljs-comment">//  🔹 初始容量值非负数</span><br>    <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal initial capacity: &quot;</span> +<br>                                           initialCapacity);       <br>    <span class="hljs-comment">//  🔹 初始容量值不超过最大容量</span><br>    <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)<br>        initialCapacity = MAXIMUM_CAPACITY;<br>    <span class="hljs-comment">//  🔹 负载因数大于0且为数字</span><br>    <span class="hljs-keyword">if</span> (loadFactor &lt;= <span class="hljs-number">0</span> || Float.isNaN(loadFactor))<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal load factor: &quot;</span> +<br>                                         loadFactor);<br><br>    <span class="hljs-comment">// 🔴 二、为配置参数赋值</span><br>    <span class="hljs-comment">//  🔹 为负载因数赋值</span><br>    <span class="hljs-keyword">this</span>.loadFactor = loadFactor;<br>    <span class="hljs-comment">//  🔹 为扩容阈值赋值：使用tableSizeFor()将给定数值调整为2的次幂数。</span><br>    <span class="hljs-keyword">this</span>.threshold = tableSizeFor(initialCapacity);<br>&#125;<br></code></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="（4）HashMap-map"><a href="#（4）HashMap-map" class="headerlink" title="（4）HashMap(map)"></a>（4）HashMap(map)</h3><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="- HashMap()"></a>- <em>HashMap()</em></h4><ul>
<li>带map的构造方法  <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Constructs a new HashMap with the same mappings as the specified Map.</span><br><span class="hljs-comment"> * The HashMap is created with default load factor (0.75) and an initial capacity sufficient to hold the mappings in the specified Map.</span><br><span class="hljs-comment"> * 使用与指定Map相同的映射构造新的HashMap。</span><br><span class="hljs-comment"> * 此HashMap由：默认负载因数(0.75)、足够的初始容量（足以存下指定Map）创建。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>   m the map whose mappings are to be placed in this map</span><br><span class="hljs-comment"> * @参数：   m，原map</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span>  NullPointerException if the specified map is null</span><br><span class="hljs-comment"> * @异常：   当原map为空时抛出空指针异常。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;<br>    <span class="hljs-comment">// 🔻 将负载因数赋为默认值。</span><br>    <span class="hljs-keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;<br>    <span class="hljs-comment">// 🔻 调用putMapEntries()，将原有map存入新map。</span><br>    putMapEntries(m, <span class="hljs-keyword">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="putMapEntries"><a href="#putMapEntries" class="headerlink" title="- putMapEntries()"></a>- <em>putMapEntries()</em></h4><ul>
<li>赋值并初始化函数<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Implements Map.putAll and Map constructor.</span><br><span class="hljs-comment"> * 赋值并构造函数。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> m the map</span><br><span class="hljs-comment"> * @参数： m，传入的map</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> evict false when initially constructing this map, else true (relayed to method afterNodeInsertion).</span><br><span class="hljs-comment"> * @参数： evict，首次创建此map时返回false，非首次创建返回true。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">putMapEntries</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m, <span class="hljs-keyword">boolean</span> evict)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> s = m.size(); <span class="hljs-comment">// m的元素个数</span><br>    <span class="hljs-comment">// 🔴 一、若m中有元素，需要根据新Map的初始化情况为其扩容阈值赋值。 （若m无元素则无需赋值，直接使用给定的负载因数和扩容阈值(lf*cap)完成构造。）</span><br>    <span class="hljs-keyword">if</span> (s &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 🔹 若数组未初始化：根据m中元素数量和负载因数计算新Map的扩容阈值。</span><br>        <span class="hljs-keyword">if</span> (table == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// pre-size</span><br>            <span class="hljs-comment">// m的扩容阈值 = 元素数量 / 负载因数（🔸+1.0F：对小数做向上取整以尽可能保证更大容量）</span><br>            <span class="hljs-keyword">float</span> ft = ((<span class="hljs-keyword">float</span>)s / loadFactor) + <span class="hljs-number">1.0F</span>;<br>            <span class="hljs-comment">// 将m扩容阈值的数据类型转为整型，并限定在默认容量上限内</span><br>            <span class="hljs-keyword">int</span> t = ((ft &lt; (<span class="hljs-keyword">float</span>)MAXIMUM_CAPACITY) ?<br>                     (<span class="hljs-keyword">int</span>)ft : MAXIMUM_CAPACITY);<br>            <span class="hljs-comment">// 若计算出m的扩容阈值 &gt; 新Map扩容阈值，调用tableSizeFor方法，将新Map扩容阈值设置为：该值最接近容量的2次幂数。</span><br>            <span class="hljs-keyword">if</span> (t &gt; threshold)<br>                threshold = tableSizeFor(t);<br>        &#125;<br>        <span class="hljs-comment">// 🔹 若数组已初始化、且Map中的元素数量超过了其扩容阈值：扩容。</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s &gt; threshold)<br>            resize();<br>        <span class="hljs-comment">// 🔴 二、赋值：遍历m的entry，逐个赋值到新Map上。</span><br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;<br>            K key = e.getKey();<br>            V value = e.getValue();<br>            <span class="hljs-comment">// 🔹 调用putVal()为每个节点赋值（此时新Map才真正初始化完成）</span><br>            putVal(hash(key), key, value, <span class="hljs-keyword">false</span>, evict);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><code>((float)s / loadFactor) + 1.0F</code> + 1.0F：为了让浮点数进行除法计算后向上取整，以尽可能保证足够容量。</li>
</ul>
<h2 id="3-静态实用程序"><a href="#3-静态实用程序" class="headerlink" title="3. 静态实用程序"></a>3. 静态实用程序</h2><h3 id="hash"><a href="#hash" class="headerlink" title="- hash()"></a>- <em>hash()</em></h3><ul>
<li><strong>计算key.hashCode()</strong><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* ---------------- Static utilities -------------- */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Computes key.hashCode() and spreads (XORs) higher bits of hash to lower. </span><br><span class="hljs-comment"> * 计算key.hashCode()并将哈希的高位扩展（异或运算）到低位。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> h;<br>    <span class="hljs-keyword">return</span> (key == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><code>(h=key.hashCode()) ^ (h &gt;&gt;&gt;16)</code><blockquote>
<p><strong>hash(Object) 方法通过以上表达式得到指定对象的Hash值</strong>。<br>这里是取得当前对象的Hash值，首先进行<strong><em>带符号位的右移16位</em></strong>操作（这时候对象Hash值的高位段就变成了低位段），然后与对象原来的Hash值进行<strong><em>异或运算</em></strong>。</p>
</blockquote>
</li>
<li><strong>异或的原因</strong>：<blockquote>
<p>因为数组容量总是2的n次幂数，计算索引位置时，散列真正生效的只是低<strong><em>n</em></strong>bit的有效位，很容易发生碰撞。因此，把高16bit和低16bit异或一下，既减少了系统的开销，也不会造成因为高位没有参与下标的计算(table长度比较小)时，引起碰撞。</p>
</blockquote>
</li>
</ul>
<h3 id="tableSizeFor"><a href="#tableSizeFor" class="headerlink" title="- tableSizeFor()"></a>- <em>tableSizeFor()</em></h3><ul>
<li><strong>返回最接近给定目标容量的二次幂数值</strong><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns a power of two size for the given target capacity.</span><br><span class="hljs-comment"> * 返回给定目标容量的二次幂数。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tableSizeFor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cap)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = cap - <span class="hljs-number">1</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">2</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">4</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">8</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">16</span>;<br>    <span class="hljs-keyword">return</span> (n &lt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="hljs-number">1</span>;<br>&#125;<br><br><br><span class="hljs-comment">/* 以下为备注：</span><br><span class="hljs-comment">    -------------------------------------------------</span><br><span class="hljs-comment">      * 该位运算用于求出高位1之后每位都为1的结果。</span><br><span class="hljs-comment">        因为将每位变为1，则加上1后刚好是一个二次幂数。</span><br><span class="hljs-comment">        如(0000 1000)，使其第一位1后面都为1，即(0000 1111)</span><br><span class="hljs-comment">    ------------------------------------------------- */</span><br><br>        <span class="hljs-comment">// 如，initialCapacity = 9</span><br>        <span class="hljs-comment">// 🔴 将 n - 1</span><br>	<span class="hljs-keyword">int</span> n = cap -<span class="hljs-number">1</span>; <span class="hljs-comment">// n = 8	</span><br><br>        <span class="hljs-comment">// 🔴 作位运算：1. 无符号位移 2. 与n作或的位运算。</span><br>	n |= n &gt;&gt;&gt; <span class="hljs-number">1</span>; <br>	n = <span class="hljs-number">0000</span> <span class="hljs-number">1000</span><br>	n = <span class="hljs-number">0000</span> <span class="hljs-number">0100</span><br>	n = <span class="hljs-number">0000</span> <span class="hljs-number">1100</span>  <br><br>	n |= n &gt;&gt;&gt; <span class="hljs-number">2</span>;<br>	n = <span class="hljs-number">0000</span> <span class="hljs-number">1100</span><br>	n = <span class="hljs-number">0000</span> <span class="hljs-number">0011</span><br>	n = <span class="hljs-number">0000</span> <span class="hljs-number">1111</span>  <span class="hljs-comment">// =15</span><br><br>	n |= n &gt;&gt;&gt; <span class="hljs-number">4</span>;<br>	n = <span class="hljs-number">0000</span> <span class="hljs-number">1111</span><br>	n = <span class="hljs-number">0000</span> <span class="hljs-number">0000</span>  <br>	n = <span class="hljs-number">0000</span> <span class="hljs-number">1111</span>  <br><br>	n |= n &gt;&gt;&gt; <span class="hljs-number">8</span>;<br>	n = <span class="hljs-number">0000</span> <span class="hljs-number">1111</span><br>	n = <span class="hljs-number">0000</span> <span class="hljs-number">0000</span><br>	n = <span class="hljs-number">0000</span> <span class="hljs-number">1111</span>  <br><br>	n |= n &gt;&gt;&gt; <span class="hljs-number">16</span>;	<br>        <span class="hljs-comment">// 🔸 因为int是32位的，所以执行到16即可.</span><br><br><br>        <span class="hljs-comment">// 🔴 返回位移结果n + 1</span><br>	<span class="hljs-keyword">return</span> (n &lt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUN_CAPACITY : n + <span class="hljs-number">1</span>;<br>	 n &lt; <span class="hljs-number">0</span>, 则返回 n = <span class="hljs-number">1</span> <br>	 n &gt;= <span class="hljs-number">0</span>, 且 n &gt;= 最大容量, 则返回最大容量 <br>	 n &gt;= <span class="hljs-number">0</span>, 且 n &lt; 最大容量, 则返回 n + <span class="hljs-number">1</span> （=<span class="hljs-number">16</span>）<br><br>     <br></code></pre></td></tr></table></figure></li>
<li><strong>为什么先进行<code>n-1</code>操作：</strong>为了处理n刚好是二次幂数的情况。<blockquote>
<p>🦋 若n已经是2的n次幂了，按照逻辑变1之后再加1，结果就会变成n的2倍了，与应有的结果不一致。如，n=16（0001 0000），位运算后 n=31（0001 1111）。</p>
</blockquote>
</li>
</ul>
<h3 id="Comparable"><a href="#Comparable" class="headerlink" title="- Comparable"></a>- <em>Comparable</em></h3><ul>
<li><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns x&#x27;s Class if it is of the form &quot;class C implements</span><br><span class="hljs-comment"> * Comparable&lt;C&gt;&quot;, else null.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> Class&lt;?&gt; comparableClassFor(Object x) &#123;<br>    <span class="hljs-keyword">if</span> (x <span class="hljs-keyword">instanceof</span> Comparable) &#123;<br>        Class&lt;?&gt; c; Type[] ts, as; Type t; ParameterizedType p;<br>        <span class="hljs-keyword">if</span> ((c = x.getClass()) == String.class) <span class="hljs-comment">// bypass checks</span><br>            <span class="hljs-keyword">return</span> c;<br>        <span class="hljs-keyword">if</span> ((ts = c.getGenericInterfaces()) != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ts.length; ++i) &#123;<br>                <span class="hljs-keyword">if</span> (((t = ts[i]) <span class="hljs-keyword">instanceof</span> ParameterizedType) &amp;&amp;<br>                    ((p = (ParameterizedType)t).getRawType() ==<br>                     Comparable.class) &amp;&amp;<br>                    (as = p.getActualTypeArguments()) != <span class="hljs-keyword">null</span> &amp;&amp;<br>                    as.length == <span class="hljs-number">1</span> &amp;&amp; as[<span class="hljs-number">0</span>] == c) <span class="hljs-comment">// type arg is c</span><br>                    <span class="hljs-keyword">return</span> c;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns k.compareTo(x) if x matches kc (k&#x27;s screened comparable</span><br><span class="hljs-comment"> * class), else 0.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span> <span class="hljs-comment">// for cast to Comparable</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareComparables</span><span class="hljs-params">(Class&lt;?&gt; kc, Object k, Object x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (x == <span class="hljs-keyword">null</span> || x.getClass() != kc ? <span class="hljs-number">0</span> :<br>            ((Comparable)k).compareTo(x));<br>&#125;<br></code></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="4-实现方法"><a href="#4-实现方法" class="headerlink" title="4. 实现方法"></a>4. 实现方法</h2><h3 id="（1）Get-获取"><a href="#（1）Get-获取" class="headerlink" title="（1）Get() - 获取"></a>（1）Get() - 获取</h3><pre class="mermaid">%%{
    init: {
    'themeVariables': {
        'fontSize': '13px'
    }
}   
}%%
graph TD
T(["<b>如何从HashMap<br>获取元素？</b>"]):::p
T --> B("先根据key找到桶位")
B --> A(["判断当前位置的元素<br>是否就要找的值"]):::lp
A --> |"<b>是</b>"| C2["核对k-v值后返回"]:::b
A --> |"<b>否</b><br><i>（有hash冲突）</i>"| C(["判断为链表或红黑树"]):::lp
C -.-> |"<b>链表</b>"|a["遍历链表、<br>核对k-v值后返回"]:::b
C -.-> |"<b>红黑树</b>"|b["从树的根节点查找、<br>核对k-v值后返回"]:::b

classDef p fill:#ddaebd
classDef b fill:#d9dfeb
classDef lp fill: #f4e4e9</pre>

<h4 id="get"><a href="#get" class="headerlink" title="- get()"></a>- <em>get()</em></h4><ul>
<li>通过key获取value<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns the value to which the specified key is mapped,</span><br><span class="hljs-comment"> * or null if this map contains no mapping for the key.</span><br><span class="hljs-comment"> * 返回指定key所映射的value值。若找不到对应value时返回null。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 但返回null不一定代表不存在该key映射的值，有可能是该key保存的value值正是&quot;null&quot;。</span><br><span class="hljs-comment"> * 可以使用containsKey()来识别。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>    <span class="hljs-comment">// Node</span><br>    Node&lt;K,V&gt; e;<br>    <span class="hljs-comment">// 🔻 使用key和其hash值调用getNode()方法，返回Node的value值。</span><br>    <span class="hljs-keyword">return</span> (e = getNode(hash(key), key)) == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : e.value;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><code>null ? null : e.value</code>：若该值为null，返回null；若该值不为null，返回e.value</li>
</ul>
<h4 id="getNode"><a href="#getNode" class="headerlink" title="- getNode()"></a>- <em>getNode()</em></h4><ul>
<li>获取Node<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Implements Map.get and related methods.</span><br><span class="hljs-comment"> * 实现了Map.get()和相关方法</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> hash key的hash值</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> key key</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 返回该key对应的Node，若无返回null</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title">getNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, Object key)</span> </span>&#123;<br>    Node&lt;K,V&gt;[] tab; <span class="hljs-comment">// Node数组</span><br>    Node&lt;K,V&gt; first, e; <span class="hljs-comment">// Node</span><br>    <span class="hljs-keyword">int</span> n; <span class="hljs-comment">// 数组长度</span><br>    K k; <span class="hljs-comment">// key</span><br>    <span class="hljs-comment">// 🔻 判断该数组非空</span><br>    <span class="hljs-comment">//   并根据传入key的hash值计算出该hash值对应的Node的下标，将该数组下标对应的值赋值给first-Node（意为hash冲突时第一个节点）</span><br>    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>        (first = tab[(n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 🔹 先判断若first刚好是我们要找的Node时：直接返回first</span><br>        <span class="hljs-keyword">if</span> (first.hash == hash &amp;&amp; <span class="hljs-comment">// always check first node</span><br>            ((k = first.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>            <span class="hljs-keyword">return</span> first;<br>        <span class="hljs-comment">// 🔹 当first尾部还有元素（即有hash冲突）时，根据Node的结构取值。</span><br>        <span class="hljs-keyword">if</span> ((e = first.next) != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 🔸 红黑树：将Node转为TreeNode类型，并调用getTreeNode()取值。</span><br>            <span class="hljs-keyword">if</span> (first <span class="hljs-keyword">instanceof</span> TreeNode)<br>                <span class="hljs-keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);<br>            <span class="hljs-comment">// 🔸 链表：遍历取值。</span><br>            <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp; <span class="hljs-comment">// 判断hash值和key值都相同</span><br>                    ((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-keyword">return</span> e;<br>            &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 🔻 数组为空，返回null</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="（2）Remove-删除"><a href="#（2）Remove-删除" class="headerlink" title="（2）Remove() - 删除"></a>（2）Remove() - 删除</h3><pre class="mermaid">%%{
    init: {
    'themeVariables': {
        'fontSize': '13px'
    }
}   
}%%
graph TD
T(["<b>如何从HashMap<br>删除元素？</b>"]):::p
T --> B("先根据key找到桶位")
B --> A(["判断当前位置的元素<br>是否就要删除的值"]):::lp
A --> |"<b>是</b>"| C2["直接删除该元素"]:::b
A --> |"<b>否</b><br><i>（有hash冲突）</i>"| C(["判断为链表或红黑树"]):::lp
C --> |"<b>链表</b>"|a["将上个位置的指针<br>（跳过该值）指向下个位置"]:::b
C --> |"<b>红黑树</b>"|b["去掉当前节点后自平衡"]:::b
b -.- bt["<i>（树长度小于6时转为链表）</i>"]:::info

classDef info fill:#f6f6f7,color:#737379stroke-width: 3px, stroke-dasharray: 3 3
classDef p fill:#ddaebd
classDef b fill:#d9dfeb
classDef lp fill: #f4e4e9</pre>

<h4 id="remove"><a href="#remove" class="headerlink" title="- remove()"></a>- <em>remove()</em></h4><ul>
<li>删除元素  <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Removes the mapping for the specified key from this map if present.</span><br><span class="hljs-comment"> * 根据指定key删除映射。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>  key 要从map中删除映射的键</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 返回与键关联的前值，若前值为空返回null</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">remove</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>    Node&lt;K,V&gt; e;<br>    <span class="hljs-comment">// 🔻 调用removeNode()删除该键映射，若前值为空返回null，若前值非空返回前值。</span><br>    <span class="hljs-keyword">return</span> (e = removeNode(hash(key), key, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>)) == <span class="hljs-keyword">null</span> ?<br>        <span class="hljs-keyword">null</span> : e.value;<br>&#125;<br></code></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="removeNode"><a href="#removeNode" class="headerlink" title="- removeNode()"></a>- <em>removeNode()</em></h4><ul>
<li>删除Node  <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Implements Map.remove and related methods.</span><br><span class="hljs-comment"> * 实现删除和相关方法。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> hash       key的hash值</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> key        key</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> value      若有值时匹配该值</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> matchValue 若为真：仅值相等时删除</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> movable    为false:删除时不移动其他值</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 返回Node，若无该Node返回null</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title">removeNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, Object key, Object value,</span></span><br><span class="hljs-params"><span class="hljs-function">                           <span class="hljs-keyword">boolean</span> matchValue, <span class="hljs-keyword">boolean</span> movable)</span> </span>&#123;<br>    Node&lt;K,V&gt;[] tab; <span class="hljs-comment">// Node数组（引用当前hashMap的散列表）</span><br>    Node&lt;K,V&gt; p;     <span class="hljs-comment">// 当前Node元素：p</span><br>    <span class="hljs-keyword">int</span> n, index;    <span class="hljs-comment">// n：数组长度，index：数组下标</span><br>    <span class="hljs-comment">// 数组非空、当前索引位置的Node元素p非空</span><br>    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>        (p = tab[index = (n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-keyword">null</span>) &#123;<br>        Node&lt;K,V&gt; node = <span class="hljs-keyword">null</span>, e; <span class="hljs-comment">// 要删除的Node元素：node；当前节点的下个节点：e(=p.next)</span><br>        K k; V v; <span class="hljs-comment">// 当前元素p的key和value值</span><br>        <span class="hljs-comment">// 🔹 第一个位置刚好是要删除的元素：赋值给node，执行下方修改指针的代码</span><br>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>            ((k = p.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>            node = p;<br>        <span class="hljs-comment">// 🔹 存在哈希冲突时：根据链表或红黑树结构获取要删除的元素node</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((e = p.next) != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 🔸 红黑树：使用getTreeNode()获取元素，赋值给node。</span><br>            <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);<br>            <span class="hljs-comment">// 🔸 链表：用hash值和键值对遍历：赋值给node。</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">do</span> &#123;<br>                    <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                        ((k = e.key) == key ||<br>                         (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k)))) &#123;<br>                        node = e;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    p = e;<br>                &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 🔴 根据元素(node)的结构删除</span><br>        <span class="hljs-keyword">if</span> (node != <span class="hljs-keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||<br>                             (value != <span class="hljs-keyword">null</span> &amp;&amp; value.equals(v)))) &#123;<br>            <span class="hljs-comment">// 🔹 若要删除树结构节点：使用removeTreeNode()移除树节点</span><br>            <span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> TreeNode)<br>                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="hljs-keyword">this</span>, tab, movable);<br>            <span class="hljs-comment">// 🔹 若要删除Node节点上的元素（刚好是第一个元素）：将该节点赋值为下个元素</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node == p)<br>                tab[index] = node.next;<br>            <span class="hljs-comment">// 🔹 若要删除链表节点：指向其下个元素的next，将链表链接起来。</span><br>            <span class="hljs-keyword">else</span><br>                p.next = node.next;<br>            ++modCount; <span class="hljs-comment">// 记录修改次数（可以判断是否修改成功）</span><br>            --size; <span class="hljs-comment">// 数组长度自减</span><br>            afterNodeRemoval(node);<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="（3）Put-添加"><a href="#（3）Put-添加" class="headerlink" title="（3）Put() - 添加"></a>（3）Put() - 添加</h3><pre class="mermaid">%%{
    init: {
    'themeVariables': {
        'fontSize': '13px'
    }
}   
}%%
graph TD
T(["<b>如何向HashMap<br>添加元素？</b>"]):::p
T --> B("先根据key找到桶位")
B --> A(["判断当前索引是否<br>就是要添加元素的位置"]):::lp
A --> |"<b>无元素</b>"| C2["直接将元素添加到该位置"]:::b
A --> |"<b>有元素</b><br><i>（有hash冲突）</i>"| C(["判断为链表或红黑树"]):::lp
C --> |"<b>链表</b>"|a["将元素添加到链表尾部"]:::b
C --> |"<b>红黑树</b>"|b["将元素添加到树尾部"]:::b
a -.- at["<i>链表长度超过8、且桶数量大于64时转为树<br>（*桶数小于64时不会树化，只会扩容）</i>"]:::info

classDef info fill:#f6f6f7,color:#737379stroke-width: 3px, stroke-dasharray: 3 3

classDef p fill:#ddaebd
classDef b fill:#d9dfeb
classDef lp fill: #f4e4e9</pre>
<h4 id="put"><a href="#put" class="headerlink" title="+ put()"></a>+ <em>put()</em></h4><ul>
<li>添加元素<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Associates the specified value with the specified key in this map. If the map previously contained a mapping for the key, the old value is replaced.</span><br><span class="hljs-comment"> * 存值：将指定值与此映射中的指定键相关联。如果映射先前包含键的映射，则将替换旧值。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> key </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> value </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 返回被替换的原值</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;<br>    <span class="hljs-comment">// 调用putVal()方法存值</span><br>    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="putVal"><a href="#putVal" class="headerlink" title="- putVal()"></a>- <em>putVal()</em></h4><ul>
<li>赋值方法（若key已有值时默认替换）<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Implements Map.put and related methods.</span><br><span class="hljs-comment">    * 实现了Map赋值以及相关方法。</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> hash         key的hash值</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> key          key值</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> value        需要赋的值</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> onlyIfAbsent 是否保留原值（默认为false：会替换原值）</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> evict        false:表处于创建状态</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> 返回前值，如果没有则为空</span><br><span class="hljs-comment">    */</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent,</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-keyword">boolean</span> evict)</span> </span>&#123;<br>    Node&lt;K,V&gt;[] tab; <span class="hljs-comment">// Node数组</span><br>    Node&lt;K,V&gt; p; <span class="hljs-comment">// Node</span><br>    <span class="hljs-keyword">int</span> n, i; <span class="hljs-comment">// n：数组长度， i：数组索引</span><br>    <span class="hljs-comment">// 🔴 一、若空数组：初始化</span><br>    <span class="hljs-comment">//       当数组为空、长度为0时：扩容，并获得Node数组长度n（容量）</span><br>    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>        n = (tab = resize()).length;<br>    <span class="hljs-comment">// 🔴 二、若空索引：直接存</span><br>    <span class="hljs-comment">//       若传入的key计算出的索引位置无元素，则使用键值对在该位置上创建Node，putVal()完成。</span><br>    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-keyword">null</span>)<br>        tab[i] = newNode(hash, key, value, <span class="hljs-keyword">null</span>);<br>    <span class="hljs-comment">// 🔴 三、若索引非空：根据情况存值</span><br>    <span class="hljs-comment">//       可能有hash冲突，判断该Node是否为链表或红黑树进行存值。</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        Node&lt;K,V&gt; e; <span class="hljs-comment">// node</span><br>        K k; <span class="hljs-comment">// key</span><br>        <span class="hljs-comment">// 🔹 若p刚好在当前索引位置的第一个节点上（未涉及到链表或红黑树），将该Node赋值给e以备存值（当前Node的key值和传入的key值相等）</span><br>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>            ((k = p.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>            e = p;<br>        <span class="hljs-comment">// 🔹 TreeNode类型：通过putTreeVal()方法在红黑树上插入键值对，赋值给e以备存值。</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-keyword">this</span>, tab, hash, key, value);<br>        <span class="hljs-comment">// 🔹 链表类型：循环直到将元素插入链表尾部，赋值给e以备存值。</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> binCount = <span class="hljs-number">0</span>; ; ++binCount) &#123; <span class="hljs-comment">// binCount：链表节点个数</span><br>                <span class="hljs-comment">// 🔸 若已遍历到链表尾部：使用newNode()在尾部再添加一个新节点并存值。</span><br>                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-keyword">null</span>) &#123;<br>                    p.next = newNode(hash, key, value, <span class="hljs-keyword">null</span>);<br>                    <span class="hljs-comment">// * 若添加节点后链表的长度超过树化阈值：</span><br>                    <span class="hljs-comment">//   通过treeifyBin()将链表转化为红黑树，跳出循环，putVal()完成。</span><br>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                        treeifyBin(tab, hash);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">// 🔸 若还未遍历到尾部、且该节点的key值与传入key值相等：</span><br>                <span class="hljs-comment">//    则跳出循环，执行下方替换原值的判断。</span><br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-comment">// 🔸 继续循环遍历链表</span><br>                p = e;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 🔻 替换并输出原值（key已有值时）</span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span><br>            V oldValue = e.value;<br>            <span class="hljs-comment">// 若设置了替换原值、或原值为空时：存值</span><br>            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-keyword">null</span>)<br>                e.value = value;<br>            afterNodeAccess(e); <span class="hljs-comment">// 访问后回调（❓</span><br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br>    ++modCount; <span class="hljs-comment">// 记录修改次数（方便在迭代中检测结构性变化）</span><br>    <span class="hljs-comment">// 🔻 若存值后元素数量大于扩容阈值，则扩容。</span><br>    <span class="hljs-keyword">if</span> (++size &gt; threshold) <br>        resize();<br>    afterNodeInsertion(evict); <span class="hljs-comment">// 插入后回调（❓</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><strong>比较时先比较hash值，hash相同的时候，再使用equals方法进行比较</strong>：<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))<br></code></pre></td></tr></table></figure>
因为hash是整数，比较的性能一般要比<code>equals()</code>高很多，使用短路与：hash不同，就没有必要调用equals方法了，这样整体上可以提高比较性能。</li>
</ul>
<h4 id="putIfAbsent"><a href="#putIfAbsent" class="headerlink" title="+ putIfAbsent()"></a>+ <em>putIfAbsent()</em></h4><ul>
<li>赋值，且已有值时不进行覆盖<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">putIfAbsent</span><span class="hljs-params">(K key, V value)</span> </span>&#123;<br>    <span class="hljs-comment">// 🔻 与默认的put()区别在于第四个参数：onlyIfAbsent（为true时不覆盖原值）</span><br>    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="（4）-Resize-扩容"><a href="#（4）-Resize-扩容" class="headerlink" title="（4）*Resize() - 扩容"></a>（4）*Resize() - 扩容</h3><h4 id="①-何时扩容"><a href="#①-何时扩容" class="headerlink" title="① 何时扩容"></a>① 何时扩容</h4><pre class="mermaid">%%{
    init: {
        'themeVariables': {
            'fontSize': '14px'
        }
    }
}%%
graph TD
T(["<b>HashMap何时需要扩容？</b>"]):::p
T --> |"<b>1. 初始化</b>"| A("1. table为null 或长度为0时"):::lp
T --> |"<b>2. 存值</b>"| B("2. 添加元素且元素数量即将超过<br>扩容阈值（threshold）时"):::lp
B -.- |"<i>hreshold 可以由 tableSizeFor() 计算得到</i>"| b["tableSizeFor()：可以计算出大于当前方法入参值，<br>并且和当前方法入参值最接近的2的幂数。"]:::info
classDef p fill: #ddaebd
classDef lp fill: #f4e4e9
classDef lb fill: #d9dfeb
classDef info fill:#f6f6f7,color:#737379, stroke-width: 2px, stroke-dasharray: 3 3</pre>

<h4 id="②-如何扩容"><a href="#②-如何扩容" class="headerlink" title="② 如何扩容"></a>② 如何扩容</h4><ul>
<li><pre class="mermaid">%%{
  init: {
      'themeVariables': {
          'fontSize': '14px'
      }
  }
}%%
graph TD
T(["<b>HashMap如何扩容？</b>"]):::p
T --> A("<b>2倍扩容，创建新数组</b>")
A --> B("<b>移动元素到新数组</b><br><i>（重新计算hash）</i>")
B --> b(["判断元素类型调整位置"]):::lp
b -.-|"<b>单个值</b>"| b1["①原位置<br>② 原位置 + 原容量"]:::lb
b -.-|"<b>红黑树</b>"| b2["<i><b>split()分割树</b></i><br>①一棵：原位置<br>②另一棵：原位置 + 原容量"]:::lb
b -.-|"<b>链表</b>"| b3["①低位链表：原位置<br>②高位链表：原位置 + 原容量"]:::lb
b2 -.- b2t["若树节点数量≤6：转链表"]:::info
classDef p fill: #ddaebd
classDef lp fill: #f4e4e9
classDef lb fill: #d9dfeb
classDef info fill:#f6f6f7,color:#737379, stroke-width: 2px, stroke-dasharray: 3 3</pre></li>
<li><strong>调整位置的原因</strong>：<blockquote>
<p> 因为HashMap计算索引位置是根据<code>hash值 &amp; (当前容量 -1)</code>，因此当容量改变时，一些原本的索引位置也会发生改变。扩容的同时重新调整元素位置，取值时才能正确匹配到相应的键值对。</p>
</blockquote>
</li>
</ul>
<h4 id="③-如何调整位置"><a href="#③-如何调整位置" class="headerlink" title="③ 如何调整位置"></a>③ 如何调整位置</h4><ul>
<li><p><strong>元素位置如何改变？</strong></p>
<pre class="mermaid">%%{
  init: {
      'themeVariables': {
          'fontSize': '14px'
      }
  }
}%%
graph TD 
T(["<b>元素位置如何改变？</b>"]):::p
T --> A("<b>hash值 & 原长度</b>"):::lb
A --> a["结果为0，位置不变"]:::lp
A --> b["结果为1，在新位置"]:::lp
a -.- at["<i>如，原hash值=3（<b>原位置=3</b>），<br>数组长度16， hash & 16：</i><br> 0000 0011 // 3 <br> 0001 0000 // 16 <br> <b>0000 0000 // =0</b><br>则，新位置 = 原位置 = 3"]:::info
b -.- bt["<i>如，原hash值=19（<b>原位置=3</b>），<br>数组长度16，hash & 16：</i><br> 0001 0011 // 19 <br> 0001 0000 // 16 <br> <b>0001 0000 // =1</b><br>则，新位置 = 原位置 + 原容量 = 19"]:::info
classDef p fill: #ddaebd
classDef lp fill: #f4e4e9
classDef lb fill: #d9dfeb
classDef info fill:#f6f6f7,color:#737379, stroke-width: 2px, stroke-dasharray: 3 3</pre>
<p>  <strong>满足“<code>(e.hash &amp; oldCap)==0</code>”条件的节点可以继续在原索引位上存储，不满足该条件的节点则需要进行移动操作。</strong></p>
<blockquote>
<p> HashMap中，table数组都是以2的幂数进行扩容操作的，就是将原容量值左移1位。<br>  因此进行扩容操作后，各个K-V键值对节点是否仍能在原索引位上，取决于新增的一位（oldCap的值）在进行与运算时是否为0。</p>
</blockquote>
</li>
<li><p><strong><u>链表元素移动</u>：</strong><br><img src="https://equne.oss-cn-hangzhou.aliyuncs.com/typora/%E6%89%A9%E5%AE%B9%E7%A4%BA%E6%84%8F%E5%9B%BE.jpeg" alt="扩容示意图"></p>
<ol>
<li>满足“<code>(e.hash &amp; oldCap)==0</code>”条件的节点会构成新的单向链表，这个链表中的节点会按照<strong><u>原索引位</u></strong>顺序存储于新的HashMap集合的table数组中；</li>
<li>满足“<code>(e.hash &amp;oldCap) !=0</code>”条件的节点会构成另一个新的单向链表，并且将<strong><em>原索引值+原数组长度</em></strong>的计算结果作为<strong><u>新的索引值</u></strong>存储于新的HashMap集合的table数组中。</li>
</ol>
</li>
<li><p><strong><u>红黑树元素移动</u>：</strong><br><img src="https://equne.oss-cn-hangzhou.aliyuncs.com/typora/42265-00-198-2.jpeg" alt="42265-00-198-2"></p>
<ul>
<li><strong>将这棵红黑树拆分成两棵新的红黑树</strong>：（若红黑树中节点数≤6，会将树结构转为链表结构）<br>① 一棵红黑树（或链表）留在<strong><u>原索引位</u></strong>上，<br>② 另一棵红黑树（或链表）放到<strong><em>原索引值+原数组容量值</em></strong>计算结果对应的<strong><u>新索引位</u></strong>上。</li>
</ul>
</li>
</ul>
<h4 id="resize"><a href="#resize" class="headerlink" title="- resize()"></a><em>- resize()</em></h4><ul>
<li>扩容<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Initializes or doubles table size.  If null, allocates in accord with initial capacity target held in field threshold.</span><br><span class="hljs-comment"> * Otherwise, because we are using power-of-two expansion, the elements from each bin must either stay at same index, or move with a power of two offset in the new table.</span><br><span class="hljs-comment"> * 初始化或二倍扩容。若为空，根据阈值和初始容量分配。</span><br><span class="hljs-comment"> * 由于使用2次幂扩容，因此每个元素保持相同索引，或在新表中以二次幂偏移量移动。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> table</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;<br>    Node&lt;K,V&gt;[] oldTab = table; <span class="hljs-comment">// 原table</span><br>    <span class="hljs-keyword">int</span> oldCap = (oldTab == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : oldTab.length; <span class="hljs-comment">// 扩容前的table长度，若无元素返回0</span><br>    <span class="hljs-keyword">int</span> oldThr = threshold; <span class="hljs-comment">// 原阈值</span><br>    <span class="hljs-keyword">int</span> newCap, newThr = <span class="hljs-number">0</span>; <span class="hljs-comment">// 新长度、新阈值</span><br>    <span class="hljs-comment">// 🔴 一、设置扩容阈值</span><br>    <span class="hljs-comment">//  🔹 ① 若已初始化(原数组有元素)：检查数组长度并设置2倍扩容阈值。</span><br>    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//  🔸 若原数组长度超过最大容量值：—&gt; 已到达容量上值，无法再扩容，返回原表。</span><br>        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<br>            threshold = Integer.MAX_VALUE;<br>            <span class="hljs-keyword">return</span> oldTab;<br>        &#125;<br>        <span class="hljs-comment">//  🔸 若原数组长度2倍扩容后仍未超过容量上限，且原数组长度超过了默认初始容量：—&gt; 原扩容阈值设置为2倍。</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;<br>                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<br>            newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold</span><br>    &#125;<br>    <span class="hljs-comment">//  🔹 ② 若未初始化(原数组无元素)，但已设置过扩容阈值(&gt;0) ：将新数组长度设置为该扩容阈值。</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// initial capacity was placed in threshold</span><br>        newCap = oldThr;<br>    <span class="hljs-comment">//  🔹 ③ 若未初始化(原数组无元素)，且未设置过扩容阈值：使用系统设置的默认数组长度和默认阈值赋值。</span><br>    <span class="hljs-keyword">else</span> &#123;               <span class="hljs-comment">// zero initial threshold signifies using defaults</span><br>        newCap = DEFAULT_INITIAL_CAPACITY;<br>        newThr = (<span class="hljs-keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<br>    &#125;<br><br>    <span class="hljs-comment">// 🔴 二、检查扩容阈值</span><br>    <span class="hljs-comment">// 若新扩容阈值仍为0：使用新数组长度计算新的扩容阈值（并将数组长度限制在最大容量上限内）</span><br>    <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">float</span> ft = (<span class="hljs-keyword">float</span>)newCap * loadFactor;<br>        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-keyword">float</span>)MAXIMUM_CAPACITY ?<br>                    (<span class="hljs-keyword">int</span>)ft : Integer.MAX_VALUE);<br>    &#125;<br>    <span class="hljs-comment">// 设置扩容阈值</span><br>    threshold = newThr;<br><br>    <span class="hljs-comment">// 🔴 三、扩容</span><br>    <span class="hljs-meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br>    <span class="hljs-comment">// 🔹 新建数组</span><br>    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> Node[newCap]; <span class="hljs-comment">// 使用新的数组长度创建新数组</span><br>    table = newTab;<br>    <span class="hljs-comment">// 🔹 移动元素到新数组</span><br>    <span class="hljs-comment">//   - 若原数组为空，无需移动，直接返回该数组。</span><br>    <span class="hljs-comment">//   - 若原数组非空：移动数据到新数组。</span><br>    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 🔸 外层循环：遍历原数组元素</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;<br>            Node&lt;K,V&gt; e;<br>            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// 清空原值，便于GC回收。</span><br>                oldTab[j] = <span class="hljs-keyword">null</span>;<br>                <span class="hljs-comment">// ① 单个值</span><br>                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-keyword">null</span>)<br>                    newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e; <span class="hljs-comment">// 原位 或 +旧容量oldCap</span><br>                <span class="hljs-comment">// ② 红黑树：分割</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode)<br>                    ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-keyword">this</span>, newTab, j, oldCap);<br>                <span class="hljs-comment">// ③ 链表：</span><br>                <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// preserve order</span><br>                    <span class="hljs-comment">// 低位链表：位置不变</span><br>                    Node&lt;K,V&gt; loHead = <span class="hljs-keyword">null</span>, loTail = <span class="hljs-keyword">null</span>; <br>                    <span class="hljs-comment">// 高位链表：位置 + 容量</span><br>                    Node&lt;K,V&gt; hiHead = <span class="hljs-keyword">null</span>, hiTail = <span class="hljs-keyword">null</span>;<br>                    Node&lt;K,V&gt; next;<br>                    <span class="hljs-comment">// 🔸 内层循环：计算新节点的索引位置。</span><br>                    <span class="hljs-keyword">do</span> &#123;<br>                        next = e.next;<br>                        <span class="hljs-comment">// true：位置不变（低位链表）</span><br>                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-keyword">null</span>)<br>                                loHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                loTail.next = e;<br>                            loTail = e;<br>                        &#125;<br>                        <span class="hljs-comment">// false：位置 + 容量（高位链表）</span><br>                        <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-keyword">null</span>)<br>                                hiHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                hiTail.next = e;<br>                            hiTail = e;<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-keyword">null</span>);<br>                    <span class="hljs-comment">// 低位链表赋值</span><br>                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-keyword">null</span>) &#123;<br>                        loTail.next = <span class="hljs-keyword">null</span>;<br>                        newTab[j] = loHead;<br>                    &#125;<br>                    <span class="hljs-comment">// 高位链表赋值</span><br>                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-keyword">null</span>) &#123;<br>                        hiTail.next = <span class="hljs-keyword">null</span>;<br>                        newTab[j + oldCap] = hiHead;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 🔹 返回新数组</span><br>    <span class="hljs-keyword">return</span> newTab;<br>&#125;<br></code></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="5-内部类"><a href="#5-内部类" class="headerlink" title="5. 内部类"></a>5. 内部类</h2><h3 id="（1）Node"><a href="#（1）Node" class="headerlink" title="（1）Node"></a>（1）Node</h3><ul>
<li><p><strong>HashMap.Node类</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Basic hash bin node, used for most entries.  (See below for TreeNode subclass, and in LinkedHashMap for its Entry subclass.)</span><br><span class="hljs-comment"> * 基本hash的bin节点，用于大部分节点。（TreeNode子类见下文，Entry子类见LinkedHashMap。）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> hash;<br>    <span class="hljs-keyword">final</span> K key; <span class="hljs-comment">// final：由于key是计算元素排列位置的依据，因此一旦初始化就不允许改变。</span><br>    V value;<br>    Node&lt;K,V&gt; next; <span class="hljs-comment">// 下一个节点（因为需要用Node节点构建单向链表）</span><br><br>    Node(<span class="hljs-keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;<br>        <span class="hljs-keyword">this</span>.hash = hash;<br>        <span class="hljs-keyword">this</span>.key = key;<br>        <span class="hljs-keyword">this</span>.value = value;<br>        <span class="hljs-keyword">this</span>.next = next;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> K <span class="hljs-title">getKey</span><span class="hljs-params">()</span>        </span>&#123; <span class="hljs-keyword">return</span> key; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title">getValue</span><span class="hljs-params">()</span>      </span>&#123; <span class="hljs-keyword">return</span> value; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> key + <span class="hljs-string">&quot;=&quot;</span> + value; &#125;<br><br>    <span class="hljs-comment">// 🔻 重写hashCode()：将key的Hash值、value的Hash值进行异或运算。</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title">setValue</span><span class="hljs-params">(V newValue)</span> </span>&#123;<br>        V oldValue = value;<br>        value = newValue;<br>        <span class="hljs-keyword">return</span> oldValue;<br>    &#125;<br><br>    <span class="hljs-comment">// 🔻 重写equals()</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>        <span class="hljs-comment">// 🔹 ① 判断两个节点的内存起始地址相同</span><br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">this</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        <span class="hljs-comment">// 🔹 ② 判断两个Map类型节点的key和value值都相等</span><br>        <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> Map.Entry) &#123;<br>            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;<br>            <span class="hljs-keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;<br>                Objects.equals(value, e.getValue()))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>重写HashCode()</strong></p>
<blockquote>
<p>Java官方对重写对象的 <strong>hashCode()</strong> 方法有严格的要求 —— <b><em>若重写 <strong>hashCode()</strong> 方法，则需要重写相应的 <strong>equals()</strong> 方法</em></b>。</p>
</blockquote>
</li>
<li><p><strong>补充：Objects工具类</strong></p>
<pre class="mermaid">graph LR
T(["<b>Objects<br>工具类</b>"]):::p
T --> A("提供了进行对象比较、<br>检验的基本操作"):::lb
A --> 1(["compare(T, S, Comparator)"]):::lp
A --> 2(["<b>hashCode(Object)</b>"]):::lp
A --> 3(["hashCode(Object[])"]):::lp
A --> 4("isNull(Object)、<br>nonNull(Object)、<br>requireNonNull(Object)等"):::lp
A --> 5(["toString(Object)"]):::lp
1 -.- 1t["两个对象的比较操作"]
2 -.- 2t["计算对象Hash值"]
3 -.- 3t["计算多个对象的Hash值组合"]
4 -.- 4t["校验或确认当前对象是否为空"]
5 -.- 5t["返回对象的字符串信息"]
classDef p fill: #ddaebd
classDef lp fill: #f4e4e9
classDef lb fill: #d9dfeb</pre></li>
<li><p><strong><u>根据哈希值存取对象、比较对象</u>是计算机程序中一种重要的思维方式。</strong></p>
<blockquote>
<p>它使得存取对象主要依赖于自身Hash值，而不是与其他对象进行比较，存取效率也与集合大小无关，高达O(1)，即使进行比较，也利用Hash值提高比较性能。</p>
</blockquote>
</li>
</ul>
<h3 id="（2）TreeNode"><a href="#（2）TreeNode" class="headerlink" title="（2）TreeNode"></a>（2）TreeNode</h3><ul>
<li>TreeNode 继承自 <strong>LinkedHashMap.Entry</strong> 类。</li>
<li>HashMap集合使用 <strong>HashMap.TreeNode</strong> 类的对象表示红黑树中的节点，来构成红黑树。<blockquote>
<p>① 当某个索引位上的链表长度达到指定的阈值（默认为单向链表长度超过8）时，单向链表会转化为红黑树；<br>② 当红黑树中的节点足够少（默认为红黑树中的节点数量少于6个）时，红黑树会转换为单向链表。</p>
</blockquote>
<h4 id="属性"><a href="#属性" class="headerlink" title="- 属性"></a>- <em>属性</em></h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">LinkedHashMap</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;<br>    <span class="hljs-comment">// 父节点</span><br>    TreeNode&lt;K,V&gt; parent;  <span class="hljs-comment">// red-black tree links</span><br>    <span class="hljs-comment">// 左节点</span><br>    TreeNode&lt;K,V&gt; left;  <br>    <span class="hljs-comment">// 右节点</span><br>    TreeNode&lt;K,V&gt; right;  <br>    <span class="hljs-comment">// 前节点：删除时需要取消链接&quot;next&quot;</span><br>    TreeNode&lt;K,V&gt; prev;    <span class="hljs-comment">// needed to unlink next upon deletion</span><br>    <span class="hljs-comment">// 节点颜色：true红色；false黑色 </span><br>    <span class="hljs-keyword">boolean</span> red;<br><br>    <span class="hljs-comment">// 构造方法，参数：hash值、key、value、下一个Node节点</span><br>    TreeNode(<span class="hljs-keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;<br>        <span class="hljs-keyword">super</span>(hash, key, val, next);<br>    &#125;<br><br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// 还有构建红黑树、解构红黑树、添加节点、移除节点等方法</span><br>&#125;<br></code></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="getTreeNode"><a href="#getTreeNode" class="headerlink" title="- getTreeNode()"></a>- <em>getTreeNode()</em></h4><ul>
<li>获取红黑树节点  <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Calls find for root node. </span><br><span class="hljs-comment"> * 调用查找根节点</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> TreeNode&lt;K,V&gt; <span class="hljs-title">getTreeNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> h, Object k)</span> </span>&#123;<br>    <span class="hljs-comment">// 🔻 调用find()查找节点</span><br>    <span class="hljs-keyword">return</span> ((parent != <span class="hljs-keyword">null</span>) ? root() : <span class="hljs-keyword">this</span>).find(h, k, <span class="hljs-keyword">null</span>);<br>    <span class="hljs-comment">// 若根节点不为空，调用root节点查找；若根节点为空，使用this查找。</span><br>&#125;<br></code></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="find"><a href="#find" class="headerlink" title="- find()"></a>- <em>find()</em></h4><ul>
<li>查找树节点  <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Finds the node starting at root p with the given hash and key. The kc argument caches comparableClassFor(key) upon first use comparing keys.</span><br><span class="hljs-comment"> * 使用给定的key和hash值查找从根p开始的节点。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> TreeNode&lt;K,V&gt; <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;<br>    TreeNode&lt;K,V&gt; p = <span class="hljs-keyword">this</span>; <span class="hljs-comment">// 当前树形Node：p</span><br>    <span class="hljs-comment">// 遍历整树：</span><br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-keyword">int</span> ph, dir; <br>        K pk;<br>        TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q; <span class="hljs-comment">// 当前Node左节点、右节点、</span><br>        <span class="hljs-comment">// 若当前节点hash值较大：p取其左节点</span><br>        <span class="hljs-keyword">if</span> ((ph = p.hash) &gt; h)<br>            p = pl;<br>        <span class="hljs-comment">// 若当前节点hash值较小：p取其右节点</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ph &lt; h)<br>            p = pr;<br>        <span class="hljs-comment">// 若当前节点key值等于给定key值，返回当前节点</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((pk = p.key) == k || (k != <span class="hljs-keyword">null</span> &amp;&amp; k.equals(pk)))<br>            <span class="hljs-keyword">return</span> p;<br>        <span class="hljs-comment">// 若左节点为空，p取其右节点</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pl == <span class="hljs-keyword">null</span>)<br>            p = pr;<br>        <span class="hljs-comment">// 若右节点为空，p取其左节点</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pr == <span class="hljs-keyword">null</span>)<br>            p = pl;<br>        <span class="hljs-comment">// 根据compareTo比较</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((kc != <span class="hljs-keyword">null</span> ||<br>                    (kc = comparableClassFor(k)) != <span class="hljs-keyword">null</span>) &amp;&amp;<br>                    (dir = compareComparables(kc, k, pk)) != <span class="hljs-number">0</span>)<br>            p = (dir &lt; <span class="hljs-number">0</span>) ? pl : pr;<br>        <span class="hljs-comment">// 根据compareTo的结果，若右节点能找到：返回右节点</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((q = pr.find(h, k, kc)) != <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> q;<br>        <span class="hljs-comment">// 若compareTo的结果在左节点上：继续查找</span><br>        <span class="hljs-keyword">else</span><br>            p = pl;<br>    &#125; <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="split"><a href="#split" class="headerlink" title="- split()"></a><em>- split()</em></h4><ul>
<li>分割树结构（HashMap扩容时使用到的方法）<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Splits nodes in a tree bin into lower and upper tree bins, or untreeifies if now too small. Called only from resize; see above discussion about split bits and indices.</span><br><span class="hljs-comment">    * 分割该树为两棵树，若树太小则链化。</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> map </span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> tab table</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> index 被分割树的索引位置</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> bit 扩容前的原数组容量</span><br><span class="hljs-comment">    */</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> bit)</span> </span>&#123;<br>    TreeNode&lt;K,V&gt; b = <span class="hljs-keyword">this</span>; <span class="hljs-comment">// 当前树节点</span><br>    <span class="hljs-comment">// Relink into lo and hi lists, preserving order</span><br>    TreeNode&lt;K,V&gt; loHead = <span class="hljs-keyword">null</span>, loTail = <span class="hljs-keyword">null</span>;<br>    TreeNode&lt;K,V&gt; hiHead = <span class="hljs-keyword">null</span>, hiTail = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">int</span> lc = <span class="hljs-number">0</span>, hc = <span class="hljs-number">0</span>; <span class="hljs-comment">// 遍历时计算链表的长度</span><br>    <span class="hljs-comment">// 🔴 一、重新计算索引位置（遍历双向链表结构）</span><br>    <span class="hljs-keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="hljs-keyword">null</span>; e = next) &#123;<br>        <span class="hljs-comment">// 🔻 拆分：割断当前节点的next引用。</span><br>        next = (TreeNode&lt;K,V&gt;)e.next;<br>        e.next = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">// 🔹 原位置：</span><br>        <span class="hljs-keyword">if</span> ((e.hash &amp; bit) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 无需移动元素即可组成新链表：</span><br>            <span class="hljs-keyword">if</span> ((e.prev = loTail) == <span class="hljs-keyword">null</span>)<br>                loHead = e;<br>            <span class="hljs-keyword">else</span><br>                loTail.next = e;<br>            loTail = e;<br>            ++lc; <span class="hljs-comment">// 记录链表长度</span><br>        &#125;<br>        <span class="hljs-comment">// 🔹 新位置：</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> ((e.prev = hiTail) == <span class="hljs-keyword">null</span>)<br>                hiHead = e;<br>            <span class="hljs-keyword">else</span><br>                hiTail.next = e;<br>            hiTail = e;<br>            ++hc; <span class="hljs-comment">// 记录长度</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 🔴 二、移动元素（将两个新链表树化或取消树化）</span><br>    <span class="hljs-comment">//  🔹 0：原位置</span><br>    <span class="hljs-keyword">if</span> (loHead != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 🔸 若节点≤树化阈值：取消树化，转为链表</span><br>        <span class="hljs-keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)<br>            tab[index] = loHead.untreeify(map);<br>        <span class="hljs-comment">// 🔸 若节点≥树化阈值：树化</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 将链表存入table索引位置</span><br>            tab[index] = loHead;<br>            <span class="hljs-comment">// 确认链表存在元素后树化</span><br>            <span class="hljs-keyword">if</span> (hiHead != <span class="hljs-keyword">null</span>) <span class="hljs-comment">// (else is already treeified)</span><br>                loHead.treeify(tab);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 🔹 1：新位置（原位置 + 原容量）：同上</span><br>    <span class="hljs-keyword">if</span> (hiHead != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)<br>            tab[index + bit] = hiHead.untreeify(map);<br>        <span class="hljs-keyword">else</span> &#123;<br>            tab[index + bit] = hiHead;<br>            <span class="hljs-keyword">if</span> (loHead != <span class="hljs-keyword">null</span>)<br>                hiHead.treeify(tab);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><strong>🦋 红黑树中隐含的双向链表结构</strong>：<br>  ① 在将红黑树结构<strong>转换为链表结构</strong>的过程中，需要使用这个隐含的双向链表进行遍历；<br>  ② 在红黑树结构的<strong>拆分</strong>过程中，也需要使用这个隐含的双向链表进行遍历。</li>
</ul>
<h3 id="（3）Iterators"><a href="#（3）Iterators" class="headerlink" title="（3）Iterators"></a>（3）Iterators</h3><h4 id="nextNode"><a href="#nextNode" class="headerlink" title="- nextNode()"></a>- <em>nextNode()</em></h4><ul>
<li><p><strong>HashMap实现了Iterator(迭代器)接口。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashIterator</span> </span>&#123;<br>        Node&lt;K,V&gt; next;        <span class="hljs-comment">// 将返回的下个entry</span><br>        Node&lt;K,V&gt; current;     <span class="hljs-comment">// 当前 entry</span><br>        <span class="hljs-keyword">int</span> expectedModCount;  <span class="hljs-comment">// 用于快速失败的属性</span><br>        <span class="hljs-keyword">int</span> index;             <span class="hljs-comment">// 当前索引</span><br>    <br>    HashIterator() &#123;<br>        expectedModCount = modCount;<br>        Node&lt;K,V&gt;[] t = table;<br>        current = next = <span class="hljs-keyword">null</span>;<br>        index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span> &amp;&amp; size &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// advance to first entry</span><br>            <span class="hljs-keyword">do</span> &#123;&#125; <span class="hljs-keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="hljs-keyword">null</span>);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title">nextNode</span><span class="hljs-params">()</span> </span>&#123;<br>        Node&lt;K,V&gt;[] t;<br>        Node&lt;K,V&gt; e = next;<br>        <span class="hljs-comment">// 若modCount不等于expectedModCount：抛出异常</span><br>        <span class="hljs-keyword">if</span> (modCount != expectedModCount)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();<br>        <span class="hljs-comment">// 若指定Node为空：抛出异常</span><br>        <span class="hljs-keyword">if</span> (e == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();<br>        <span class="hljs-comment">// 若next指向的Node（即当前Node的next的值）不为空，且数组不为空：</span><br>        <span class="hljs-keyword">if</span> ((next = (current = e).next) == <span class="hljs-keyword">null</span> &amp;&amp; (t = table) != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 限定索引不超出长度、且下个位置仍有元素。</span><br>            <span class="hljs-keyword">do</span> &#123;&#125; <span class="hljs-keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="hljs-keyword">null</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> e;<br>    &#125;<br>    <span class="hljs-comment">// ... </span><br>    <span class="hljs-comment">// EntryIterator，继承自HashIterator</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EntryIterator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HashIterator</span></span><br><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;&gt; </span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Map.<span class="hljs-function">Entry&lt;K,V&gt; <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> nextNode(); &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p><strong>遍历元素时使用<code>modCount</code>属性判断HashMap是否发生结构性变化</strong></p>
<blockquote>
<p>🔹 <strong>属性</strong>：<br><strong>- <u>modCount</u></strong>：HashMap类中的一个成员变量，表示对HashMap的修改次数。（与ArrayList和LinkedList相同）<br><strong>- <u>expectedModCount</u></strong>：表示对hashMap修改次数的期望值，它的初始值为modCount。<br><strong>- <u>ConcurrentModificationException()</u>异常</strong>：此异常为了防止在使用Iterator遍历容器的同时又对容器作增加或删除操作，或者使用多线程操作。</p>
</blockquote>
<blockquote>
<p>🔹 <strong>说明</strong>：<br>HashMap的<strong>Iterator</strong>是<strong><em>fail-fast</em></strong>迭代器。每次发生结构性变化时modCount都会增加，而每次迭代器操作时都会检查expectedModCount是否与modCount相同，这样就能检测出结构性变化。当有其他线程改变了HashMap的结构（增加、删除、修改元素），将会抛出ConcurrentModificationExceptidon。</p>
</blockquote>
<blockquote>
<p>🔹 <strong>解决方法</strong>：<br>在遍历的过程中把需要删除的对象保存到一个集合中，等遍历结束后再调用removeAll方法来删除，或者通过Iterator的remove()方法移除元素。</p>
</blockquote>
</li>
</ul>
<p>　　</p>
<hr>
<p>参考：</p>
<ul>
<li>HashMap扩容部分：<a href="https://book.douban.com/subject/35689618/">《Java高并发与集合框架：JCF和JUC源码分析与实现》</a></li>
<li>内存结构示意图部分：<a href="https://book.douban.com/subject/30133440/">《Java编程的逻辑》</a></li>
</ul>
</div></article><div class="post-view__sidebar"><div class="sidebar"><div class="tocbot"><h2>Toc</h2><div class="toc__content"></div></div><h2>Links</h2><div class="sidebar__link"><ul><li><a href="https://github.com/equnee">Github</a></li><li><a href="https://codepen.io/equne">Codepen</a></li><li><a href="mailto:equne@qq.com">Mail</a></li></ul></div><h2>Friends</h2><div class="sidebar__friend"></div><h2>Archives</h2><div class="sidebar__archives"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/">2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/">2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a></li></ul></div><h2>Categories</h2><div class="sidebar__categories"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li></ul></div><h2>Tags</h2><div class="sidebar__tags"><ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Chain/" rel="tag">Chain</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HashMap/" rel="tag">HashMap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/I-O/" rel="tag">I/O</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mac/" rel="tag">Mac</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Markdown/" rel="tag">Markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mermaid/" rel="tag">Mermaid</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/singleton/" rel="tag">singleton</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/windows/" rel="tag">windows</a></li></ul></div></div></div></div><div class="horizontal-line" style="height: 1px"></div><div class="main__bottom"><div class="pre-next"><a class="pre-button" href="/note/Basics/IO/IO_RandomAccessFile/">IO - RandomAccessFile 任意访问文件</a><a class="next-button" href="/note/Design-pattern/design-pattern_Chain_of_Responsibility/">🌷《秒懂设计模式》—— 责任链模式</a></div><div id="comments"></div></div></div></div><div class="footer"><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span>©️2019-2023 Author By  <b><a class="link" href="https://github.com/equnee">equne</a></b></span><span>&nbsp;Powered By <b><a class="link" href="https://hexo.io/zh-cn/">hexo  </a></b></span><script type="text/javascript" id="maid-script" src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script><script>if (window.mermaid) {
  var options = JSON.parse(document.getElementById('maid-script').getAttribute('mermaidoptioins'));
  mermaid.initialize({
    theme: 'neutral',
    fontFamily: 'Noto Serif SC',
    startOnLoad: 'true'
  });
}</script></div><div class="darkmode-mask" id="darkmode-mask"></div><div class="sidebar__button"></div></body></html>