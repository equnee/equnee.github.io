<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=0"><meta name="description" content="IO - 输入/输出流⑵_实现类 [ 🍧 Peach ] "><meta name="theme-color"><title>IO - 输入/输出流⑵_实现类 [ 🍧 Peach ] </title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/css/mermaid.css"><script src="https://cdn.bootcss.com/highlight.js/9.6.0/highlight.min.js" defer></script><script src="/js/paper.js" defer></script><script src="https://www.googletagmanager.com/gtag/js?id=G-5GZQ6P3RMX" async></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-5GZQ6P3RMX');</script><script src="https://www.unpkg.com/valine/dist/Valine.min.js" defer></script><script>window.addEventListener('DOMContentLoaded', () => {
  new Valine({
    el: '#comments',
    appId: 'MJAdR7lH7cWVJLyn1Tgnw5Sj-gzGzoHsz',
    appKey: 'de2VP0VpE5bWgR2aA8wkwxn2',
    notify: false,
    verify: false,
    avatar: 'mp',
    placeholder: 'say something',
  })
})</script><script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js" defer></script><script>window.addEventListener('DOMContentLoaded', () => {
  tocbot.init({
    // Where to render the table of contents.
    tocSelector: '.toc__content',
    // Where to grab the headings to build the table of contents.
    contentSelector: '.article__content',
    // Which headings to grab inside of the contentSelector element.
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    // For headings inside relative or absolute positioned containers within content.
    hasInnerContainers: true,
    orderedList: false,
    collapseDepth: 2,
  });
})</script><link rel="preload" href="https://cdn.bootcss.com/highlight.js/9.6.0/styles/github.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.6.0/styles/github.min.css"><link rel="preload" href="https://fonts.googleapis.com/css?family=Abril+Fatface&amp;display=swap" as="style" onload="this.onload=null;this.rel='stylesheet'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface&amp;display=swap"><link rel="preload" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@300;400;500;600;700&amp;display=swap" as="style" onload="this.onload=null;this.rel='stylesheet'"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@300;400;500;600;700&amp;display=swap"><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css"><meta name="generator" content="Hexo 5.4.2"></head><body><div class="mask-border"></div><div class="head"><div class="head__inner"><h1><a href="/">🍧 Peach</a></h1><p>蜜桃学代码</p></div></div><div class="paper-container"><div class="main"><div class="location-bar"><div class="line-1"><div class="horizontal-line" style="height: 3px"></div></div><div class="line-2"><div class="horizontal-line" style="height: 1px"></div></div><p class="text">IO - 输入/输出流⑵_实现类</p><div class="switch-button"><input class="container_toggle" type="checkbox" id="switch" name="mode"><label for="switch">Toggle</label></div><div class="line-3"><div class="horizontal-line" style="height: 1px"></div></div></div><div class="main__2-col"><article class="post-view__article"><div class="article__infomation"><div class="posts-item"><h2 class="posts-item__title"><a href="">IO - 输入/输出流⑵_实现类</a></h2><span class="post__date">2023-05-09</span><a href="/tags/Java/"><span class="post__tags">#Java</span></a><a href="/tags/I-O/"><span class="post__tags">#I/O</span></a></div></div><div class="article__content"><div>
  <!--  bgcolor="#fdeff2" -->
    <table style="font-size:11px;width:100%;">
        <tr>
            <th colspan="2">java.io - 目录</th>
        </tr>
        <tr>
            <td rowspan="2" style="text-align:center">标准设备输入/输出</td>
            <td>
                <a href="https://equnee.github.io/note/Basics/IO/IO_StandardIO/">标准设备输入/输出：System</a>
            </td>
        </tr>
        <tr>
            <td>
                <a href="https://equnee.github.io/note/Basics/IO/IO_StandardIO/">控制台读写类：Console</a>
            </td>
        </tr>
        <tr>
            <td rowspan="3" style="text-align:center">文件基本处理</td>
            <td>
                <a href="https://equnee.github.io//note/Basics/IO/IO_File/">文件操作类：File</a>
            </td>
        </tr>
        <tr>
            <td>
                <a href="https://equnee.github.io//note/Basics/IO/IO_File/">文件搜索类：FileFilter、FilenameFilter</a>
            </td>
        </tr>
        <tr>
            <td>
                <a href="https://equnee.github.io/note/Basics/IO/IO_RandomAccessFile/">文件任意读写类：RandomAccessFile</a>
            </td>
        </tr>
        <tr>
      <td rowspan="3" style="text-align:center" bgcolor="#fdeff2"><b>输入/输出流</b></td>
            <td colspan="2">
                <a href="https://equnee.github.io/note/Basics/IO/IO_IO_1/">输入/输出流 - 分类</a>
            </td>
        </tr>
        <tr>
            <td colspan="2" bgcolor="#fdeff2">        
        <a href="https://equnee.github.io/note/Basics/IO/IO_IO_2/"><b>输入/输出流 - 实现类</b></a>
            </td>
        </tr>
        <tr>
            <td colspan="2">
                <a href="https://equnee.github.io/note/Basics/IO/IO_Object_serialization/">对象序列化</a>
            </td>
        </tr>
    </table>
</div>


<p><strong>流体系：</strong></p>
<table>
  <tr>
    <th>分类</th>
    <th>字节输入流</th>
    <th>字节输出流</th>
    <th>字符输入流</th>
    <th>字符输出流</th>
  </tr>
  <tr bgcolor="#fdeff2">
    <td><i>抽象类</i></td>
    <td><i>InputStream</i></td>
    <td><i>OutputStream</i></td>
    <td><i>Reader</i></td>
    <td><i>Writer</i></td>
  </tr>
  <tr>
  <td>转换类</td>
    <td></td>
    <td></td>
    <td>InputStream-<br>Reader</td>
    <td>OutputStream-<br>Writer</td>
  </tr>
  <tr>
    <td colspan="5" bgcolor="#e9f0e9" style="text-align:center;">第一类：数据源类</td>
  </tr>
  <tr>
    <td><b>文件</b></td>
    <td><b>File-<br>InputStream</b></td>
    <td><b>File-<br>OutputStream</b></td>
    <td><b>FileReader</b></td>
    <td><b>FilerWriter</b></td>
  </tr>
  <tr>
    <td>数组</td>
    <td>ByteArray-<br>InputStream</td>
    <td>ByteArray-<br>OutputStream</td>
    <td>CharArray-<br>Reader</td>
    <td>CharArray-<br>Writer</td>
  </tr>
  <tr>
    <td>对象</td>
    <td>Object-<br>InputStream</td>
    <td>Object-<br>OutputStream</td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td><b>字符串</b></td>
    <td><b>StringBuffer-<br>InputStream</b></td>
    <td></td>
    <td><b>StringReader</b></td>
    <td><b>StringWriter</b></td>
  </tr>
   <tr>
    <td colspan="5" bgcolor="#e9f0e9" style="text-align:center;">第二类：数据流串联类</td>
   </tr>
  <tr>
    <td>管道</td>
    <td>Pipe-<br>InputStream</td>
    <td>Pipe-<br>OutputStream</td>
    <td>PipeReader</td>
    <td>PipeWriter</td>
  </tr>
  <tr>
    <td>序列</td>
    <td>Sequence-<br>InputStream</td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td colspan="5" bgcolor="#e9f0e9" style="text-align:center;">第三类：数据流过滤类</td>
  </tr>
  <tr bgcolor="#fdeff2">
    <td><i>过滤</i></td>
    <td><i>Filter-<br>InputStream</i></td>
    <td><i>Filter-<br>OutputStream</i></td>
    <td><i>FilterReader</i></td>
    <td><i>FilterWriter</i></td>
  </tr>
    <tr>
    <td><b>缓冲</b></td>
    <td><b>Buffered-<br>InputStream</b></td>
    <td><b>Buffered-<br>OutputStream</b></td>
    <td><b>Buffered-<br>Reader</b></td>
    <td><b>Buffered-<br>Writer</b></td>
  </tr>
    <tr>
    <td>数据</td>
    <td>Data-<br>InputStream</td>
    <td>Data-<br>OutputStream</td>
    <td></td>
    <td></td>
  </tr>
    <tr>
    <td>行号</td>
    <td>LineNumber-<br>InputStream</td>
    <td></td>
    <td>LineNumber-<br>Reader</td>
    <td></td>
  </tr>
    <tr>
    <td>推回</td>
    <td>Pushback-<br>InputStream</td>
    <td></td>
    <td>Pushback-<br>Reader</td>
    <td></td>
  </tr>
    <tr>
    <td>格式化</td>
    <td></td>
    <td>PrintStream</td>
    <td></td>
    <td>PrintWriter</td>
  </tr>
</table>

<hr style="height:2px;border:none;border-top:1px dashed #dedede;"/>

<h2 id="（一）文件流"><a href="#（一）文件流" class="headerlink" title="（一）文件流"></a>（一）文件流</h2><pre class="mermaid">graph LR
T(["<b>文件流</b><br>（低级文件流）"]):::p
T --> t("<b>可操作文件<br>中的内容</b>"):::info
t --> A(["按照(读/写)<br><b>方向</b>分类"]):::p
t --> B(["按照(读/写)<br><b>字节数大小</b>分类"]):::b
A -.-> |"<i><b>in</b></i>（读取）"| a("<b>文件输入流</b><br><i>字节型文件输入流<br>字符型文件输入流</i>"):::lp
A -.-> |"<i><b>out</b></i>（写入）"| a2("<b>文件输出流</b><br><i>字节型文件输出流<br>字符型文件输出流</i>"):::lp
B -.-> |"<i><b>1字节</b></i>"| b("<b>字节型文件流</b><br>FileInputStream<br>FileOUtputStream"):::lb
B -.-> |"<i><b>1字符</b><br>（2字节）</i>"| b2("<b>字符型文件流</b><br>FileReader<br>FileWriter"):::lb

classDef p fill:#ddaebd
classDef b fill:#aab7d2
classDef g fill:#9ac5bb
classDef lp fill:#f4e4e9
classDef lb fill:#d9dfeb
classDef lg fill:#ddebe6
classDef info fill:#f6f6f7,color:#737379,stroke-dasharray: 3 3, stroke-width: 2px</pre>



<h3 id="（1）FileInputStram"><a href="#（1）FileInputStram" class="headerlink" title="（1）FileInputStram"></a>（1）FileInputStram</h3><p><code>字节型文件输入流</code></p>
<h4 id="继承关系"><a href="#继承关系" class="headerlink" title="* 继承关系"></a>* 继承关系</h4><p>继承于 <strong><em>InputStream</em></strong> 类（字节型输入流）</p>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="* 构造方法"></a>* 构造方法</h4><table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><em>（没有无参构造方法）</em></td>
<td></td>
</tr>
<tr>
<td><em>FileInputStram(File file)</em></td>
<td>通过File对象构造</td>
</tr>
<tr>
<td><em>FileInputStram(String name)</em></td>
<td>通过文件路径字符串构造</td>
</tr>
</tbody></table>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="* 常用方法"></a>* 常用方法</h4><table>
<thead>
<tr>
<th>常用方法</th>
<th>说明</th>
<th>返回值类型</th>
</tr>
</thead>
<tbody><tr>
<td><em>finalize()</em></td>
<td>GC对象回收</td>
<td></td>
</tr>
<tr>
<td><u><strong><em>available()</em></strong></u></td>
<td>返回当前流管道中有多少缓存字节，每次读取一个字节对应的 Unicode 码<em>。（读得到返回 0–65536，读不到返回-1）</em></td>
<td>int</td>
</tr>
<tr>
<td>🔺 <strong><u><em>read</em>()</u></strong></td>
<td>从输入流中读取单个字节，返回读取的字节数据（Unicode码）</td>
<td>int</td>
</tr>
<tr>
<td></td>
<td><strong><em>read(byte[])</em></strong>：将输入流内容写入数组里，返回实际读取的字节数。</td>
<td>int</td>
</tr>
<tr>
<td></td>
<td><strong><em>read(byte[] b, int off, int leng)</em></strong>：将输入流内容写入数组里，从off位置开始，放入len个字节（不是从数组起点开始），返回实际读取的字节数。</td>
<td>int</td>
</tr>
<tr>
<td><u><strong><em>skip()</em></strong></u></td>
<td>跳过几个字节读取</td>
<td>long n</td>
</tr>
<tr>
<td><u><strong><em>close()</em></strong></u></td>
<td>关闭流管道（⚠️ 必须要做，最好放在 <strong><em>finally{}</em></strong> 里）</td>
<td></td>
</tr>
</tbody></table>
<h5 id="read"><a href="#read" class="headerlink" title="- read()"></a>- <em>read</em>()</h5><p>创建一个字节型文件输入流，读取文件中的内容。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>    File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;D://Test//test.txt&quot;</span>);<br>    FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStram(file);<br>    <span class="hljs-keyword">int</span> i = fis.read(); <span class="hljs-comment">// ← 每次读取一个字节</span><br>    <span class="hljs-keyword">while</span>(i!=-<span class="hljs-number">1</span>)&#123;<br>        System.out.ptinln(i); <span class="hljs-comment">// → 返回字节对应得Unicode码</span><br>        i = fis.read(); <br>    &#125;<br>&#125;<span class="hljs-keyword">catch</span>(IOException e)&#123;<br>    e.printStackTrace;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h5 id="read-byte-b"><a href="#read-byte-b" class="headerlink" title="- read(byte[] b)"></a>- <em>read(byte[] b)</em></h5><p>读取文件内容，装入数组内。返回读取的有效字符个数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">try</span>&#123;<br>      FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStram(<span class="hljs-string">&quot;D://Test//test.txt&quot;</span>);<br>      <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> bytep[<span class="hljs-number">5</span>];	<br>      <span class="hljs-keyword">int</span> count = fis.read(b); <span class="hljs-comment">// ← 读取文件内容，装进数组里</span><br>      <span class="hljs-keyword">while</span>(count!=-<span class="hljs-number">1</span>)&#123;	<span class="hljs-comment">// → 返回读取到的有效字节个数</span><br>          <span class="hljs-comment">// 🔸 String value = new String(b);</span><br>          String value = <span class="hljs-keyword">new</span> String(b, <span class="hljs-number">0</span>, count);  <span class="hljs-comment">// 使用偏移量构造字节型数组字符串</span><br>          System.out.ptint(value); <span class="hljs-comment">// </span><br>          count = fis.read(b); <br>      &#125;<br>  &#125;<span class="hljs-keyword">catch</span>(IOException e)&#123;<br>      e.printStackTrace;<br>  &#125;<br><br><span class="hljs-comment">/* 文件内容：</span><br><span class="hljs-comment"> *	abcdefg</span><br><span class="hljs-comment"> *	hijklmn</span><br><span class="hljs-comment"> *	opq</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/* 🔸 直接使用String(b)读取内容：</span><br><span class="hljs-comment"> *	a  b  c  d  e</span><br><span class="hljs-comment"> *	f  g  \r \n h</span><br><span class="hljs-comment"> *	i  j  k  l  m </span><br><span class="hljs-comment"> *	n  \r \n o  p</span><br><span class="hljs-comment"> *	q  \r \n o  p  &lt;—— 到q结束，但是之前的没有被替换掉</span><br></code></pre></td></tr></table></figure>

<h5 id="skip"><a href="#skip" class="headerlink" title="- skip()"></a>- <em>skip()</em></h5><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;D://Test//test.txt&quot;</span>);<br>    fis.skip(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">int</span> code = fis.read();  <span class="hljs-comment">// c</span><br>    System.out.println((<span class="hljs-keyword">char</span>)code);<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure>



<h5 id="close"><a href="#close" class="headerlink" title="- close()"></a>- <em>close()</em></h5><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>    File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;D://Test//test.txt&quot;</span>);<br>    FileOutStream fos = <span class="hljs-keyword">new</span> FileOutStram(file);<br>    fos.write(<span class="hljs-number">97</span>);	<span class="hljs-comment">// 写入code码</span><br>    fos.flush();	<span class="hljs-comment">// 刷新 将管道中的字节推入文件中</span><br>&#125;<span class="hljs-keyword">catch</span>(IOException e)&#123;<br>    e.printStackTrace;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="（2）FileOutputStream"><a href="#（2）FileOutputStream" class="headerlink" title="（2）FileOutputStream"></a>（2）FileOutputStream</h3><p><code>字节型文件输出流</code></p>
<h4 id="继承关系-1"><a href="#继承关系-1" class="headerlink" title="* 继承关系"></a>* 继承关系</h4><p>继承于 <strong><em>OutputStream</em></strong> 类</p>
<h4 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="* 构造方法"></a>* 构造方法</h4><table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><em>（没有无参构造方法）</em></td>
<td></td>
</tr>
<tr>
<td><em>FileOutputStram(File file)</em></td>
<td>利用File对象构造<em>（默认覆盖原文）</em></td>
</tr>
<tr>
<td><em>FileOutputStram(File file, Boolean append)</em></td>
<td>利用File对象构造、是否将内容追加到文件末尾<em>（true：不覆盖）</em></td>
</tr>
<tr>
<td><em>FileOutputStram(String name)</em></td>
<td>通过文件路径字符串构造</td>
</tr>
<tr>
<td><em>FileOutputStram(String name, Boolean append)</em></td>
<td>通过文件路径构造、是否追加到文件末尾</td>
</tr>
</tbody></table>
<h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="* 常用方法"></a>* 常用方法</h4><table>
<thead>
<tr>
<th>常用方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>*finalize</strong>()*</td>
<td>GC对象回收</td>
</tr>
<tr>
<td><strong><em>write()</em></strong></td>
<td>写入到文件（与read()区别）</td>
</tr>
<tr>
<td></td>
<td><strong><em>write(int code)</em></strong>：将给定code写入文件 <em>（’=’字符char也行,会自动转换）</em></td>
</tr>
<tr>
<td></td>
<td><strong><em>write(byte[])</em></strong>： 将数组内容写入文件流里<em>（String—getByte()）</em></td>
</tr>
<tr>
<td><strong><em>flush()</em></strong></td>
<td>刷新：将管道内字节推入文件</td>
</tr>
<tr>
<td><strong><em>close()</em></strong></td>
<td><em>* 注意：在finally中关闭</em></td>
</tr>
</tbody></table>
<h5 id="write"><a href="#write" class="headerlink" title="- write()"></a>- <em>write()</em></h5><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>    File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;D://Test//test.txt&quot;</span>);<br>    FileOutStream fos = <span class="hljs-keyword">new</span> FileOutStram(file);<br>    fos.write(<span class="hljs-number">97</span>);	<span class="hljs-comment">// 写入code码</span><br>    fos.flush();	<span class="hljs-comment">// 刷新 将管道中的字节推入文件中</span><br>    &#125;<br>&#125;<span class="hljs-keyword">catch</span>(IOException e)&#123;<br>    e.printStackTrace;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="（3）FileReader"><a href="#（3）FileReader" class="headerlink" title="（3）FileReader"></a>（3）FileReader</h3><p><code>字符型文件输入流</code></p>
<h4 id="继承关系-2"><a href="#继承关系-2" class="headerlink" title="* 继承关系"></a>* 继承关系</h4><p>继承于<strong><em>InputStreamReader</em></strong> 类<em>（字节型输入流）</em></p>
<h4 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="* 构造方法"></a>* 构造方法</h4><table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><em>（没有无参构造方法）</em></td>
<td></td>
</tr>
<tr>
<td><em>FileReader(File file)</em></td>
<td>通过File对象构造<em>（默认覆盖原文）</em></td>
</tr>
<tr>
<td><em>FIleReader(String fileName)</em></td>
<td>通过文件路径字符串构造</td>
</tr>
<tr>
<td><em>FileReader(FileDescriptor fd)</em></td>
<td>通过文件描述符构建<br>（<em>文件描述符的有效范围是 0 到 OPEN_MAX</em>）</td>
</tr>
</tbody></table>
<h4 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="* 常用方法"></a>* 常用方法</h4><table>
<thead>
<tr>
<th>常用方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>🔺 <strong><em>read</em>()</strong></td>
<td>从输入流中读取单个字符，返回所读取的字符数据</td>
</tr>
<tr>
<td><em>int read(char[] cbuf)</em></td>
<td>从输入流中最多读取cbuf.length个字符的数据，并将其存储在字符数组cbuf中，返回实际读取的字符数。</td>
</tr>
<tr>
<td><em>int read(char[] cbuf, int off, int len)</em></td>
<td>从输入流中最多读取len个字符的数据，并将其存储在字符数组cbuf中，从off位置开始存储（并不是从数组起点开始），返回实际读取的字符数。</td>
</tr>
</tbody></table>
<h3 id="（4）FileWriter"><a href="#（4）FileWriter" class="headerlink" title="（4）FileWriter"></a>（4）FileWriter</h3><p><code>字符型文件输出流</code></p>
<h4 id="继承关系-3"><a href="#继承关系-3" class="headerlink" title="* 继承关系"></a>* 继承关系</h4><p>继承于 <strong><em>OutputStreamWriter</em></strong> 类 <em>（字节型输出流）</em></p>
<h4 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="* 构造方法"></a>* 构造方法</h4><table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><em>（没有无参构造方法）</em></td>
<td></td>
</tr>
<tr>
<td><em>FileWriter(File file)</em></td>
<td>利用File对象构建<em>（默认覆盖原文）</em></td>
</tr>
<tr>
<td><em>FileWriter(File file, Boolean boolean)</em></td>
<td>利用File对象构造、是否将内容追加到文件末尾<em>（true：不覆盖）</em></td>
</tr>
<tr>
<td><em>FileWriter(String name)</em></td>
<td>通过文件路径字符串构造</td>
</tr>
<tr>
<td><em>FileWriter(String name, Boolean boolean)</em></td>
<td>通过文件路径字符串构造、是否追加到文件末尾</td>
</tr>
</tbody></table>
<h4 id="常用方法-3"><a href="#常用方法-3" class="headerlink" title="* 常用方法"></a>* 常用方法</h4><table>
<thead>
<tr>
<th>常用方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong><em>write()</em></strong></td>
<td>读取</td>
</tr>
<tr>
<td><em>write(char)</em></td>
<td></td>
</tr>
<tr>
<td><em>write(String)</em></td>
<td></td>
</tr>
</tbody></table>
<h5 id="write-1"><a href="#write-1" class="headerlink" title="- write()"></a>- <em>write()</em></h5><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">String str = <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-keyword">char</span>[] c = str.toCharArray();<br>FileWriter fw = <span class="hljs-keyword">new</span> FileWriter(file);<br>fw.write(<span class="hljs-number">97</span>);<br>fw.write(c);<br></code></pre></td></tr></table></figure>



<h3 id="（5）Demo"><a href="#（5）Demo" class="headerlink" title="（5）Demo"></a>（5）Demo</h3><h4 id="①-文件的复制"><a href="#①-文件的复制" class="headerlink" title="① 文件的复制"></a>① 文件的复制</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OperateFile</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">copyFile</span><span class="hljs-params">(File file, String path)</span></span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 🔻 0 创建对象</span><br>            FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;D://test.txt&quot;</span>));<br>            File newFile = <span class="hljs-keyword">new</span> File(path + <span class="hljs-string">&quot;//&quot;</span> + file.gsetName());<br>            FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(newFile);<br>            <br>            <span class="hljs-comment">// 🔻 1 读取文件</span><br>            <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>]; <span class="hljs-comment">// 通常创建的数组：1kb-8kb之间</span><br>            <span class="hljs-keyword">int</span> count = fis.read(b); <span class="hljs-comment">// count记录读取的有效字节数，读取到byte数组b里</span><br>  <br>            <span class="hljs-comment">// 🔻 2 写入文件</span><br>            <span class="hljs-keyword">while</span>(count!=-<span class="hljs-number">1</span>)&#123; <span class="hljs-comment">// 当能读取到内容时</span><br>                          <br>            	<span class="hljs-comment">// 🔸（做点手脚）</span><br>                fos.write(b, <span class="hljs-number">0</span>, count); <span class="hljs-comment">// 写入有效字节数</span><br>                fos.flush();<br>                count = fis.read(b); <span class="hljs-comment">// 最后再次读取，读取不到内容时，count=-1时退出while循环</span><br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;复制完毕！&quot;</span>);<br>        <br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 关闭</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        OperateFile of = <span class="hljs-keyword">new</span> OperateFile();<br>        of.copyFile(<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;D://test.txt&quot;</span>), <span class="hljs-string">&quot;D://test&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="②-文件的加密"><a href="#②-文件的加密" class="headerlink" title="② 文件的加密"></a>② 文件的加密</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 读取文件 -&gt; 做点手脚 -&gt; 写入文件</span><br><span class="hljs-keyword">byte</span> temp = b[<span class="hljs-number">0</span>];<br>b[<span class="hljs-number">0</span>] = b[<span class="hljs-number">1</span>];<br>b[<span class="hljs-number">1</span>] = temp;<br></code></pre></td></tr></table></figure>

<h4 id="③-文件夹的复制"><a href="#③-文件夹的复制" class="headerlink" title="③ 文件夹的复制"></a>③ 文件夹的复制</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">superCopyFile</span><span class="hljs-params">(File file, String newPath)</span></span>&#123;<br><br>    String oldFilePath = file.getAbsolutePath();<br>    String newFilePath = newPath + oldFilePath.split(<span class="hljs-string">&quot;:&quot;</span>)[<span class="hljs-number">1</span>];<br><br>    File[] files = file.listFiles(); <span class="hljs-comment">// 获取当前传递进来的File对象的所有子元素</span><br>    File newFile = <span class="hljs-keyword">new</span> File(newFilePath);<br><br>    <span class="hljs-comment">// 判断当前传递进来的file是个文件还是个文件夹 （①isFile isDirectory  ②listFile)</span><br>    <span class="hljs-keyword">if</span>(files!=<span class="hljs-keyword">null</span>)&#123; <span class="hljs-comment">// 🔻 1. 文件夹（才能构成文件数组对象）</span><br>        newFile.mkdir();	<span class="hljs-comment">// 通过新的file对象操作 在硬盘上创建一个文件夹</span><br>        <span class="hljs-keyword">if</span>(files.length!=<span class="hljs-number">0</span>)&#123; <span class="hljs-comment">// 🔻 3. 文件夹内有文件              </span><br>            <span class="hljs-keyword">for</span>(File f:files)&#123;<br>                <span class="hljs-keyword">this</span>.superCopyFile(f, newPath); <span class="hljs-comment">// 👈 使用递归</span><br>            &#125;<br>        &#125;<br>        System.out.println(newFile.getName() + <span class="hljs-string">&quot;文件夹复制完成！&quot;</span>);<br><br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 🔻 2. 文件 （没有子文件了）</span><br><br>        FileInputStream fis = <span class="hljs-keyword">null</span>;<br>        FileOutputStream fos = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-keyword">new</span> File(oldFilePath));<br>            fos = <span class="hljs-keyword">new</span> FileOutputStream(newFile);<br>            <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>            <span class="hljs-keyword">int</span> count = fis.read(b);<br>            <span class="hljs-keyword">while</span>(count!=-<span class="hljs-number">1</span>)&#123;<br>                fos.write(b,<span class="hljs-number">0</span>,count);<br>                fos.flush();<br>                count = fis.read(b);<br>            &#125;<br>            System.out.println(newFile.getName() + <span class="hljs-string">&quot;文件复制完成！&quot;</span>);<br><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span>(fis!=<span class="hljs-keyword">null</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    fis.close();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (fos!=<span class="hljs-keyword">null</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    fos.close();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<br>

<hr style="height:2px;border:none;border-top:1px dashed #dedede;"/>

<h2 id="（二）对象流"><a href="#（二）对象流" class="headerlink" title="（二）对象流"></a>（二）对象流</h2><h3 id="（1）对象序列化"><a href="#（1）对象序列化" class="headerlink" title="（1）对象序列化"></a>（1）对象序列化</h3><pre class="mermaid">%%{
  init: {
    'themeVariables': {
       'fontSize': '12px'
     }
  }
}%%
graph LR
subgraph "应用层1"
A("<b>对象</b>"):::lb
end

subgraph "应用层2"
B("<b>对象</b>"):::lb
end

subgraph "网络协议"
C("<b><i>二进制流</i></b>"):::p
end

A --> |"<i>[ 转换 ]<br><b>ObjectOutputStream<br>FileOutputStream</i></b>"|C 
C --> |"<i>[ 还原 ]<br><b><u>ObjectInputStream</u><br>FileInputStream</i></b>"|B



style 网络协议 fill:#f4e4e9, stroke-dasharray: 3 3, stroke-width: 2px
classDef p fill:#ddaebd
classDef b fill:#aab7d2
classDef g fill:#9ac5bb
classDef lp fill:#f4e4e9
classDef lb fill:#d9dfeb
classDef lg fill:#ddebe6
classDef info fill:#f6f6f7,color:#3f3f3f,stroke-dasharray: 3 3, stroke-width: 1px</pre>

<ul>
<li><p><strong>序列化：对象的持久存储</strong></p>
<blockquote>
<ul>
<li><em>ObjectOutputStream</em> 和 <em>ObjectInputStream</em> 分别与 <em>FileOutputStream</em> 和 <em>FileInputStream</em> 一起使用，通过在流中使用文件可以实现<strong>对象的持久存储</strong>。</li>
<li><strong><em>ObjectInputStream</em></strong>：用于恢复那些已经序列化存储的对象。确保从流创建的图形中所有对象的类型与Java虚拟机中显示的类相匹配。</li>
</ul>
</blockquote>
</li>
<li><p><strong>序列化细节：</strong></p>
<blockquote>
<ol>
<li>读写顺序要一致<i>（对象类型转换异常：java.io.OptionalDataException）</i></li>
<li>要求必须实现 <strong><em>Serializable</em></strong> 或 <strong><em>Externalizable</em></strong> 接口</li>
<li>在序列化类中添加 <strong><em>SerialVersionUID</em></strong>，提高版本兼容性</li>
<li>序列化对象时默认所有属性都序列化，除 <strong><em>static</em></strong> 和 <strong><em>transit</em></strong></li>
<li>序列化<strong>可继承性</strong>，若某类实现序列化，其子类也默认实现序列化</li>
</ol>
</blockquote>
</li>
</ul>
<h3 id="（2）方法"><a href="#（2）方法" class="headerlink" title="（2）方法"></a>（2）方法</h3><ul>
<li><p><strong><em>readObject()</em></strong></p>
<blockquote>
<p><strong><em>readObject()</em></strong>：负责读取通过对应的 <strong><em>writeObject()</em></strong> 方法写入的数据，为特定类读取和恢复对象的状态。</p>
<p>恢复状态：从 ObjectInputStream 读取数据并将其分配给对象的适当字段。</p>
</blockquote>
</li>
<li><p>读取各种数据类型的函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 与 ObjectOutputStream write()相对应</span><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">readBoolean</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">// 读取一个boolean值</span><br><span class="hljs-function"><span class="hljs-keyword">byte</span> <span class="hljs-title">readByte</span><span class="hljs-params">()</span></span>;          <span class="hljs-comment">// 读取一个8位的字节</span><br><span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">readChar</span><span class="hljs-params">()</span></span>;          <span class="hljs-comment">// 读取一个16位的char值</span><br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">readDouble</span><span class="hljs-params">()</span></span>;      <span class="hljs-comment">// 读取一个 64 位的double值</span><br><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">readFloat</span><span class="hljs-params">()</span></span>;        <span class="hljs-comment">// 读取一个 32 位的float值</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">readInt</span><span class="hljs-params">()</span></span>;            <span class="hljs-comment">// 读取一个 32 位的int值</span><br><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">readLong</span><span class="hljs-params">()</span></span>;          <span class="hljs-comment">// 读取一个 64 位的long值</span><br><span class="hljs-function"><span class="hljs-keyword">short</span> <span class="hljs-title">readShort</span><span class="hljs-params">()</span></span>;        <span class="hljs-comment">// 读取一个 16 位的short值</span><br><br><span class="hljs-comment">// 从序列化流读取类描述符</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span>  ObjectStreamClass <span class="hljs-title">readClassDescriptor</span><span class="hljs-params">()</span></span>;    <br><span class="hljs-comment">// 按名称从流中读取持久字段并使其可用</span><br>ObjectInputStream.<span class="hljs-function">GetField <span class="hljs-title">readFields</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">// 允许子类读取并验证它们自己的流头部</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">readStreamHeader</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">// 从 ObjectInputStream 读取“非共享”对象</span><br><span class="hljs-function">Object <span class="hljs-title">readUnshared</span><span class="hljs-params">()</span></span>;                                 <br></code></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="（3）示例"><a href="#（3）示例" class="headerlink" title="（3）示例"></a>（3）示例</h3><h4 id="①-对象序列化"><a href="#①-对象序列化" class="headerlink" title="① 对象序列化"></a>① 对象序列化</h4><ul>
<li><p><strong><em>Person</em></strong> 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123; <br><span class="hljs-comment">// 🔹 使用Serializable来实现序列化，让目标类实现Serializable标记接口</span><br>  <br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-comment">// 注意此处没有提供无参数的构造器：🔻反序列化机制无须通过构造器来初始化Java对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name , <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>          System.out.println(<span class="hljs-string">&quot;有参数的构造器&quot;</span>);<br>          <span class="hljs-keyword">this</span>.name=name;<br>          <span class="hljs-keyword">this</span>.age=age;<br>    &#125;<br>    <span class="hljs-comment">// 省略name与age的setter和getter方法</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>使用 <strong><em>ObjectOutputStream</em></strong> 将一个Person对象写入磁盘文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WriteObject</span></span>&#123;<br>      <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span>(<br>              <span class="hljs-comment">// 🔹（1）创建一个ObjectOutputStream输出流</span><br>              ObjectOutputStream oos = <span class="hljs-keyword">new</span> ObjectOutputStream(<br>                  <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;object.txt&quot;</span>))) <span class="hljs-comment">// 这个输出流是一个处理流，所以必须建立在其他节点流（文件输出流）的基础之上</span><br>        &#123;<br>              Person per = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;孙悟空&quot;</span>, <span class="hljs-number">500</span>);<br>              <span class="hljs-comment">// 🔹（2）调用ObjectOutputStream对象的writeObject()方法输出可序列化对象</span><br>              oos.writeObject(per); <span class="hljs-comment">// 将per对象写入输出流</span><br>        &#125;<br>        <span class="hljs-keyword">catch</span> (IOException ex)&#123;<br>              ex.printStackTrace();<br>        &#125;<br>     &#125;<br>  &#125;<br><br><span class="hljs-comment">// 运行上面程序，将会看到生成了一个object.txt文件，该文件的内容就是Person对象。</span><br></code></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="②-对象反序列化"><a href="#②-对象反序列化" class="headerlink" title="② 对象反序列化"></a>② 对象反序列化</h4><ul>
<li><p>从刚刚生成的object.txt文件中读取Person对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReadObject</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span>(<br>              <span class="hljs-comment">// 🔹（1）创建一个ObjectInputStream输入流</span><br>              ObjectInputStream ois=<span class="hljs-keyword">new</span> ObjectInputStream(<br>                  <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;object.txt&quot;</span>))) <span class="hljs-comment">// 这个输入流是一个处理流，所以必须建立在其他节点流的基础之上。</span><br>        &#123;<br>              <span class="hljs-comment">// 🔹（2）从输入流中读取一个Java对象，并将其强制类型转换为Person类</span><br>              Person p = (Person)ois.readObject(); <span class="hljs-comment">// 调用ObjectInputStream对象的readObject()</span><br>              System.out.println(<span class="hljs-string">&quot;名字为：&quot;</span> + p.getName()<br>                  + <span class="hljs-string">&quot;\n年龄为：&quot;</span> + p.getAge());<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>              ex.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



</li>
</ul>
<br>

<hr style="height:2px;border:none;border-top:1px dashed #dedede;"/>

<h2 id="（三）转换流"><a href="#（三）转换流" class="headerlink" title="（三）转换流"></a>（三）转换流</h2><p>转换流（<strong><em>InputStreamReader</em></strong>、<strong><em>OutputStreamWriter</em></strong>），Reader的子类，可以将 InputStream 包装成 Reader。用于实现将<strong>字节流</strong>转换成<strong>字符流</strong>。—— 可解决文件乱码问题。</p>
<ul>
<li><p><strong><em>Demo</em></strong>：获取键盘输入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 该程序将 System.in 包装成 BufferedReader，</span><br><span class="hljs-comment">    BufferedReader流具有缓冲功能，它可以一次读取一行文本：</span><br><span class="hljs-comment">    以换行符为标志，若没有读到换行符，则程序阻塞，等到读到换行符为止。*/</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KeyinTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>          <span class="hljs-keyword">try</span>&#123;<br>                <span class="hljs-comment">// 将 Sytem.in 对象转换成 Reader 对象</span><br>                InputStreamReader reader = <span class="hljs-keyword">new</span> InputStreamReader(System.in);<br>                <span class="hljs-comment">// 将普通的Reader包装成BufferedReader</span><br>                BufferedReader br = <span class="hljs-keyword">new</span> BufferedReader(reader))<br>                String buffer = <span class="hljs-keyword">null</span>;<br>                <span class="hljs-comment">// 采用循环方式来逐行地读取</span><br>                <span class="hljs-keyword">while</span> ((buffer = br.readLine()) !=<span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-comment">//如果读取的字符串为&quot;exit&quot;，则程序退出</span><br>                    <span class="hljs-keyword">if</span> (buffer.equals(<span class="hljs-string">&quot;exit&quot;</span>)) &#123;<br>                          System.exit(<span class="hljs-number">1</span>);<br>                    &#125;<br>                    <span class="hljs-comment">//打印读取的内容</span><br>                    System.out.println(<span class="hljs-string">&quot;输入内容为:&quot;</span> + buffer);<br>                &#125;<br>          &#125; <span class="hljs-keyword">catch</span> (IOException ioe) &#123;<br>          		ioe.printStackTrace();<br>          &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><code>InputStreamReader</code></p>
<blockquote>
<p>Java使用 <strong><em>System.in</em></strong> 代表标准输入（即键盘输入），但这个标准输入流是 <em>InputStream</em> 类的实例，使用不太方便，且键盘输入内容都是文本内容，所以可用 <em>InputStreamReader</em> 将其转换成字符输入流。</p>
</blockquote>
<p><code>BufferedReader</code>：</p>
<blockquote>
<p>由于 <em>BufferedReader</em> 具有一个 <strong><em>readLine()</em></strong> 方法，可以非常方便地一次读入一行内容，所以经常把读取文本内容的输入流包装成 <em>BufferedReader</em>，用来方便地读取输入流的文本内容。</p>
</blockquote>
</li>
</ul>
<p><em>🔸 只有字节转字符：因为字符流比字节流操作更方便</em></p>
<br>

<hr style="height:2px;border:none;border-top:1px dashed #dedede;"/>

<h2 id="（四）管道流☕️"><a href="#（四）管道流☕️" class="headerlink" title="（四）管道流☕️"></a>（四）管道流☕️</h2><br>

<hr style="height:2px;border:none;border-top:1px dashed #dedede;"/>

<h2 id="（五）序列流"><a href="#（五）序列流" class="headerlink" title="（五）序列流"></a>（五）序列流</h2><p>SequenceInputStream 类允许连接多个 InputStream 流，表示其他输入流的<strong>逻辑串联</strong>。</p>
<pre class="mermaid">%%{
  init: {
    'themeVariables': {
       'fontSize': '12px'
     }
  }
}%%
graph
A([InputStream s1]):::lp
B([InputStream s2]):::lp
C([InputStream s3]):::lp
D([InputStream s1]):::lb
E([InputStream s2]):::lb

A --> B --> C
subgraph "<b><i>（2） SequenceInputStream(e)</i></b>"
subgraph "<i>Enumeration ⟨? extends InputStream⟩ e</i>"
A
B
C
end
end

subgraph "<b><i>（1） SequenceInputStream(s1, s2)</i></b>"
D --> E
end

classDef p fill:#ddaebd
classDef b fill:#aab7d2
classDef g fill:#9ac5bb
classDef lp fill:#f4e4e9
classDef lb fill:#d9dfeb
classDef lg fill:#ddebe6
classDef info fill:#f6f6f7,color:#3f3f3f,stroke-dasharray: 3 3, stroke-width: 1px</pre>

<blockquote>
<p><span style="font-size:13px;color:#4b4b4b">串联输入源：它从输入流的有序集合开始，从第一个输入流开始读取，读到文件末尾，接着从第二个输入流读取，依次类推，直到到达包含的最后一个输入流的文件末尾为止。</span></p>
</blockquote>
<p><strong>* 构造函数：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//（1）串联数据源</span><br>SequenceInputStream(InputStream s1,InputStream s2);  <span class="hljs-comment">// 将按顺序读取这两个参数，先读取s1，然后读取s2         </span><br><br><span class="hljs-comment">//（2）串联 Enumeration 类型的数据源列表</span><br>SequenceInputStream(Enumeration＜?extends InputStream＞e);  <br></code></pre></td></tr></table></figure>

<p><strong>* Demo</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** 将两个文件数据源串联起来，创建一个SequenceInputStream类型的数据源并输出文件内容到控制台中。 */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestSequenceInputStream</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 🔹 创建输入源数组</span><br>            <span class="hljs-comment">// * 串联的数据源列表中，可以包含各种InputStream实现类的数据流对象。</span><br>            FileInputStream fis1 = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;D:/demo/test.txt&quot;</span>);<br>            FileInputStream fis2 = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;D:/demo/test2.txt&quot;</span>);<br>            Vector＜FileInputStream＞ vector = <span class="hljs-keyword">new</span> Vector＜FileInputStream＞();<br>            vector.add(fis1);<br>            vector.add(fis2);<br>            Enumeration＜FileInputStream＞ e = vector.elements();<br><br>            <span class="hljs-comment">// 🔸 创建序列输入源</span><br>            SequenceInputStream is = <span class="hljs-keyword">new</span> SequenceInputStream(e);<br><br>            <span class="hljs-comment">// 🔹 从输入流读取数据</span><br>            <span class="hljs-keyword">while</span> (is.available() ＞ <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">int</span> c = is.read();<br>                System.out.print((<span class="hljs-keyword">char</span>)c);<br>            &#125;<br><br>            <span class="hljs-comment">// 🔹 关闭输入流</span><br>            is.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>





<br>

<hr style="height:2px;border:none;border-top:1px dashed #dedede;"/>

<h2 id="（六）过滤流☕️"><a href="#（六）过滤流☕️" class="headerlink" title="（六）过滤流☕️"></a>（六）过滤流☕️</h2><p>用于读取已过滤的字符流的抽象类。抽象类FilterReader自身提供了一些将所有请求传递给所包含的流的默认方法。FilterReader的子类应重写这些方法中的一些方法，并且还可以提供一些额外的方法和字段。通常并不单独使用它，而是使用它的子类。</p>
<br>

<hr style="height:2px;border:none;border-top:1px dashed #dedede;"/>

<h2 id="（七）缓冲流"><a href="#（七）缓冲流" class="headerlink" title="（七）缓冲流"></a>（七）缓冲流</h2><p>缓冲流主要为输入/输出流缓存数据，因此需要使用 <strong><em>flush()</em></strong> 方法强制将缓存中的数据真正写入到输出流中。（输入流对象的关闭顺序必须与其创建的顺序相反，后面的输出流也是如此。）</p>
<h3 id="（1）BufferedInpuStream"><a href="#（1）BufferedInpuStream" class="headerlink" title="（1）BufferedInpuStream"></a>（1）BufferedInpuStream</h3><p>BufferedInputStream为另一个输入流添加一些功能，即缓存输入的能力。</p>
<blockquote>
<p>在创建BufferedInputStream时，会创建一个内部缓存区数组。在读取或跳过流中的字节时，可根据需要从包含的输入流再次填充该内部缓存区，一次填充多个字节。</p>
</blockquote>
<p><strong>* Demo：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestBufferedInputStream</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 🔹创建输入流</span><br>            FileInputStream is = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;D:/demo/test.txt&quot;</span>);<br>            BufferedInputStream bis = <span class="hljs-keyword">new</span> BufferedInputStream(is);<br>            <span class="hljs-comment">// 🔹从输入流读取数据</span><br>            <span class="hljs-keyword">while</span> (bis.available() ＞ <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">int</span> c = bis.read();<br>                System.out.print((<span class="hljs-keyword">char</span>)c);<br>            &#125;<br><br>            <span class="hljs-comment">// 🔹关闭输入流</span><br>            bis.close();<br>            is.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        &#125;<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>



<h3 id="（2）BufferedOutputStream"><a href="#（2）BufferedOutputStream" class="headerlink" title="（2）BufferedOutputStream"></a>（2）BufferedOutputStream</h3><p>BufferedOutputStream 继承自 FilterOutputStream，它与 BufferedInputStream 相对应，主要为输出流做缓存。</p>
<p><strong>* demo</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** 将文件输入流对象os转换为缓存输出流 */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestBufferedOutputStream</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 🔹创建输出流</span><br>            FileOutputStream os = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;D:/demo/test.txt&quot;</span>);<br>            BufferedOutputStream bos = <span class="hljs-keyword">new</span> BufferedOutputStream(os);<br><br>            <span class="hljs-comment">// 🔹写入数组数据</span><br>            <span class="hljs-keyword">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">3</span>];<br>            buf[<span class="hljs-number">0</span>] = <span class="hljs-number">100</span>;<br>            buf[<span class="hljs-number">1</span>] = <span class="hljs-number">101</span>;<br>            buf[<span class="hljs-number">2</span>] = <span class="hljs-number">102</span>;<br>            bos.write(buf);<br><br>            <span class="hljs-comment">// 🔹关闭输出流</span><br>            bos.close();<br>            os.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 运行该程序，将会往文件中写入3个字符“def”。</span><br></code></pre></td></tr></table></figure>



<h3 id="（3）BufferedReader"><a href="#（3）BufferedReader" class="headerlink" title="（3）BufferedReader"></a>（3）BufferedReader</h3><p><em>BufferedReader</em> 从字符输入流中读取文本，缓存各个字符，以实现字符/数组/行的高效读取。</p>
<p><strong>* 构造方法：</strong></p>
<blockquote>
<p>📌 Reader所做的每个读取请求都会导致<u>对底层字符或字节流进行相应的读取请求</u>。<br>因此，建议用 <strong><em>BufferedReader</em></strong> 包装所有其 <strong><em>read()</em></strong> 操作可能开销很高的Reader（如 <em>FileReader</em> 和<em>InputStreamReader</em>）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">BufferedReader(Reader in);        <span class="hljs-comment">// 创建一个使用默认大小输入缓存区的缓存字符输入流</span><br>BufferedReader(Reader in,<span class="hljs-keyword">int</span> sz); <span class="hljs-comment">// 创建一个使用指定大小输入缓存区的缓存字符输入流</span><br></code></pre></td></tr></table></figure>

<p><strong>* Demo</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 组合使用 FileReader 和 BufferedReader：获得一个具有缓存的文件输入流</span><br><span class="hljs-comment"> */</span> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestBufferedReader</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 🔹创建输入流</span><br>            FileReader is = <span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;D:/demo/test.txt&quot;</span>);<br>            BufferedReader bis = <span class="hljs-keyword">new</span> BufferedReader(is);<br><br>            <span class="hljs-comment">// 🔹从输入流读取数据</span><br>            <span class="hljs-keyword">while</span> (bis.ready()) &#123;<br>                <span class="hljs-keyword">int</span> c = bis.read();<br>                System.out.print((<span class="hljs-keyword">char</span>)c);<br>            &#125;<br><br>            <span class="hljs-comment">// 🔹关闭输入流</span><br>            bis.close();<br>            is.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 运行该程序，将会输出文件中的内容到控制台中。</span><br></code></pre></td></tr></table></figure>

<h3 id="（4）BufferedWriter"><a href="#（4）BufferedWriter" class="headerlink" title="（4）BufferedWriter"></a>（4）BufferedWriter</h3><p><strong><em>BufferedWriter</em></strong> 将文本写入字符输出流，缓存各个字符，从而提供单个字符、数组和字符串的高效写入。 </p>
<p><strong>* 使用</strong></p>
<blockquote>
<p>📌 通常 Writer 将其输出<u>立即发送到底层字符或字节流</u>。除非要求提示输出，否则建议用 <strong><em>BufferedWriter</em></strong> 包装所有其 <strong><em>write()</em></strong> 操作可能开销很高的 <strong><em>Writer</em></strong>（如FileWriters和OutputStreamWriters）。例如以下案例将缓冲 PrintWriter 对文件的输出。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"> PrintWriter out = <span class="hljs-keyword">new</span> PrintWriter(<br>   <span class="hljs-keyword">new</span> BufferedWriter(<span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;foo.out&quot;</span>)));<br><br><span class="hljs-comment">// 若没有缓冲，则每次调用 print() 方法会导致将字符转换为字节，</span><br><span class="hljs-comment">// 然后立即写入到文件，而这是极其低效的。</span><br></code></pre></td></tr></table></figure>

<p><strong>* 输出换行</strong></p>
<blockquote>
<p>该类提供了 <strong><em>newLine()</em></strong> 方法，它使用平台自己的行分隔符概念，此概念由系统属性 <strong><em>line.separator</em></strong> 定义。</p>
<p>并非所有平台都使用新行符（<code>\n</code>）来终止各行。因此调用此方法来终止每个输出行要优于直接写入新行符。</p>
</blockquote>
<p><strong>* Demo</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** 将文件输入流对象os转换为缓存输出流。 */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestBufferedWriter</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 🔹 创建输出流</span><br>            FileWriter os = <span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;D:/demo/test.txt&quot;</span>);<br>            BufferedWriter bos = <span class="hljs-keyword">new</span> BufferedWriter(os);<br><br>            <span class="hljs-comment">// 🔹 写入数组数据</span><br>            <span class="hljs-keyword">char</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">3</span>];<br>            buf[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;a&#x27;</span>;<br>            buf[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;b&#x27;</span>;<br>            buf[<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;中&#x27;</span>;<br>            bos.write(buf);<br><br>            <span class="hljs-comment">// 🔹 关闭输出流</span><br>            bos.close();<br>            os.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 运行该程序，将会在文件中写入“ab中”。</span><br></code></pre></td></tr></table></figure>



<br>

<hr style="height:2px;border:none;border-top:1px dashed #dedede;"/>

<h2 id="（八）数据流☕️"><a href="#（八）数据流☕️" class="headerlink" title="（八）数据流☕️"></a>（八）数据流☕️</h2><br>

<hr style="height:2px;border:none;border-top:1px dashed #dedede;"/>

<h2 id="（九）行号输入流"><a href="#（九）行号输入流" class="headerlink" title="（九）行号输入流"></a>（九）行号输入流</h2><h3 id="（1）LineNumberInputStream"><a href="#（1）LineNumberInputStream" class="headerlink" title="（1）LineNumberInputStream"></a>（1）LineNumberInputStream</h3><p><strong><em>LineNumberInputStream</em></strong> 可跟踪行号、设置行号、对行做标记以便恢复等功能。  </p>
<table>
<thead>
<tr>
<th>名词</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>行</td>
<td>以回车符（<code>\r</code>）、换行符（<code>\n</code>）、回车符后紧跟的换行符（<code>\r\n</code>）<br>（三种情况）结尾的字节序列。</td>
</tr>
<tr>
<td>行号</td>
<td>以0开头，并在read返回换行符时递增1。</td>
</tr>
</tbody></table>
<p><strong>* 方法</strong>：<span style="color:#d63200;font-weight:bold">（Deprecated）</span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">getLineNumber();   <span class="hljs-comment">// 取得行号</span><br>setLineNumber();   <span class="hljs-comment">// 设置行号</span><br></code></pre></td></tr></table></figure>

<p><strong>* demo</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** </span><br><span class="hljs-comment"> *  按照文件的行读取，输出每一行的行号和内容。</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestLineNumberInputStream</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 🔹 创建文件输入流</span><br>            FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;D:/demo/test.txt&quot;</span>);<br>            <span class="hljs-comment">// 🔹 创建行号输入流</span><br>            LineNumberInputStream lis = <span class="hljs-keyword">new</span> LineNumberInputStream(fis);<br>            <span class="hljs-comment">// 🔹 创建数据输入流：通过DataInputStream 进行输入流过滤，获得readLine()的功能。</span><br>            DataInputStream dis = <span class="hljs-keyword">new</span> DataInputStream(lis);<br><br>            <span class="hljs-comment">// 🔸 读取数据</span><br>            String line;<br>            <span class="hljs-keyword">while</span> ((line = dis.readLine()) != <span class="hljs-keyword">null</span>) &#123;<br>                System.out.println(lis.getLineNumber() + <span class="hljs-string">&quot;:&quot;</span> + line);<br>            &#125;<br><br>            <span class="hljs-comment">// 关闭输入流</span><br>            dis.close();<br>            lis.close();<br>            fis.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//  1:hello,World!</span><br><span class="hljs-comment">//  2:hello,China!</span><br><span class="hljs-comment">//  3:Hello,Beijing!</span><br></code></pre></td></tr></table></figure>



<h3 id="（2）LineNumberReader"><a href="#（2）LineNumberReader" class="headerlink" title="（2）LineNumberReader"></a>（2）LineNumberReader</h3><p><strong>* 构造方法</strong>：</p>
<p>由于该类继承自BufferedReader，因此它拥有与BufferedReader相同的两个构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">LineNumberReader(Reader in);           <span class="hljs-comment">// 使用默认输入缓存区的大小创建新的行编号reader</span><br>LineNumberReader(Reader in,<span class="hljs-keyword">int</span> sz);    <span class="hljs-comment">// 创建新的行编号reader，将字符读入给定大小的缓存区</span><br></code></pre></td></tr></table></figure>



<p><strong>* 方法</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">getLineNumber();     <span class="hljs-comment">// 取得行号  </span><br>setLineNumber(<span class="hljs-keyword">int</span>);  <span class="hljs-comment">// 设置行号</span><br><br><span class="hljs-comment">// 注意：setLineNumber(int)不会实际更改流中的当前位置；它只更改由getLineNumber()返回的值</span><br></code></pre></td></tr></table></figure>



<p><strong>* demo</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  根据文件输入流fis创建行号输入流的方法，</span><br><span class="hljs-comment"> *  通过lis的readLine()方法可以读取一行数据，使用getLineNumber()取得行号，并输出行号和该行内容。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestLineNumberReader</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 🔹 创建文件输入流</span><br>            FileReader fis = <span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;D:/demo/test.txt&quot;</span>);<br>            <span class="hljs-comment">// 🔹 创建行号输入流</span><br>            LineNumberReader lis = <span class="hljs-keyword">new</span> LineNumberReader(fis);<br><br>            <span class="hljs-comment">// 🔸 读取数据</span><br>            String line;<br>            <span class="hljs-keyword">while</span> ((line = lis.readLine()) != <span class="hljs-keyword">null</span>) &#123;<br>                System.out.println(lis.getLineNumber() + <span class="hljs-string">&quot;:&quot;</span> + line);<br>            &#125;<br><br>            <span class="hljs-comment">// 关闭输入流</span><br>            lis.close();<br>            fis.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 1:hello,World!</span><br><span class="hljs-comment">// 2:hello,China!</span><br><span class="hljs-comment">// 3:Hello,Beijing!</span><br></code></pre></td></tr></table></figure>



<br>

<hr style="height:2px;border:none;border-top:1px dashed #dedede;"/>

<h2 id="（十）推回输入流"><a href="#（十）推回输入流" class="headerlink" title="（十）推回输入流"></a>（十）推回输入流</h2><p><em>PushbackInputStream</em> 和 <em>PushbackReader</em> 为另一个输入流添加性能，允许将字节(字符)推回到流中：即“<strong>推回（pushback）</strong>”或“<strong>取消读取（unread）</strong>”一个字节(字符)的能力。</p>
<ul>
<li><p><strong>PushbackInputStream 和 PushbackReader 的3个方法：</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><em>void <strong>unread</strong>(int b)</em></td>
<td>将一个字节/字符推回到推回缓冲区里，从而允许重复读取刚刚读取的内容。</td>
</tr>
<tr>
<td><em>void <strong>unread</strong>(byte[]/char[] buf)</em></td>
<td>将一个字节/字符数组内容推回到推回缓冲区里，从而允许重复读取刚刚读取的内容。</td>
</tr>
<tr>
<td><em>void <strong>unread</strong>(byte[]/char[] b, int off, int len)</em></td>
<td>将一个字节/字符数组里从off开始，长度为len字节/字符的内容推回到推回缓冲区里，从而允许重复读取刚刚读取的内容。</td>
</tr>
</tbody></table>
<p>  在读取终止字节(字符)后，代码片段可以“取消读取”该字节(字符)，这样，输入流上的下一个读取操作将会重新读取被推回的字节(字符)。</p>
</li>
</ul>
<ul>
<li><p><strong>处理示意图</strong></p>
<img src="https://equne.oss-cn-hangzhou.aliyuncs.com/typora/pushBack.jpg" alt="pushBack" style="zoom:25%;" />
</li>
<li><p><strong>需指定缓冲区大小</strong></p>
<p>当创建一个 <em>PushbackInputStream</em> 和 <em>PushbackReader</em> 时需要<strong>指定推回缓冲区的大小</strong>，默认的推回缓冲区的长度为1。</p>
<p>若程序中推回到推回缓冲区的内容超出了推回缓冲区的大小，将会引发 <strong><em>Pushback buffer overflow</em></strong> 的 <em>IOException</em> 异常。</p>
</li>
<li><p><strong>Demo</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestPushbackInputStream</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 创建文件输入流</span><br>            FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;D:/demo/test.txt&quot;</span>);<br>            <span class="hljs-comment">// 创建推回输入流</span><br>            PushbackInputStream pis = <span class="hljs-keyword">new</span> PushbackInputStream(fis);<br><br>            <span class="hljs-comment">// 读取对象数据</span><br>            <span class="hljs-keyword">int</span> c = pis.read();<br>            System.out.print((<span class="hljs-keyword">char</span>)c);<br>            pis.unread(c);  <span class="hljs-comment">// 🔻 推回一个字节</span><br>            c = pis.read();   <span class="hljs-comment">// 再次读取</span><br>            System.out.print((<span class="hljs-keyword">char</span>)c);<br><br>            <span class="hljs-comment">// 关闭输入流</span><br>            pis.close();<br>            fis.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 运行该程序将会重复输出第一个字符。</span><br></code></pre></td></tr></table></figure>




</li>
</ul>
<br>

<hr style="height:2px;border:none;border-top:1px dashed #dedede;"/>

<h2 id="（十一）打印流（格式化）"><a href="#（十一）打印流（格式化）" class="headerlink" title="（十一）打印流（格式化）"></a>（十一）打印流（格式化）</h2><h3 id="（1）PrintStream"><a href="#（1）PrintStream" class="headerlink" title="（1）PrintStream"></a>（1）PrintStream</h3><pre class="mermaid">%%{
  init: {
    'themeVariables': {
         'fontSize': '13px'
       }
    }
}%%
graph LR
A(["<b>PrintStream</b><i>（与OutputStream相比）</i>"]):::p
A -.-> a("添加了一组 <i><b>print() / println()</b></i> 方法，<br>可以打印各种数据类型，比较方便。"):::lp
A -.-> b("不会抛出<i><b>IOException</b></i>"):::lp
A -.-> c("<b>自动刷新机制</b>：<br>写入内容后自动调用flush()方法"):::lp

classDef p fill:#ddaebd
classDef lp fill:#f4e4e9</pre>



<ul>
<li><p>（字节型）<code>PrintStream</code> 是一种 <strong><em>FilterOutputStream</em></strong>，在 <em>OutputStream</em> 的接口上，额外提供了一些写入<strong>各种数据类型</strong>的方法。以及对应的一组 <em>println()</em> 方法（自动加上换行符）。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><em>void <strong>print</strong>(boolean)</em></td>
<td>将boolean类型数据对应字符串写到PrintStream流中</td>
</tr>
<tr>
<td><em>void <strong>print</strong>(char)</em></td>
<td>将char类型数据对应字符串写到PrintStream流中</td>
</tr>
<tr>
<td><em>void <strong>print</strong>(int)</em></td>
<td>将int类型数据对应字符串写到PrintStream流中</td>
</tr>
<tr>
<td><em>void <strong>print</strong>(long)</em></td>
<td>将long类型数据对应字符串写到PrintStream流中</td>
</tr>
<tr>
<td><em>void <strong>print</strong>(float)</em></td>
<td>将float类型数据对应字符串写到PrintStream流中</td>
</tr>
<tr>
<td><em>void <strong>print</strong>(double)</em></td>
<td>将double类型数据对应字符串写到PrintStream流中</td>
</tr>
<tr>
<td><em>void <strong>print</strong>(char[])</em></td>
<td>将字符串数组写到PrintStream流中</td>
</tr>
<tr>
<td><em>void <strong>print</strong>(String)</em></td>
<td>将字符串写到PrintStream流中</td>
</tr>
<tr>
<td><em>void <strong>print</strong>(Obj)</em></td>
<td>将对象对应字符串写到PrintStream中</td>
</tr>
</tbody></table>
<p>🔺 两方法写入数据时都会将数据转换成字符串，实际调用的方法：write(String s)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ptrint(<span class="hljs-number">0x61</span>) = write(String.valueOf(<span class="hljs-number">0x61</span>))<br></code></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="（2）PrintWriter"><a href="#（2）PrintWriter" class="headerlink" title="（2）PrintWriter"></a>（2）PrintWriter</h3><ul>
<li>（字符型）<code>PrintWriter</code>扩展了 <strong><em>Writer</em></strong> 接口，它的 <em>print() / println()</em> 方法最终输出的是 <strong>char</strong> 数据。使用方法同 <em>PrintStream</em>。</li>
</ul>
<h3 id="（3）重定向标准输入-输出"><a href="#（3）重定向标准输入-输出" class="headerlink" title="（3）重定向标准输入/输出"></a>（3）重定向标准输入/输出</h3><ul>
<li><p><strong>重定向标准输入/输出</strong></p>
<p>Java的<strong>标准输入/输出</strong>分别通过 <strong><em>System.in</em></strong>（从键盘输入）和 <strong><em>System.out</em></strong>（输出到屏幕）来代表。而 <em>System</em> 类里提供了如下3个重定向标准输入/输出的方法。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>static void <strong><em>setErr</em></strong>(PrintStream err)</td>
<td>重定向 “标准”错误输出流。</td>
</tr>
<tr>
<td>static void <strong><em>setIn</em></strong>(InputStream in)</td>
<td>重定向“标准”输入流。</td>
</tr>
<tr>
<td>static void <strong><em>setOut</em></strong>(PrintStream out)</td>
<td>重定向 “标准”输出流。</td>
</tr>
</tbody></table>
</li>
<li><p><strong>demo：重定向标准输出</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 通过重定向标准输出流，将System.out的输出重定向到文件输出，而不是在屏幕上输出。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedirectOut</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>          <span class="hljs-keyword">try</span>(<br>                <span class="hljs-comment">// 一次性创建PrintStream输出流</span><br>                PrintStream ps=<span class="hljs-keyword">new</span> PrintStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;out.txt&quot;</span>)))<br>          &#123;<br>                <span class="hljs-comment">// 将系统的标准输出重定向到ps输出流</span><br>                System.setOut(ps);<br>                <span class="hljs-comment">// 向标准输出输出一个字符串</span><br>                System.out.println(<span class="hljs-string">&quot;普通字符串&quot;</span>);<br>                <span class="hljs-comment">// 向标准输出输出一个对象</span><br>                System.out.println(<span class="hljs-keyword">new</span> RedirectOut());<br>          &#125;<br>          <span class="hljs-keyword">catch</span> (IOException ex)<br>          &#123;<br>                ex.printStackTrace();<br>          &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>该代码创建了一个 <strong><em>PrintStream</em></strong> 输出流，并将系统的标准输出重定向到该 <em>Print Stream</em> 输出流。运行该程序无任何输出：因为标准输出不再输出到屏幕，而是输出到 <em>out.txt</em> 文件。</p>
</li>
<li><p><strong>demo：重定向标准输入</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 下面程序重定向标准输入，从而可以将System.in重定向到指定文件，而不是键盘输入。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedirectIn</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>          <span class="hljs-keyword">try</span>(<br>                FileInputStream fis=<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;RedirectIn.java&quot;</span>))<br>          &#123;<br>                <span class="hljs-comment">// 将标准输入重定向到fis输入流</span><br>                System.setIn(fis);<br>                <span class="hljs-comment">// 使用System.in创建Scanner对象，用于获取标准输入</span><br>                Scanner sc=<span class="hljs-keyword">new</span> Scanner(System.in);<br>                <span class="hljs-comment">// 增加下面一行只把回车作为分隔符</span><br>                sc.useDelimiter(<span class="hljs-string">&quot;\n&quot;</span>);<br>                <span class="hljs-comment">// 判断是否还有下一个输入项</span><br>                <span class="hljs-keyword">while</span>(sc.hasNext())<br>                &#123;<br>                    <span class="hljs-comment">// 输出输入项</span><br>                    System.out.println(<span class="hljs-string">&quot;键盘输入的内容是：&quot;</span> + sc.next());<br>                &#125;<br>          &#125;<br>          <span class="hljs-keyword">catch</span> (IOException ex)<br>          &#123;<br>                ex.printStackTrace();<br>          &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>该代码创建了一个 <strong><em>FileInputStream</em></strong> 输入流，并使用 <em>System</em> 的 <strong><em>setIn</em>()</strong> 方法将系统标准输入重定向到该文件输入流。</p>
<p>运行上面程序，程序不会等待用户输入，而是直接输出了 <em>RedirectIn.java</em> 文件的内容，这表明程序不再使用键盘作为标准输入，而是使用指定文件作为标准输入源。</p>
</li>
</ul>
<p><br><br><br><p style="text-align:center;font-size:13px;color:#666666"> - <i>end</i> - </p> </p>
<hr>
<blockquote>
<p>🔖 笔记来自： </p>
<ul>
<li><a href="https://book.douban.com/subject/30133440/">《Java编程的逻辑》</a> </li>
<li><a href="https://book.douban.com/subject/3609215/">《Java高手真经（编程基础卷）》</a></li>
<li><a href="https://book.douban.com/subject/3246499/">《疯狂Java讲义》</a> </li>
</ul>
<p>📎 补充：</p>
<ul>
<li><a href="https://equnee.github.io/note/Basics/IO/IO_Object_serialization/">IO - 对象序列化</a></li>
</ul>
</blockquote>
</div></article><div class="post-view__sidebar"><div class="sidebar"><div class="tocbot"><h2>Toc</h2><div class="toc__content"></div></div><h2>Links</h2><div class="sidebar__link"><ul><li><a href="https://github.com/equnee">Github</a></li><li><a href="https://codepen.io/equne">Codepen</a></li><li><a href="mailto:equne@qq.com">Mail</a></li></ul></div><h2>Friends</h2><div class="sidebar__friend"></div><h2>Archives</h2><div class="sidebar__archives"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/">2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/">2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a></li></ul></div><h2>Categories</h2><div class="sidebar__categories"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li></ul></div><h2>Tags</h2><div class="sidebar__tags"><ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Chain/" rel="tag">Chain</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HashMap/" rel="tag">HashMap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/I-O/" rel="tag">I/O</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mac/" rel="tag">Mac</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Markdown/" rel="tag">Markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mermaid/" rel="tag">Mermaid</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/singleton/" rel="tag">singleton</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/windows/" rel="tag">windows</a></li></ul></div></div></div></div><div class="horizontal-line" style="height: 1px"></div><div class="main__bottom"><div class="pre-next"><a class="pre-button" href="/note/Basics/IO/IO_IO_1/">IO - 输入/输出流⑴_分类</a><a class="next-button" href="/note/Basics/IO/IO_File/">IO - File、FileFilter 和 FilenameFilter</a></div><div id="comments"></div></div></div></div><div class="footer"><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span>©️2019-2023 Author By  <b><a class="link" href="https://github.com/equnee">equne</a></b></span><span>&nbsp;Powered By <b><a class="link" href="https://hexo.io/zh-cn/">hexo  </a></b></span><script type="text/javascript" id="maid-script" src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script><script>if (window.mermaid) {
  var options = JSON.parse(document.getElementById('maid-script').getAttribute('mermaidoptioins'));
  mermaid.initialize({
    theme: 'neutral',
    fontFamily: 'Noto Serif SC',
    startOnLoad: 'true'
  });
}</script></div><div class="darkmode-mask" id="darkmode-mask"></div><div class="sidebar__button"></div></body></html>